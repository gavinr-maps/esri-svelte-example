import{n as A}from"./mat4-Fi6iAz29.js";import{e as T}from"./mat4f64-Dk4dwAN8.js";import{n as b}from"./vec3f64-BLpZdpfb.js";import{m as D}from"./computeTranslationToOriginAndRotation-BT43Xu5d.js";import{o as I}from"./projectBuffer-DOU0xvVi.js";import{t as $}from"./dehydratedFeatureUtils-1rrRm6hF.js";import{t as F,a as x}from"./ElevationProvider-aS5xrHHy.js";import{e as O}from"./VertexAttribute-Cq4MnHjR.js";import{n as N,e as z}from"./unitConversionUtils-C4AR5obr.js";import{D as P,B as w}from"./Accessor-BHnuXKD2.js";import{u as G}from"./hydratedFeatures-BVVSs98j.js";import{o as q}from"./opacityUtils-CSd4XoR2.js";function ce(e,t,n,r,o,a,s,i,u,f,c){const d=k[c.mode];let l,m,p=0;if(I(e,t,n,r,u.spatialReference,o,i))return d!=null&&d.requiresAlignment(c)?(p=d.applyElevationAlignmentBuffer(r,o,a,s,i,u,f,c),l=a,m=s):(l=r,m=o),I(l,u.spatialReference,m,a,f.spatialReference,s,i)?p:void 0}function R(e,t,n,r,o){const a=($(e)?e.z:F(e)?e.array[e.offset+2]:e[2])||0;switch(n.mode){case"on-the-ground":{const s=x(t,e,"ground")??0;return o.verticalDistanceToGround=0,o.sampledElevation=s,void(o.z=s)}case"relative-to-ground":{const s=x(t,e,"ground")??0,i=n.geometryZWithOffset(a,r);return o.verticalDistanceToGround=i,o.sampledElevation=s,void(o.z=i+s)}case"relative-to-scene":{const s=x(t,e,"scene")??0,i=n.geometryZWithOffset(a,r);return o.verticalDistanceToGround=i,o.sampledElevation=s,void(o.z=i+s)}case"absolute-height":{const s=n.geometryZWithOffset(a,r),i=x(t,e,"ground")??0;return o.verticalDistanceToGround=s-i,o.sampledElevation=i,void(o.z=s)}default:return void(o.z=0)}}function de(e,t,n,r){return R(e,t,n,r,E),E.z}function me(e,t,n){return t==="on-the-ground"&&n==="on-the-ground"?e.staysOnTheGround:t===n||t!=="on-the-ground"&&n!=="on-the-ground"?t==null||n==null?e.definedChanged:U.UPDATE:e.onTheGroundChanged}function pe(e){return e==="relative-to-ground"||e==="relative-to-scene"}function he(e){return e!=="absolute-height"}function Ee(e,t,n,r,o){R(t,n,o,r,E),S(e,E.verticalDistanceToGround);const a=E.sampledElevation,s=A(L,e.transformation);return v[0]=t.x,v[1]=t.y,v[2]=E.z,D(t.spatialReference,v,s,r.spatialReference)?e.transformation=s:console.warn("Could not locate symbol object properly, it might be misplaced"),a}function S(e,t){for(let n=0;n<e.geometries.length;++n){const r=e.geometries[n].getMutableAttribute(O.CENTEROFFSETANDDISTANCE);r&&r.data[3]!==t&&(r.data[3]=t,e.geometryVertexAttributeUpdated(e.geometries[n],O.CENTEROFFSETANDDISTANCE))}}function B(e,t,n,r,o,a){let s=0;const i=a.spatialReference;t*=3,r*=3;for(let u=0;u<o;++u){const f=e[t],c=e[t+1],d=e[t+2],l=a.getElevation(f,c,d,i,"ground")??0;s+=l,n[r]=f,n[r+1]=c,n[r+2]=l,t+=3,r+=3}return s/o}function W(e,t,n,r,o,a,s,i){let u=0;const f=i.calculateOffsetRenderUnits(s),c=i.featureExpressionInfoContext,d=a.spatialReference;t*=3,r*=3;for(let l=0;l<o;++l){const m=e[t],p=e[t+1],g=e[t+2],h=a.getElevation(m,p,g,d,"ground")??0;u+=h,n[r]=m,n[r+1]=p,n[r+2]=c==null?g+h+f:h+f,t+=3,r+=3}return u/o}function Z(e,t,n,r,o,a,s,i){let u=0;const f=i.calculateOffsetRenderUnits(s),c=i.featureExpressionInfoContext,d=a.spatialReference;t*=3,r*=3;for(let l=0;l<o;++l){const m=e[t],p=e[t+1],g=e[t+2],h=a.getElevation(m,p,g,d,"scene")??0;u+=h,n[r]=m,n[r+1]=p,n[r+2]=c==null?g+h+f:h+f,t+=3,r+=3}return u/o}function M(e){const t=e.meterUnitOffset,n=e.featureExpressionInfoContext;return t!==0||n!=null}function V(e,t,n,r,o,a,s,i){const u=i.calculateOffsetRenderUnits(s),f=i.featureExpressionInfoContext;t*=3,r*=3;for(let c=0;c<o;++c){const d=e[t],l=e[t+1],m=e[t+2];n[r]=d,n[r+1]=l,n[r+2]=f==null?m+u:u,t+=3,r+=3}return 0}class j{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}}var U;(function(e){e[e.NONE=0]="NONE",e[e.UPDATE=1]="UPDATE",e[e.RECREATE=2]="RECREATE"})(U||(U={}));const k={"absolute-height":{applyElevationAlignmentBuffer:V,requiresAlignment:M},"on-the-ground":{applyElevationAlignmentBuffer:B,requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:W,requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:Z,requiresAlignment:()=>!0}},L=T(),E=new j,v=b(),H=()=>w.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function J(e){return{cachedResult:e.cachedResult,arcade:e.arcade?{func:e.arcade.func,context:e.arcade.modules.arcadeUtils.createExecContext(null,{sr:e.arcade.context.spatialReference}),modules:e.arcade.modules}:null}}function ge(e){const t=e==null?void 0:e.expression;if(typeof t=="string"){const n=_(t);if(n!=null)return{cachedResult:n}}return null}async function xe(e,t,n,r){const o=e==null?void 0:e.expression;if(typeof o!="string")return null;const a=_(o);if(a!=null)return{cachedResult:a};const s=await q();P(n);const i=s.arcadeUtils,u=i.createSyntaxTree(o);return i.dependsOnView(u)?(r!=null&&r.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:i.createFunction(u),context:i.createExecContext(null,{sr:t}),modules:s}}}function K(e,t,n){return e.arcadeUtils.createFeature(t.attributes,t.geometry,n)}function Q(e,t){if(e!=null&&!C(e)){if(!t||!e.arcade)return void H().errorOncePerTick("Arcade support required but not provided");const n=t;n._geometry&&(n._geometry=G(n._geometry)),e.arcade.modules.arcadeUtils.updateExecContext(e.arcade.context,t)}}function X(e){if(e!=null){if(C(e))return e.cachedResult;const t=e.arcade;let n=t==null?void 0:t.modules.arcadeUtils.executeFunction(t.func,t.context);return typeof n!="number"&&(e.cachedResult=0,n=0),n}return 0}function ve(e,t=!1){let n=e==null?void 0:e.featureExpressionInfo;const r=n==null?void 0:n.expression;return t||r==="0"||(n=null),n??null}const Ue={cachedResult:0};function C(e){return e.cachedResult!=null}function _(e){return e==="0"?0:null}class y{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(t){this._unit=t,this._metersPerElevationInfoUnit=N(t)}get requiresSampledElevationInfo(){return this.mode!=="absolute-height"}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(t){this._meterUnitOffset=t,this._renderUnitOffset=0}set offsetElevationInfoUnits(t){this._meterUnitOffset=t*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(t){this._renderUnitOffset+=t}geometryZWithOffset(t,n){const r=this.calculateOffsetRenderUnits(n);return this.featureExpressionInfoContext!=null?r:t+r}calculateOffsetRenderUnits(t){let n=this._meterUnitOffset;const r=this.featureExpressionInfoContext;return r!=null&&(n+=X(r)*this._metersPerElevationInfoUnit),n/t.unitInMeters+this._renderUnitOffset}setFromElevationInfo(t){this.mode=t.mode,this.unit=z(t.unit)?t.unit:"meters",this.offsetElevationInfoUnits=t.offset??0}updateFeatureExpressionInfoContext(t,n,r){if(t==null)return void(this._featureExpressionInfoContext=null);const o=t==null?void 0:t.arcade;o&&n!=null&&r!=null?(this._featureExpressionInfoContext=J(t),Q(this._featureExpressionInfoContext,K(o.modules,n,r))):this._featureExpressionInfoContext=t}static fromElevationInfo(t){const n=new y;return t!=null&&n.setFromElevationInfo(t),n}}export{S as E,j as R,xe as a,ge as b,R as c,ve as d,Ue as e,de as f,he as g,U as h,pe as i,Q as l,me as m,y as o,Ee as p,K as s,ce as u};
