import{M as H}from"./mathUtils-ClvKsMak.js";import{k as b,a as A,x as B}from"./Polyline-BQFeqYXi.js";function Z(n,e,r,o){if(n.type==="point")return n.x+=e,n.y+=r,n.hasZ&&o!=null&&(n.z+=o),n;if(n.type==="multipoint"){const x=n.points;for(let a=0;a<x.length;a++)x[a]=C(x[a],e,r,o);return n}if(n.type==="extent")return n.xmin+=e,n.xmax+=e,n.ymin+=r,n.ymax+=r,n;const m=b(n),t=n.type==="polyline"?n.paths:n.rings;for(let x=0;x<m.length;x++){const a=m[x];for(let i=0;i<a.length;i++)a[i]=C(a[i],e,r,o)}return"paths"in n?n.paths=t:n.rings=t,n}function K(n,e,r,o,m){const t=n.clone(),x=o.resolution;if(t.type==="point"){if(m)Z(t,e*x,-r*x);else{const a=o.state.transform,i=o.state.inverseTransform,l=a[0]*t.x+a[2]*t.y+a[4],y=a[1]*t.x+a[3]*t.y+a[5];t.x=i[0]*(l+e)+i[2]*(y+r)+i[4],t.y=i[1]*(l+e)+i[3]*(y+r)+i[5]}return t}if(t.type==="multipoint"){if(m)Z(t,e*x,-r*x);else{const a=t.points,i=o.state.transform,l=o.state.inverseTransform;for(let y=0;y<a.length;y++){const c=a[y],p=i[0]*c[0]+i[2]*c[1]+i[4],M=i[1]*c[0]+i[3]*c[1]+i[5],f=l[0]*(p+e)+l[2]*(M+r)+l[4],u=l[1]*(p+e)+l[3]*(M+r)+l[5];a[y]=k(c,f,u,void 0)}}return t}if(t.type==="extent"){if(m)Z(t,e*x,-r*x);else{const a=o.state.transform,i=o.state.inverseTransform,l=a[0]*t.xmin+a[2]*t.ymin+a[4],y=a[1]*t.xmin+a[3]*t.ymin+a[5],c=a[0]*t.xmax+a[2]*t.ymax+a[4],p=a[1]*t.xmax+a[3]*t.ymax+a[5];t.xmin=i[0]*(l+e)+i[2]*(y+r)+i[4],t.ymin=i[1]*(l+e)+i[3]*(y+r)+i[5],t.xmax=i[0]*(c+e)+i[2]*(p+r)+i[4],t.ymax=i[1]*(c+e)+i[3]*(p+r)+i[5]}return t}if(m)Z(t,e*x,-r*x);else{const a=b(t),i=t.type==="polyline"?t.paths:t.rings,l=o.state.transform,y=o.state.inverseTransform;for(let c=0;c<a.length;c++){const p=a[c];for(let M=0;M<p.length;M++){const f=p[M],u=l[0]*f[0]+l[2]*f[1]+l[4],h=l[1]*f[0]+l[3]*f[1]+l[5],v=y[0]*(u+e)+y[2]*(h+r)+y[4],g=y[1]*(u+e)+y[3]*(h+r)+y[5];p[M]=k(f,v,g,void 0)}}"paths"in t?t.paths=i:t.rings=i}return t}function L(n,e,r,o){if(n.type==="point"){const{x:f,y:u}=n,h=o?o[0]:f,v=o?o[1]:u,g=n.clone(),d=(f-h)*e+h,s=(u-v)*r+v;return g.x=d,g.y=s,g}if(n.type==="multipoint"){const f=b(n),u=A(),[h,v,g,d]=B(u,[f]),s=o?o[0]:(h+g)/2,T=o?o[1]:(d+v)/2,q=n.clone(),j=q.points;for(let z=0;z<j.length;z++){const w=j[z],[D,E]=w,F=(D-s)*e+s,G=(E-T)*r+T;j[z]=k(w,F,G,void 0)}return q}if(n.type==="extent"){const{xmin:f,xmax:u,ymin:h,ymax:v}=n,g=o?o[0]:(f+u)/2,d=o?o[1]:(v+h)/2,s=n.clone();if(s.xmin=(f-g)*e+g,s.ymax=(v-d)*r+d,s.xmax=(u-g)*e+g,s.ymin=(h-d)*r+d,s.xmin>s.xmax){const T=s.xmin,q=s.xmax;s.xmin=q,s.xmax=T}if(s.ymin>s.ymax){const T=s.ymin,q=s.ymax;s.ymin=q,s.ymax=T}return s}const m=b(n),t=A(),[x,a,i,l]=B(t,m),y=o?o[0]:(x+i)/2,c=o?o[1]:(l+a)/2,p=n.clone(),M=p.type==="polyline"?p.paths:p.rings;for(let f=0;f<m.length;f++){const u=m[f];for(let h=0;h<u.length;h++){const v=u[h],[g,d]=v,s=(g-y)*e+y,T=(d-c)*r+c;M[f][h]=k(v,s,T,void 0)}}return"paths"in p?p.paths=M:p.rings=M,p}function N(n,e,r,o,m,t){const x=Math.sqrt((r-n)*(r-n)+(o-e)*(o-e));return Math.sqrt((m-n)*(m-n)+(t-e)*(t-e))/x}function O(n,e,r,o=!1){const m=Math.atan2(e.y-r.y,e.x-r.x)-Math.atan2(n.y-r.y,n.x-r.x),t=Math.atan2(Math.sin(m),Math.cos(m));return o?t:H(t)}function C(n,e,r,o){return k(n,n[0]+e,n[1]+r,n[2]!=null&&o!=null?n[2]+o:void 0)}function k(n,e,r,o){const m=[e,r];return n.length>2&&m.push(o??n[2]),n.length>3&&m.push(n[3]),m}export{N as a,K as i,O as m,L as s};
