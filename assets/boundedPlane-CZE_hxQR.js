import{n as en}from"./subclass-BR3PhgZG.js";import{t as _,r as u,P as h,s as I,b as y,g as l,c as p,d as P,x as an,J as cn,m as un,f as F,G as O,O as m,z as C,v as D,n as v}from"./mathUtils-ClvKsMak.js";import{s as J,x as gn}from"./sphere-7666U3LO.js";import{h as bn,s as fn,p as ln}from"./mat4-ybYUU6jq.js";import{e as L}from"./mat4f64-Dk4dwAN8.js";import{n as V}from"./Polyline-D97hl-6E.js";import{v as pn,A as R,j as dn}from"./lineSegment-BvgMMk26.js";import{E as w,U as z,v as mn,A as hn,c as e,T as In,S as $n,z as Pn,B as vn,D as W,J as Nn,a as N,F as M,O as Mn}from"./plane-Bz78OrLf.js";const E=()=>en.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class Tn{constructor(){this.plane=w(),this.origin=v(),this.basis1=v(),this.basis2=v()}}const wn=Tn;function $(n=tn){return{plane:w(n.plane),origin:_(n.origin),basis1:_(n.basis1),basis2:_(n.basis2)}}function An(n,o,i){const s=Gn.get();return s.origin=n,s.basis1=o,s.basis2=i,s.plane=mn(0,0,0,0),x(s),s}function A(n,o=$()){return X(n.origin,n.basis1,n.basis2,o)}function xn(n,o){u(o.origin,n.origin),u(o.basis1,n.basis1),u(o.basis2,n.basis2),hn(o.plane,n.plane)}function X(n,o,i,s=$()){return u(s.origin,n),u(s.basis1,o),u(s.basis2,i),x(s),Yn(s,"fromValues()"),s}function x(n){z(n.basis2,n.basis1,n.origin,n.plane)}function Z(n,o,i){n!==i&&A(n,i);const s=l(e.get(),f(n),o);return p(i.origin,i.origin,s),i.plane[3]-=o,i}function Sn(n,o,i){return H(o,i),Z(i,B(n,n.origin),i),i}function H(n,o=$()){const i=(n[2]-n[0])/2,s=(n[3]-n[1])/2;return P(o.origin,n[0]+i,n[1]+s,0),P(o.basis1,i,0,0),P(o.basis2,0,s,0),In(0,0,1,0,o.plane),o}function U(n,o,i){return!!$n(n.plane,o,i)&&sn(n,i)}function _n(n,o,i){if(U(n,o,i))return i;const s=K(n,o,e.get());return p(i,o.origin,l(e.get(),o.direction,an(o.origin,s)/I(o.direction))),i}function K(n,o,i){const s=T.get();rn(n,o,s,T.get());let r=Number.POSITIVE_INFINITY;for(const t of q){const a=G(n,t,S.get()),g=e.get();if(Pn(s,a,g)){const c=cn(e.get(),o.origin,g),b=Math.abs(un(h(o.direction,c)));b<r&&(r=b,u(i,g))}}return r===Number.POSITIVE_INFINITY?Q(n,o,i):i}function Q(n,o,i){if(U(n,o,i))return i;const s=T.get(),r=T.get();rn(n,o,s,r);let t=Number.POSITIVE_INFINITY;for(const a of q){const g=G(n,a,S.get()),c=e.get();if(vn(s,g,c)){const b=gn(o,c);if(!W(r,c))continue;b<t&&(t=b,u(i,c))}}return Y(n,o.origin)<t&&nn(n,o.origin,i),i}function nn(n,o,i){const s=Nn(n.plane,o,e.get()),r=R(k(n,n.basis1),s,-1,1,e.get()),t=R(k(n,n.basis2),s,-1,1,e.get());return F(i,p(e.get(),r,t),n.origin),i}function on(n,o,i){const{origin:s,basis1:r,basis2:t}=n,a=F(e.get(),o,s),g=N(r,a),c=N(t,a),b=N(f(n),a);return P(i,g,c,b)}function Y(n,o){const i=on(n,o,e.get()),{basis1:s,basis2:r}=n,t=I(s),a=I(r),g=Math.max(Math.abs(i[0])-t,0),c=Math.max(Math.abs(i[1])-a,0),b=i[2];return g*g+c*c+b*b}function yn(n,o){return Math.sqrt(Y(n,o))}function On(n,o){let i=Number.NEGATIVE_INFINITY;for(const s of q){const r=G(n,s,S.get()),t=dn(r,o);t>i&&(i=t)}return Math.sqrt(i)}function Vn(n,o){return W(n.plane,o)&&sn(n,o)}function En(n,o,i,s){return Un(n,i,s)}function B(n,o){const i=-n.plane[3];return N(f(n),o)-i}function jn(n,o,i,s){const r=B(n,o),t=l(Bn,f(n),i-r);return p(s,o,t),s}function zn(n,o){return O(n.basis1,o.basis1)&&O(n.basis2,o.basis2)&&O(n.origin,o.origin)}function Fn(n,o,i){return n!==i&&A(n,i),bn(d,o),fn(d,d),m(i.basis1,n.basis1,d),m(i.basis2,n.basis2,d),m(M(i.plane),M(n.plane),d),m(i.origin,n.origin,o),Mn(i.plane,i.plane,i.origin),i}function Jn(n,o,i,s){return n!==s&&A(n,s),ln(j,o,i),m(s.basis1,n.basis1,j),m(s.basis2,n.basis2,j),x(s),s}function f(n){return M(n.plane)}function Un(n,o,i){switch(o){case V.X:u(i,n.basis1),C(i,i);break;case V.Y:u(i,n.basis2),C(i,i);break;case V.Z:u(i,f(n))}return i}function sn(n,o){const i=F(e.get(),o,n.origin),s=D(n.basis1),r=D(n.basis2),t=h(n.basis1,i),a=h(n.basis2,i);return-t-s<0&&t-s<0&&-a-r<0&&a-r<0}function k(n,o){const i=S.get();return u(i.origin,n.origin),u(i.vector,o),i}function G(n,o,i){const{basis1:s,basis2:r,origin:t}=n,a=l(e.get(),s,o.origin[0]),g=l(e.get(),r,o.origin[1]);p(i.origin,a,g),p(i.origin,i.origin,t);const c=l(e.get(),s,o.direction[0]),b=l(e.get(),r,o.direction[1]);return l(i.vector,p(c,c,b),2),i}function Yn(n,o){Math.abs(h(n.basis1,n.basis2)/(I(n.basis1)*I(n.basis2)))>1e-6&&E().warn(o,"Provided basis vectors are not perpendicular"),Math.abs(h(n.basis1,f(n)))>1e-6&&E().warn(o,"Basis vectors and plane normal are not perpendicular"),Math.abs(-h(f(n),n.origin)-n.plane[3])>1e-6&&E().warn(o,"Plane offset is not consistent with plane origin")}function rn(n,o,i,s){const r=f(n);z(r,o.direction,o.origin,i),z(M(i),r,o.origin,s)}const tn={plane:w(),origin:y(0,0,0),basis1:y(1,0,0),basis2:y(0,1,0)},T=new J(w),S=new J(pn),Bn=v(),Gn=new J(()=>$()),q=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=L(),j=L(),Zn=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:wn,altitudeAt:B,axisAt:En,closestPoint:Q,closestPointOnSilhouette:K,copy:A,copyWithoutVerify:xn,create:$,distance:yn,distance2:Y,distanceToSilhouette:On,elevate:Z,equals:zn,extrusionContainsPoint:Vn,fromAABoundingRect:H,fromValues:X,intersectRay:U,intersectRayClosestSilhouette:_n,normal:f,projectPoint:nn,projectPointLocal:on,rotate:Jn,setAltitudeAt:jn,setExtent:Sn,transform:Fn,up:tn,updateUnboundedPlane:x,wrap:An},Symbol.toStringTag,{value:"Module"}));export{H as $,wn as G,X as H,x as J,$ as W,A as Z,Zn as _,yn as a,f as d,Fn as l,Jn as m,zn as p,U as s,Vn as u};
