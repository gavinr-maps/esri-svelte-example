import{n as m}from"./CollectionFlattener-CQN6i8ZK.js";import{r as l}from"./tslib.es6-B3Jf3DVX.js";import{V as h}from"./Collection-CEdjem1-.js";import{n as p}from"./collectionUtils-D_lHIu88.js";import{m as f,a as u,n as i}from"./subclass-BZA_h8Db.js";import{S as c}from"./Accessor-BLX9ikPh.js";import b from"./Layer-CVt7Hb5J.js";function M(n){return new m({getCollections:()=>[n.tables,n.layers],getChildrenFunction:s=>{const e=[];return"tables"in s&&e.push(s.tables),"layers"in s&&e.push(s.layers),e},itemFilterFunction:s=>{const e=s.parent;return!!e&&"tables"in e&&e.tables.includes(s)}})}function B(n){for(const s of n.values())s==null||s.destroy();n.clear()}function d(n,s,e){let t,a;if(n)for(let o=0,r=n.length;o<r;o++){if(t=n.at(o),(t==null?void 0:t[s])===e)return t;if((t==null?void 0:t.type)==="group"&&(a=d(t.layers,s,e),a))return a}}const I=n=>{let s=class extends n{constructor(...e){super(...e),this.layers=new h;const t=r=>{r.parent&&"remove"in r.parent&&r.parent.remove(r)},a=r=>{r.parent=this,this.layerAdded(r),r.type!=="elevation"&&r.type!=="base-elevation"||i.getLogger(this).error(`Layer 'title:${r.title}, id:${r.id}' of type '${r.type}' is not supported as an operational layer and will therefore be ignored.`)},o=r=>{r.parent=null,this.layerRemoved(r)};this.addHandles([this.layers.on("before-add",r=>{if(r.item===this)return r.preventDefault(),void i.getLogger(this).error("#add()","Cannot add layer to itself.");t(r.item)}),this.layers.on("after-add",r=>a(r.item)),this.layers.on("after-remove",r=>o(r.item))])}destroy(){const e=this.layers.toArray();for(const t of e)t.destroy();this.layers.destroy()}set layers(e){this._set("layers",p(e,this._get("layers")))}add(e,t){const a=this.layers;if(t=a.getNextIndex(t),e instanceof b){const o=e;o.parent===this?this.reorder(o,t):a.add(o,t)}else c(e)?e.then(o=>{this.destroyed||this.add(o,t)}):i.getLogger(this).error("#add()","The item being added is not a Layer or a Promise that resolves to a Layer.")}addMany(e,t){const a=this.layers;let o=a.getNextIndex(t);e.slice().forEach(r=>{r.parent!==this?(a.add(r,o),o+=1):this.reorder(r,o)})}findLayerById(e){return d(this.layers,"id",e)}findLayerByUid(e){return d(this.layers,"uid",e)}remove(e){return this.layers.remove(e)}removeMany(e){return this.layers.removeMany(e)}removeAll(){return this.layers.removeAll()}reorder(e,t){return this.layers.reorder(e,t)}layerAdded(e){}layerRemoved(e){}};return l([f()],s.prototype,"layers",null),s=l([u("esri.support.LayersMixin")],s),s};function y(n,s,e){if(n)for(let t=0,a=n.length;t<a;t++){const o=n.at(t);if(o[s]===e)return o;if((o==null?void 0:o.type)==="group"){const r=y(o.tables,s,e);if(r)return r}}}const T=n=>{let s=class extends n{constructor(...e){super(...e),this.tables=new h,this.addHandles([this.tables.on("after-add",t=>{const a=t.item;a.parent&&a.parent!==this&&"tables"in a.parent&&a.parent.tables.remove(a),a.parent=this,a.type!=="feature"&&i.getLogger(this).error(`Layer 'title:${a.title}, id:${a.id}' of type '${a.type}' is not supported as a table and will therefore be ignored.`)}),this.tables.on("after-remove",t=>{t.item.parent=null})])}destroy(){const e=this.tables.toArray();for(const t of e)t.destroy();this.tables.destroy()}set tables(e){this._set("tables",p(e,this._get("tables")))}findTableById(e){return y(this.tables,"id",e)}findTableByUid(e){return y(this.tables,"uid",e)}};return l([f()],s.prototype,"tables",null),s=l([u("esri.support.TablesMixin")],s),s};export{B as a,I as l,T as n,M as t};
