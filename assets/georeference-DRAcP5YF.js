import{cE as Ot,gG as St,cz as ft,gH as Et,gI as jt,g4 as Gt,fR as Nt,d as h,y as x,f as zt,aU as Lt,cl as J,gJ as Vt,cm as Bt,cD as C,gK as It,gL as pt,dD as Z,gM as Wt,cg as Ut,s as k,dE as G,gN as tt,eG as et,eF as rt,gO as kt,ck as Ht,gP as qt,gQ as Dt,gR as Yt,gE as z,gS as gt,gT as Jt,eR as Kt,ac as Qt,fT as nt,gU as Xt,g5 as Zt,bz as te,gV as ee}from"./index-B1qcMJFy.js";import{e as yt}from"./mat3f64-q3fE-ZOt.js";import{e as b,o as E}from"./mat4f64-CSKppSlJ.js";import{a as R,R as N}from"./computeTranslationToOriginAndRotation-cKPYaaYJ.js";import{t as ot,o as re}from"./DoubleArray-D7gNrzaD.js";import{v as mt,b as H,x as ne}from"./quat-9HFu1srU.js";import{e as K}from"./quatf64-Bdb9ZJJK.js";import"./vec4f64-CCf6w8sj.js";import{g as L,f as oe,u as ht}from"./meshVertexSpaceUtils-BNBosy7D.js";import{n as T,s as $t,i as ae,r as w}from"./vec3-DSi-VB0T.js";import{i as $,T as A}from"./BufferView-BM2WiAif.js";function d(t=dt){return[t[0],t[1],t[2],t[3]]}function j(t,e,r=d()){return Ot(r,t),r[3]=e,r}function Le(t,e=d()){const r=St(v,t);return At(e,ft(mt(e,r))),e}function at(t,e,r=d()){return H(v,t,q(t)),H(it,e,q(e)),ne(v,it,v),At(r,ft(mt(r,v)))}function Ve(t,e,r,n=d()){return j(Et,t,_),j(jt,e,st),j(Gt,r,lt),at(_,st,_),at(_,lt,n),n}function Be(t){return t}function ie(t){return t[3]}function q(t){return Nt(t[3])}function At(t,e){return t[3]=e,t}const dt=[0,0,1,0],v=K(),it=K();d();const _=d(),st=d(),lt=d();var D;let y=D=class extends Lt{constructor(t){super(t),this.translation=J(),this.rotationAxis=Vt(dt),this.rotationAngle=0,this.scale=Bt(1,1,1)}get rotation(){return j(this.rotationAxis,this.rotationAngle)}set rotation(t){this.rotationAxis=C(t),this.rotationAngle=ie(t)}get localMatrix(){const t=b();return H(ct,this.rotation,q(this.rotation)),It(t,ct,this.translation,this.scale),t}get localMatrixInverse(){return pt(b(),this.localMatrix)}applyLocal(t,e){return Z(e,t,this.localMatrix)}applyLocalInverse(t,e){return Z(e,t,this.localMatrixInverse)}equals(t){return this===t||t!=null&&Wt(this.localMatrix,t.localMatrix)}clone(){const t={translation:C(this.translation),rotationAxis:C(this.rotationAxis),rotationAngle:this.rotationAngle,scale:C(this.scale)};return new D(t)}};h([x({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"translation",void 0),h([x({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"rotationAxis",void 0),h([x({type:Number,nonNullable:!0,json:{write:!0}})],y.prototype,"rotationAngle",void 0),h([x({type:[Number],nonNullable:!0,json:{write:!0}})],y.prototype,"scale",void 0),h([x()],y.prototype,"rotation",null),h([x()],y.prototype,"localMatrix",null),h([x()],y.prototype,"localMatrixInverse",null),y=D=h([zt("esri.geometry.support.MeshTransform")],y);const ct=K(),ut=y;function Pt(t,e){return t.isGeographic||t.isWebMercator&&(e??!0)}function xt(t,e){switch(t.type){case"georeferenced":return e.isGeographic;case"local":return e.isGeographic||e.isWebMercator}}function Ie(t,e,r,n){if(n!==void 0){Ut(k.getLogger(t),"option: geographic",{replacement:"use mesh vertexSpace and spatial reference to control how operations are performed",version:"4.29",warnOnce:!0});const o=e.type==="local";if(!L(e)||n===o)return r.isGeographic||r.isWebMercator&&n;k.getLogger(t).warnOnce(`Specifying the 'geographic' parameter (${n}) for a Mesh vertex space of type "${e.type}" is not supported. This parameter will be ignored.`)}return xt(e,r)}const V=()=>k.getLogger("esri.geometry.support.meshUtils.normalProjection");function se(t,e,r,n,o){return I(n)?(B(m.TO_PCPF,$.fromTypedArray(t),A.fromTypedArray(e),A.fromTypedArray(r),n,$.fromTypedArray(o)),o):(V().error("Cannot convert spatial reference to PCPF"),o)}function le(t,e,r,n,o){return I(n)?(B(m.FROM_PCPF,$.fromTypedArray(t),A.fromTypedArray(e),A.fromTypedArray(r),n,$.fromTypedArray(o)),o):(V().error("Cannot convert to spatial reference from PCPF"),o)}function ce(t,e,r){return G(t,e,0,r,R(e),0,t.length/3),r}function ue(t,e,r){return G(t,R(r),0,e,r,0,t.length/3),e}function fe(t,e,r){return z(u,r),T(e,t,u),gt(u)||$t(e,e),e}function pe(t,e,r){if(z(u,r),T(e,t,u,4),gt(u)||$t(e,e,4),t!==e)for(let n=3;n<t.length;n+=4)e[n]=t[n];return e}function ge(t,e,r,n,o){if(!I(n))return V().error("Cannot convert spatial reference to PCPF"),o;B(m.TO_PCPF,$.fromTypedArray(t,4*Float32Array.BYTES_PER_ELEMENT),A.fromTypedArray(e),A.fromTypedArray(r),n,$.fromTypedArray(o,4*Float32Array.BYTES_PER_ELEMENT));for(let a=3;a<t.length;a+=4)o[a]=t[a];return o}function ye(t,e,r,n,o){if(!I(n))return V().error("Cannot convert to spatial reference from PCPF"),o;B(m.FROM_PCPF,$.fromTypedArray(t,16),A.fromTypedArray(e),A.fromTypedArray(r),n,$.fromTypedArray(o,16));for(let a=3;a<t.length;a+=4)o[a]=t[a];return o}function B(t,e,r,n,o,a){if(!e)return;const l=r.count,c=R(o);if(Ft(o))for(let i=0;i<l;i++)n.getVec(i,O),e.getVec(i,g),N(c,O,S,c),tt(u,S),t===m.FROM_PCPF&&et(u,u),rt(g,g,u),a.setVec(i,g);else for(let i=0;i<l;i++){n.getVec(i,O),e.getVec(i,g),N(c,O,S,c),tt(u,S);const s=kt(r.get(i,1));let f=Math.cos(s);t===m.TO_PCPF&&(f=1/f),u[0]*=f,u[1]*=f,u[2]*=f,u[3]*=f,u[4]*=f,u[5]*=f,t===m.FROM_PCPF&&et(u,u),rt(g,g,u),Ht(g,g),a.setVec(i,g)}return a}function I(t){return Ft(t)||me(t)}function Ft(t){return t.isWGS84||qt(t)||Dt(t)||Yt(t)}function me(t){return t.isWebMercator}var m;(function(t){t[t.TO_PCPF=0]="TO_PCPF",t[t.FROM_PCPF=1]="FROM_PCPF"})(m||(m={}));const O=J(),g=J(),S=b(),u=yt();function Q(t,e,r){return Pt(e.spatialReference,r==null?void 0:r.geographic)?X(t,e,!1,r):de(t,e,r)}function Tt(t,e=E){const{position:r,normal:n,tangent:o}=t;return{position:w(new Float64Array(r.length),r,e),normal:n!=null?fe(n,new Float32Array(n.length),e):null,tangent:o!=null?pe(o,new Float32Array(o.length),e):null}}function Mt(t,e,r,n){const{position:o,normal:a,tangent:l}=t;if(!L(e))return{position:o,normal:a,tangent:l};const c=ht(e,n);return Q(Tt(t,r==null?void 0:r.localMatrix),c,{geographic:e.type==="local"})}function he(t,e,r){const n=oe(e,r),o=e.spatialReference,a=L(n);if(!a)return{vertexAttributes:Q(t,e,r),vertexSpace:n,transform:null};const{position:l,normal:c,tangent:i}=t,s=xt(n,o);switch(n.type){case"georeferenced":return s?{vertexAttributes:X(t,e,a,r),vertexSpace:n,transform:null}:{vertexAttributes:{position:l,normal:c,tangent:i},vertexSpace:n,transform:new ut};case"local":return{vertexAttributes:{position:l,normal:c,tangent:i},vertexSpace:n,transform:new ut}}}function Y(t,e,r){return Pt(e.spatialReference,r==null?void 0:r.geographic)?bt(t,e,r):vt(t,e,r)}function $e(t,e,r,n,o){if(!L(e))return Y(t,n,o);const{spatialReference:a}=n,l=Mt(t,e,r,a);return n.equals(ht(e,a))?vt(l,n,o):Y(l,n,o)}function Ae({positions:t,transform:e,vertexSpace:r,inSpatialReference:n,outSpatialReference:o,outPositions:a,localMode:l}){const c=r.origin??nt,i=r.origin!=null?(e==null?void 0:e.localMatrix)??E:E;if(r.type==="georeferenced"){const p=a??ot(t.length);if(Xt(i,E)?re(p,t):w(p,t,i),!Zt(c,nt)){const[U,Ct,_t]=c;for(let M=0;M<p.length;M+=3)p[M]+=U,p[M+1]+=Ct,p[M+2]+=_t}return G(p,n,0,p,o,0,p.length/3),p}let s=n;const f=R(n);s=o.isWebMercator&&l||!te(n,f)?s:f,N(n,c,F,s),ee(F,F,i);const P=a??ot(t.length);return w(P,t,F),G(P,s,0,P,o,0,P.length/3),P}function de(t,e,r){const n=new Float64Array(t.position.length),o=t.position,a=e.x,l=e.y,c=e.z??0,i=W(r?r.unit:null,e.spatialReference);for(let s=0;s<o.length;s+=3)n[s]=o[s]*i+a,n[s+1]=o[s+1]*i+l,n[s+2]=o[s+2]*i+c;return{position:n,normal:t.normal,tangent:t.tangent}}function X(t,e,r,n){const o=e.spatialReference,a=wt(e,n,F),l=new Float64Array(t.position.length),c=Pe(t.position,a,o,l),i=z(Rt,a),s=xe(c,l,t.normal,i,o),f=Fe(c,l,t.tangent,i,o);if(r){const{x:P,y:p,z:U}=e;ae(c,c,[-P,-p,-(U??0)])}return{position:c,normal:s,tangent:f}}function Pe(t,e,r,n){w(n,t,e);const o=new Float64Array(t.length);return ue(n,o,r)}function xe(t,e,r,n,o){if(r==null)return null;const a=new Float32Array(r.length);return T(a,r,n),le(a,t,e,o,a),a}function Fe(t,e,r,n,o){if(r==null)return null;const a=new Float32Array(r.length);T(a,r,n,4);for(let l=3;l<a.length;l+=4)a[l]=r[l];return ye(a,t,e,o,a),a}function vt(t,e,r){const n=new Float64Array(t.position.length),o=t.position,a=e.x,l=e.y,c=e.z??0,i=W(r?r.unit:null,e.spatialReference);for(let s=0;s<o.length;s+=3)n[s]=(o[s]-a)/i,n[s+1]=(o[s+1]-l)/i,n[s+2]=(o[s+2]-c)/i;return{position:n,normal:t.normal,tangent:t.tangent}}function bt(t,e,r){const n=e.spatialReference;wt(e,r,F);const o=pt(be,F),a=new Float64Array(t.position.length),l=Te(t.position,n,o,a),c=z(Rt,o);return{position:l,normal:Me(t.normal,t.position,a,n,c),tangent:ve(t.tangent,t.position,a,n,c)}}function wt(t,e,r){N(t.spatialReference,[t.x,t.y,t.z??0],r,R(t.spatialReference));const n=W(e?e.unit:null,t.spatialReference);return Jt(r,r,[n,n,n]),r}function Te(t,e,r,n){const o=ce(t,e,n),a=new Float64Array(o.length);return w(a,o,r),a}function Me(t,e,r,n,o){if(t==null)return null;const a=se(t,e,r,n,new Float32Array(t.length));return T(a,a,o),a}function ve(t,e,r,n,o){if(t==null)return null;const a=ge(t,e,r,n,new Float32Array(t.length));return T(a,a,o,4),a}function W(t,e){if(t==null)return 1;const r=Kt(e);return 1/Qt(r,"meters",t)}const F=b(),be=b(),Rt=yt(),We=Object.freeze(Object.defineProperty({__proto__:null,applyTransform:Tt,georeference:Q,georeferenceApplyTransform:Mt,georeferenceByTransform:he,georeferenceGlobal:X,getUnitScale:W,project:Ae,ungeoreference:Y,ungeoreferenceByTransform:$e,ungeoreferenceGlobal:bt},Symbol.toStringTag,{value:"Module"}));export{q as A,$e as C,ue as E,Ae as G,X as I,Tt as O,Mt as P,bt as Q,he as V,W as _,ce as a,d as b,Ie as c,ut as d,le as e,ye as f,We as g,ge as h,se as j,Le as k,Ve as w,Be as y};
