import"./geometry-D964gYQX.js";import{p as h}from"./workers-D4HfeYKj.js";import{j as l}from"./Point-Cg0-ChZE.js";import{f as y}from"./jsonUtils-CEfjT-BK.js";import"./subclass-BZA_h8Db.js";import"./Extent-Bf3YTe7m.js";import"./tslib.es6-B3Jf3DVX.js";import"./Polyline-D9YkgmM_.js";import"./writer-DNAwXnhG.js";import"./mathUtils-C4_ghTv4.js";import"./jsonMap-0cxwUWs2.js";import"./Accessor-BLX9ikPh.js";import"./Queue-yu3bZ02p.js";import"./SimpleObservable-KocWTzVy.js";import"./assets-C43MgM-v.js";import"./index-Bh2oEzTI.js";import"./intl-CChhNOV8.js";import"./date-DlqISzcw.js";import"./locale-C9TlLpzi.js";import"./messages-OmQvZhAg.js";import"./cast-Bjksrh93.js";function n(e){var t;return Array.isArray(e)?(t=e[0])==null?void 0:t.spatialReference:e==null?void 0:e.spatialReference}function p(e){return e&&(Array.isArray(e)?e.map(p):e.toJSON?e.toJSON():e)}function o(e){return Array.isArray(e)?e.map(t=>y(t)):y(e)}function S(e,t){let r;return Array.isArray(e)?r=e:(r=[],r.push(e),t!=null&&r.push(t)),r}let f;async function w(){return f||(f=h("geometryEngineWorker",{strategy:"distributed"})),f}async function a(e,t){return(await w()).invoke("executeGEOperation",{operation:e,parameters:p(t)})}async function d(e,t){const r=await w();return Promise.all(r.broadcast("executeGEOperation",{operation:e,parameters:p(t)}))}function C(e){return a("extendedSpatialReferenceInfo",[e])}async function G(e,t){return o(await a("clip",[n(e),e,t]))}async function $(e,t){return o(await a("cut",[n(e),e,t]))}function W(e,t){return a("contains",[n(e),e,t])}function F(e,t){return a("crosses",[n(e),e,t])}function K(e,t,r){return a("distance",[n(e),e,t,r])}function M(e,t){return a("equals",[n(e),e,t])}function Q(e,t){return a("intersects",[n(e),e,t])}function U(e,t){return a("touches",[n(e),e,t])}function X(e,t){return a("within",[n(e),e,t])}function Y(e,t){return a("disjoint",[n(e),e,t])}function Z(e,t){return a("overlaps",[n(e),e,t])}function _(e,t,r){return a("relate",[n(e),e,t,r])}function ee(e){return a("isSimple",[n(e),e])}async function te(e){return o(await a("simplify",[n(e),e]))}async function re(e,t=!1){return o(await a("convexHull",[n(e),e,t]))}async function ae(e,t){return o(await a("difference",[n(e),e,t]))}async function ne(e,t){return o(await a("symmetricDifference",[n(e),e,t]))}async function ie(e,t){return o(await a("intersect",[n(e),e,t]))}async function oe(e,t=null){const r=S(e,t);return o(await a("union",[n(r),r]))}async function ce(e,t,r,i,c,u){return o(await a("offset",[n(e),e,t,r,i,c,u]))}async function se(e,t,r,i=!1){const c=[n(e),e,t,r,i];return o(await a("buffer",c))}async function ue(e,t,r,i,c,u){const g=[n(e),e,t,r,i,c,u];return o(await a("geodesicBuffer",g))}async function fe(e,t,r=!0){const i=await a("nearestCoordinate",[n(e),e,t,r]);return{...i,coordinate:l.fromJSON(i.coordinate)}}async function le(e,t){const r=await a("nearestVertex",[n(e),e,t]);return{...r,coordinate:l.fromJSON(r.coordinate)}}async function pe(e,t,r,i){return(await a("nearestVertices",[n(e),e,t,r,i])).map(c=>({...c,coordinate:l.fromJSON(c.coordinate)}))}function m(e){var t;return"xmin"in e?e.center:"x"in e?e:(t=e.extent)==null?void 0:t.center}async function me(e,t,r){if(e==null)throw new s;const i=e.spatialReference;if((r=r??m(e))==null)throw new s;const c=e.constructor.fromJSON(await a("rotate",[i,e,t,r]));return c.spatialReference=i,c}async function ye(e,t){if(e==null)throw new s;const r=e.spatialReference;if((t=t??m(e))==null)throw new s;const i=e.constructor.fromJSON(await a("flipHorizontal",[r,e,t]));return i.spatialReference=r,i}async function we(e,t){if(e==null)throw new s;const r=e.spatialReference;if((t=t??m(e))==null)throw new s;const i=e.constructor.fromJSON(await a("flipVertical",[r,e,t]));return i.spatialReference=r,i}async function de(e,t,r,i){return o(await a("generalize",[n(e),e,t,r,i]))}async function ge(e,t,r){return o(await a("densify",[n(e),e,t,r]))}async function he(e,t,r,i=0){return o(await a("geodesicDensify",[n(e),e,t,r,i]))}function Se(e,t){return a("planarArea",[n(e),e,t])}function xe(e,t){return a("planarLength",[n(e),e,t])}function Re(e,t,r){return a("geodesicArea",[n(e),e,t,r])}function Ae(e,t,r){return a("geodesicLength",[n(e),e,t,r])}async function Oe(e,t){return o(await a("intersectLinesToPoints",[n(e),e,t]))}async function De(e,t){await d("changeDefaultSpatialReferenceTolerance",[e,t])}async function Je(e){await d("clearDefaultSpatialReferenceTolerance",[e])}class s extends Error{constructor(){super("Illegal Argument Exception")}}export{se as buffer,De as changeDefaultSpatialReferenceTolerance,Je as clearDefaultSpatialReferenceTolerance,G as clip,W as contains,re as convexHull,F as crosses,$ as cut,ge as densify,ae as difference,Y as disjoint,K as distance,M as equals,C as extendedSpatialReferenceInfo,ye as flipHorizontal,we as flipVertical,de as generalize,Re as geodesicArea,ue as geodesicBuffer,he as geodesicDensify,Ae as geodesicLength,ie as intersect,Oe as intersectLinesToPoints,Q as intersects,ee as isSimple,fe as nearestCoordinate,le as nearestVertex,pe as nearestVertices,ce as offset,Z as overlaps,Se as planarArea,xe as planarLength,_ as relate,me as rotate,te as simplify,ne as symmetricDifference,U as touches,oe as union,X as within};
