import{r as n}from"./tslib.es6-B3Jf3DVX.js";import{j as u,I as g,F as f,M as m,a as b,R as w,Q as y,L as M,i as R,g as j}from"./Point-Cg0-ChZE.js";import{m as p,a as k}from"./subclass-BZA_h8Db.js";import{v as h}from"./Polyline-D9YkgmM_.js";import{j as v}from"./geodesicUtils-FCYOaNwu.js";var d;let c=d=class extends h{constructor(e){super(e),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const e=this.center,a=this.numberOfPoints;if(this.hasZ=(e==null?void 0:e.hasZ)??!1,this.rings.length!==0||!e)return;const o=g(this.radius,this.radiusUnit,"meters"),r=e.spatialReference;let t,s="geographic";if(r.isWebMercator?s="webMercator":((r.wkid&&f[r.wkid])!=null||(r.wkt2||r.wkt)&&m(r.wkt2||r.wkt))&&(s="projected"),this.geodesic){let i;switch(s){case"webMercator":i=b(e);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":i=e}t=this._createGeodesicCircle(i,o,a),s==="webMercator"&&(t=w(t))}else{let i;s==="webMercator"||s==="projected"?i=o/y(e.spatialReference):s==="geographic"&&(i=M(o,"meters",R(e.spatialReference).radius)),t=this._createPlanarCircle(e,i,a)}this.spatialReference=t.spatialReference,this.addRing(t.rings[0])}clone(){const{center:e,numberOfPoints:a,radius:o,radiusUnit:r,geodesic:t}=this;return new d({center:e==null?void 0:e.clone(),numberOfPoints:a,radius:o,radiusUnit:r,geodesic:t})}_createGeodesicCircle(e,a,o){let r=0;const t=[];for(;r<360;){const s=[0,0],i=[e.x,e.y];v(s,i,r,a,j.WGS84),this.hasZ&&s.push(e.z),t.push(s),r+=360/o}return t.push(t[0]),new h({rings:[t]})}_createPlanarCircle(e,a,o){const r=[],t=2*Math.PI/o;for(let s=0;s<o;++s){const i=t*s,l=[e.x+Math.cos(-i)*a,e.y+Math.sin(-i)*a];this.hasZ&&l.push(e.z),r.push(l)}return r.push(r[0]),new h({spatialReference:e.spatialReference,rings:[r]})}};n([p({type:u})],c.prototype,"center",void 0),n([p()],c.prototype,"geodesic",void 0),n([p()],c.prototype,"numberOfPoints",void 0),n([p()],c.prototype,"radius",void 0),n([p()],c.prototype,"radiusUnit",void 0),c=d=n([k("esri.geometry.Circle")],c);const x=c;export{x as b};
