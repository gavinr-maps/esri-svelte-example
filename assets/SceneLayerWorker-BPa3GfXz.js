const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./i3s-BB6LKGW6.js","./_commonjsHelpers-DCkdB7M8.js","./projectBuffer-DOU0xvVi.js","./mathUtils-DV9iOXpW.js","./Point-XGrwlf63.js","./Accessor-BHnuXKD2.js","./cast-BA_-jlhc.js","./index-tefRSezt.js","./index-Cx51aysm.css","./JSONSupport-CGdeqxpk.js","./writer-B2bQV2uU.js","./geodesicConstants-yASAK_zX.js","./projection-B2I9Bzj_.js","./SimpleObservable-7oieNGD8.js","./vec3f64-BLpZdpfb.js","./Extent-CBBGeHb-.js","./Polyline-BmuD2-ZN.js","./projectMeshVertexPositions-Ap141qsf.js","./MeshLocalVertexSpace-C0YDTRex.js","./Clonable-DvJsj5LF.js","./enumeration-Cr5WIZs4.js","./vertexSpaceConversion-Dbe11h0o.js","./mat3-CR8GKnhD.js","./common-DQOJ18NT.js","./mat3f64-BBpwCtoL.js","./mat4-Fi6iAz29.js","./mat4f64-Dk4dwAN8.js","./vec32-Dvg_eL9J.js","./spatialReferenceEllipsoidUtils-DM073JUd.js","./computeTranslationToOriginAndRotation-BT43Xu5d.js","./projectPointToVector-BS0u8fq6.js","./meshVertexSpaceUtils-SW0WEjNN.js","./vec3-Bn81gjoR.js","./colorUtils-Rxh2V3ai.js","./BufferView-_QDXRCew.js","./vec2-maR1OrZI.js","./vec42-YcqnINSP.js","./vec4-DcW4fpPA.js"])))=>i.map(i=>d[i]);
import{_ as S}from"./index-tefRSezt.js";import{T as K}from"./mathUtils-DV9iOXpW.js";import{g as k}from"./Point-XGrwlf63.js";import{n as Q,a as X}from"./MeshLocalVertexSpace-C0YDTRex.js";import{n as ee,d as te}from"./vec3-Bn81gjoR.js";import{n as re}from"./cast-BA_-jlhc.js";import{a0 as oe,B as se}from"./Accessor-BHnuXKD2.js";import{n as ne}from"./vec3f64-BLpZdpfb.js";import{h as ie}from"./WorkerHandle-B2QLNs3X.js";import{L as ae}from"./projection-B2I9Bzj_.js";import{n as fe}from"./projectVectorToVector-dS8io47t.js";import{r as O}from"./I3SNode-C58UWnty.js";var N,g;(function(e){e[e.None=0]="None",e[e.Int16=1]="Int16",e[e.Int32=2]="Int32"})(N||(N={})),function(e){e[e.Replace=0]="Replace",e[e.Outside=1]="Outside",e[e.Inside=2]="Inside",e[e.Finished=3]="Finished"}(g||(g={}));function ce(){return v||(v=new Promise(e=>S(()=>import("./i3s-BB6LKGW6.js"),__vite__mapDeps([0,1]),import.meta.url).then(t=>t.i).then(({default:t})=>{const r=t({locateFile:ue,onRuntimeInitialized:()=>e(r)});delete r.then})).catch(e=>{throw e})),v}function ue(e){return re(`esri/libs/i3s/${e}`)}let v;class le{constructor(t,r,n,s,c,a){this.layout=t,this.interleavedVertexData=r,this.indices=n,this.hasColors=s,this.hasModifications=c,this.positionData=a}}let he=class{constructor(t,r,n,s,c,a,u){this.componentOffsets=t,this.featureIds=r,this.anchorIds=n,this.anchors=s,this.transformedGeometry=c,this.globalTrafo=a,this.obb=u}};class De extends ie{constructor(t){super("SceneLayerWorker","process",{process:r=>[r.geometryBuffer],project:r=>[r.positions.buffer],transformNormals:r=>[r.normals.buffer]},t,{hasInitialize:!0})}setModifications(t,r,n,s){const c={context:t,modifications:pe(r,n,s),isGeodetic:s.isGeographic};this.broadcast(c,"setModifications")}setLegacySchema(t,r){const n=JSON.stringify(r);return this.broadcast({context:t,jsonSchema:n},"setLegacySchema")}destroyContext(t){return this.broadcast(t,"destroyContext")}project(t,r){return this.invokeMethod("project",t,r)}transformNormals(t,r){return this.invokeMethod("transformNormals",t,r)}}const o=new oe({deallocator:null}),I=ne();function pe(e,t,r){o.clear();let n=1/0,s=1/0,c=-1/0,a=-1/0,u=!1;for(const h of t){const w=h.type==="clip"?g.Inside:h.type==="mask"?g.Outside:g.Replace,d=h.geometry;let b=p=>p;if(d.spatialReference){if(!ae(d.spatialReference,r)){se.getLogger("esri.views.3d.layers.I3SMeshWorkerHandle").warn("Can't project modification polygon into layer spatial reference, ignoring modification");continue}b=p=>(fe(p,d.spatialReference,I,r),I)}else d.hasZ||(I[2]=0,b=p=>(I[0]=p[0],I[1]=p[1],I));u=u||w===g.Outside,o.push(w),o.push(d.rings.length);for(const p of d.rings){o.push(p.length);for(const E of p){const l=b(E);o.push(l[0]),o.push(l[1]),o.push(l[2]),n=Math.min(n,l[0]),s=Math.min(s,l[1]),c=Math.max(c,l[0]),a=Math.max(a,l[1])}}}e!=null&&(u?(o.push(g.Inside),o.push(2),o.push(4),o.push(n-1e-4),o.push(s-1e-4),o.push(0),o.push(c+1e-4),o.push(s-1e-4),o.push(0),o.push(c+1e-4),o.push(a+1e-4),o.push(0),o.push(n-1e-4),o.push(a+1e-4),o.push(0),o.push(4),o.push(e[0]),o.push(e[1]),o.push(0),o.push(e[2]),o.push(e[1]),o.push(0),o.push(e[2]),o.push(e[3]),o.push(0),o.push(e[0]),o.push(e[3]),o.push(0)):(o.push(g.Outside),o.push(1),o.push(4),o.push(e[0]),o.push(e[1]),o.push(0),o.push(e[2]),o.push(e[1]),o.push(0),o.push(e[2]),o.push(e[3]),o.push(0),o.push(e[0]),o.push(e[3]),o.push(0))),o.push(g.Finished);const m=new Float64Array(o.length);for(let h=0;h<o.length;++h)m[h]=o.at(h);return m}async function me(e){i=await x();const t=[e.geometryBuffer];return{result:z(i,e,t),transferList:t}}async function de(e){var h;i=await x();const t=[e.geometryBuffer],{geometryBuffer:r}=e,n=r.byteLength,s=i._malloc(n),c=new Uint8Array(i.HEAPU8.buffer,s,n);c.set(new Uint8Array(r));const a=i.dracoDecompressPointCloudData(s,c.byteLength);if(i._free(s),a.error.length>0)throw new Error(`i3s.wasm: ${a.error}`);const u=((h=a.featureIds)==null?void 0:h.length)>0?a.featureIds.slice():null,m=a.positions.slice();return u&&t.push(u.buffer),t.push(m.buffer),{result:{positions:m,featureIds:u},transferList:t}}async function ye(e){await x(),J(e);const t={buffer:e.buffer};return{result:t,transferList:[t.buffer]}}async function be(e){await x(),H(e)}async function ge(e){i=await x(),i.setLegacySchema(e.context,e.jsonSchema)}async function we(e){const{localMatrix:t,origin:r,positions:n,vertexSpace:s}=e,c=k.fromJSON(e.inSpatialReference),a=k.fromJSON(e.outSpatialReference);let u;const[{projectBuffer:m},{initializeProjection:h}]=await Promise.all([S(()=>import("./projectBuffer-DOU0xvVi.js").then(l=>l.p),__vite__mapDeps([2,3,4,5,6,7,8,9,10,11]),import.meta.url),S(()=>import("./projection-B2I9Bzj_.js").then(l=>l.p),__vite__mapDeps([12,7,8,5,13,14,4,6,9,10,15,16,3,2,11]),import.meta.url)]);await h(c,a);const w=[0,0,0];if(!m(r,c,0,w,a,0))throw new Error("Failed to project");if(s.type==="georeferenced"&&s.origin==null){if(u=new Float64Array(n.length),!m(n,c,0,u,a,0,u.length/3))throw new Error("Failed to project")}else{const l=s.type==="georeferenced"?Q.fromJSON(s):X.fromJSON(s),{projectMeshVertexPositions:y}=await S(async()=>{const{projectMeshVertexPositions:L}=await import("./projectMeshVertexPositions-Ap141qsf.js");return{projectMeshVertexPositions:L}},__vite__mapDeps([17,2,3,4,5,6,7,8,9,10,11,18,19,20,14,21,22,23,24,25,26,27,28,29,30,12,13,15,16,31,32,33,34,35,36,37]),import.meta.url),_=y({vertexAttributes:{position:n},transform:t?{localMatrix:t}:void 0,vertexSpace:l,spatialReference:c},a);if(!_)throw new Error("Failed to project");u=_}const d=u.length,[b,p,E]=w;for(let l=0;l<d;l+=3)u[l]-=b,u[l+1]-=p,u[l+2]-=E;return{result:{projected:u,original:n,projectedOrigin:w},transferList:[u.buffer,n.buffer]}}async function _e({normalMatrix:e,normals:t}){const r=new Float32Array(t.length);return ee(r,t,e),K(e)&&te(r,r),{result:{transformed:r,original:t},transferList:[r.buffer,t.buffer]}}function Ee(e){Y(e)}let Le,i;function H(e){if(!i)return;const t=e.modifications,r=i._malloc(8*t.length),n=new Float64Array(i.HEAPU8.buffer,r,t.length);for(let s=0;s<t.length;++s)n[s]=t[s];i.setModifications(e.context,r,t.length,e.isGeodetic),i._free(r)}function z(e,t,r){const{context:n,globalTrafo:s,mbs:c,obbData:a,elevationOffset:u,geometryBuffer:m,geometryDescriptor:h,indexToVertexProjector:w,vertexToRenderProjector:d}=t,b=e._malloc(m.byteLength),p=33,E=e._malloc(p*Float64Array.BYTES_PER_ELEMENT),l=new Uint8Array(e.HEAPU8.buffer,b,m.byteLength);l.set(new Uint8Array(m));const y=new Float64Array(e.HEAPU8.buffer,E,p);P(y,[NaN,NaN,NaN]);let _=y.byteOffset+3*y.BYTES_PER_ELEMENT,L=new Float64Array(y.buffer,_);P(L,s),_+=16*y.BYTES_PER_ELEMENT,L=new Float64Array(y.buffer,_),P(L,c),_+=4*y.BYTES_PER_ELEMENT,a&&(L=new Float64Array(y.buffer,_),P(L,a));const F=h,G={isDraco:!1,isLegacy:!1,color:t.layouts.some(A=>A.some(M=>M.name==="color")),normal:t.needNormals&&t.layouts.some(A=>A.some(M=>M.name==="normalCompressed")),uv0:t.layouts.some(A=>A.some(M=>M.name==="uv0")),uvRegion:t.layouts.some(A=>A.some(M=>M.name==="uvRegion")),featureIndex:F.featureIndex},f=e.process(n,!!t.obbData,b,l.byteLength,F,G,E,u,w,d,t.normalReferenceFrame);if(e._free(E),e._free(b),f.error.length>0)throw new Error(`i3s.wasm: ${f.error}`);if(f.discarded)return null;const R=f.componentOffsets.length>0?f.componentOffsets.slice():null,j=f.featureIds.length>0?f.featureIds.slice():null,W=f.anchorIds.length>0?Array.from(f.anchorIds):null,Z=f.anchors.length>0?Array.from(f.anchors):null,T=f.interleavedVertedData.slice().buffer,$=f.indicesType===N.Int16?new Uint16Array(f.indices.buffer,f.indices.byteOffset,f.indices.byteLength/2).slice():new Uint32Array(f.indices.buffer,f.indices.byteOffset,f.indices.byteLength/4).slice(),U=f.positions.slice(),{buffer:B,byteOffset:D,byteLength:C}=f.positionIndices,V=f.positionIndicesType===N.Int16?new Uint16Array(B,D,C/2).slice():new Uint32Array(B,D,C/4).slice(),q=new le(t.layouts[0],T,$,f.hasColors,f.hasModifications,{data:U,indices:V});return j&&r.push(j.buffer),R&&r.push(R.buffer),r.push(T),r.push($.buffer),r.push(U.buffer),r.push(V.buffer),new he(R,j,W,Z,q,s,f.obb)}function Ae(e){return e===0?O.Unmodified:e===1?O.PotentiallyModified:e===2?O.Culled:O.Unknown}function J(e){if(!i)return;const{context:t,buffer:r}=e,n=i._malloc(r.byteLength),s=r.byteLength/Float64Array.BYTES_PER_ELEMENT,c=new Float64Array(i.HEAPU8.buffer,n,s),a=new Float64Array(r);c.set(a),i.filterOBBs(t,n,s),a.set(c),i._free(n)}function Y(e){i&&i.destroy(e)===0&&(i=null)}function P(e,t){for(let r=0;r<t.length;++r)e[r]=t[r]}async function Me(){i||await x()}async function x(){return i||(i=await(Le??(Le=ce()))),i}const Ie={transform:(e,t)=>i&&z(i,e,t),destroy:Y},Ce=Object.freeze(Object.defineProperty({__proto__:null,destroyContext:Ee,dracoDecompressPointCloudData:de,filterObbsForModifications:ye,filterObbsForModificationsSync:J,initialize:Me,interpretObbModificationResults:Ae,process:me,project:we,setLegacySchema:ge,setModifications:be,setModificationsSync:H,test:Ie,transformNormals:_e},Symbol.toStringTag,{value:"Module"}));export{Ae as L,Me as P,J as S,De as a,Ce as b,pe as f,H as j};
