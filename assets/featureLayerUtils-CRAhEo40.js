import{S as K,X as z,O as B,b as u}from"./subclass-BZA_h8Db.js";import{i as L}from"./originUtils-D69mHv66.js";import{P as j,y as N,w as x,$ as V,d as X,v as k,p as O,f as q,I as g,m as A}from"./utils-BGV5vBjY.js";import{d as f}from"./arcgisLayerUrl-BX1FE5Hm.js";import{t as C,a as H,i as Q}from"./lazyLayerLoader-Buplpp4b.js";import{L as W}from"./layerUtils-BrNoooE9.js";import{l as R,a as T,f as p,u as d,i as Z}from"./portalItemUtils-BzVoFAku.js";import"./multiOriginJSONSupportUtils-C0wm8_Yw.js";import"./Portal-C10FKnaA.js";import"./index-Bh2oEzTI.js";import"./tslib.es6-B3Jf3DVX.js";import"./assets-C43MgM-v.js";import"./Accessor-BLX9ikPh.js";import"./Loadable-BabW5Xcc.js";import"./Promise-B2Hu02L7.js";import"./writer-DNAwXnhG.js";import"./Extent-Bf3YTe7m.js";import"./Point-Cg0-ChZE.js";import"./cast-Bjksrh93.js";import"./jsonMap-0cxwUWs2.js";import"./locale-C9TlLpzi.js";import"./PortalItem-DzgXrpyc.js";import"./persistableUrlUtils-fa1mAujs.js";import"./jsonContext-DueMnVx9.js";import"./saveUtils-gB1pYTqT.js";import"./requestPresets-B-6DU6iY.js";import"./projection-B971H0Re.js";import"./SimpleObservable-KocWTzVy.js";import"./vec3f64-BLpZdpfb.js";import"./Polyline-D9YkgmM_.js";import"./mathUtils-C4_ghTv4.js";import"./projectBuffer-Bs7GwaPY.js";import"./geodesicConstants-DWQLYX7F.js";const w="Feature Service",v="feature-layer-utils",aa=`${v}-save`,ta=`${v}-save-as`,m=`${v}-saveall`,y=`${v}-saveall-as`;function $(a){return{isValid:W(a)&&(!("dynamicDataSource"in a)||!a.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function M(a){const t=[],e=[];for(const{layer:r,layerJSON:i}of a)r.isTable?e.push(i):t.push(i);return{layers:t,tables:e}}function D(a){return M([a])}async function J(a,t){return/\/\d+\/?$/.test(a.url)?D(t[0]):F(t,a)}async function F(a,t){if(a.reverse(),!t)return M(a);const e=await ea(t,a);for(const r of a)U(r.layer,r.layerJSON,e);return na(e,a),e}async function ea(a,t){let e=await a.fetchData("json");if(ra(e))return e;e||(e={}),oa(e);const{layer:{url:r,customParameters:i,apiKey:n}}=t[0];return await ia(e,{url:r??"",customParameters:i,apiKey:n},t.map(o=>o.layer.layerId)),e}function ra(a){return!!(a&&Array.isArray(a.layers)&&Array.isArray(a.tables))}function oa(a){a.layers||(a.layers=[]),a.tables||(a.tables=[])}function na(a,t){const e=[],r=[];for(const{layer:i}of t){const{isTable:n,layerId:o}=i;n?r.push(o):e.push(o)}b(a.layers,e),b(a.tables,r)}function b(a,t){if(a.length<2)return;const e=[];for(const{id:r}of a)e.push(r);K(e.sort(S),t.slice().sort(S))&&a.sort((r,i)=>{const n=t.indexOf(r.id),o=t.indexOf(i.id);return n<o?-1:n>o?1:0})}function S(a,t){return a<t?-1:a>t?1:0}async function ia(a,t,e){const{url:r,customParameters:i,apiKey:n}=t,{serviceJSON:o,layersJSON:s}=await C(r,{customParameters:i,apiKey:n}),l=P(a.layers,o.layers,e),c=P(a.tables,o.tables,e);a.layers=l.itemResources,a.tables=c.itemResources;const h=[...l.added,...c.added],G=s?[...s.layers,...s.tables]:[];await sa(a,h,r,G)}function P(a,t,e){const r=z(a,t,(n,o)=>n.id===o.id);a=a.filter(n=>!r.removed.some(o=>o.id===n.id));const i=r.added;return i.forEach(({id:n})=>{a.push({id:n})}),{itemResources:a,added:i.filter(({id:n})=>!e.includes(n))}}async function sa(a,t,e,r){const i=await la(t),n=t.map(({id:o,type:s})=>new(i.get(s))({url:e,layerId:o,sourceJSON:r.find(({id:l})=>l===o)}));await Promise.allSettled(n.map(o=>o.load())),n.forEach(o=>{const{layerId:s,loaded:l,defaultPopupTemplate:c}=o;if(!l||c==null)return;const h={id:s,popupInfo:c.toJSON()};o.operationalLayerType!=="ArcGISFeatureLayer"&&(h.layerType=o.operationalLayerType),U(o,h,a)})}async function la(a){const t=[];a.forEach(({type:i})=>{const n=Q(i),o=H[n];t.push(o())});const e=await Promise.all(t),r=new Map;return a.forEach(({type:i},n)=>{r.set(i,e[n])}),r}function U(a,t,e){a.isTable?E(e.tables,t):E(e.layers,t)}function E(a,t){const e=a.findIndex(({id:r})=>r===t.id);e===-1?a.push(t):a[e]=t}function Y(a,t){if(!a.length)throw new u(`${t}:missing-parameters`,"'layers' array should contain at least one feature layer")}function ca(a,t){const e=a.map(r=>r.portalItem.id);if(new Set(e).size>1)throw new u(`${t}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function _(a,t){const e=a.map(r=>r.layerId);if(new Set(e).size!==e.length)throw new u(`${t}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function pa(a){Y(a,m),await Promise.all(a.map(t=>t.load()));for(const t of a)O(t,m,$),q({layer:t,itemType:w,errorNamePrefix:m});ca(a,m),_(a,m)}function I(a,t){const e=a.some(r=>r.type==="oriented-imagery");d(t,p.ORIENTED_IMAGERY_LAYER,e)}async function ua(a,t){I([a],t)}async function ma(a,t){const{url:e,layerId:r,title:i,fullExtent:n,isTable:o}=a,s=f(e);t.url=((s==null?void 0:s.serverType)==="FeatureServer"?e:`${e}/${r}`)??null,t.title||(t.title=i),t.extent=null,o||n==null||(t.extent=await R(n)),T(t,p.METADATA),T(t,p.MULTI_LAYER),Z(t,p.SINGLE_LAYER),d(t,p.TABLE,o),I([a],t)}function ya(a,t){for(const n of a){const o=n.parsedUrl.path,s=f(o);if(!(s==null?void 0:s.url.path))throw new u(`${t}:invalid-parameters`,A(n,`has unsupported url pattern: ${o}`),{layer:n});const c=s==null?void 0:s.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new u(`${t}:invalid-parameters`,A(n,`has unsupported server type: ${c}`),{layer:n});if(c==="MapServer"&&a.length>1)throw new u(`${t}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const e=f(a[0].parsedUrl.path),r=e==null?void 0:e.url.path;if(!a.every(n=>{const o=f(n.parsedUrl.path);return(o==null?void 0:o.url.path)===r}))throw new u(`${t}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function fa(a){Y(a,y),await Promise.all(a.map(t=>t.load()));for(const t of a)O(t,y,$);ya(a,y),_(a,y)}function da(a,t){I(t,a),g(a)}async function ha(a,t){let e=0,r=0;for(const{isTable:o}of t)o?r++:e++;const i=t[0].parsedUrl.path,n=f(i);if(a.url=(n==null?void 0:n.serverType)==="FeatureServer"?n.url.path:i,a.title||(a.title=n.title),a.extent=null,e>0){const o=t.map(s=>s.fullExtent).filter(B).reduce((s,l)=>s.clone().union(l));o&&(a.extent=await R(o))}T(a,p.METADATA),d(a,p.MULTI_LAYER,t.length>1),d(a,p.SINGLE_LAYER,t.length===1),d(a,p.TABLE,r>0&&e===0),I(t,a),g(a)}async function Ha(a,t){return j({layer:a,itemType:w,validateLayer:$,createItemData:(e,r)=>J(r,[e]),errorNamePrefix:aa,setItemProperties:ua},t)}async function Qa(a,t){await pa(a);const e=a[0].portalItem,r=N(e),i=await Promise.all(a.map(o=>x(o,r,t))),n=await J(e,a.map((o,s)=>({layer:o,layerJSON:i[s]})));return da(e,a),await e.update({data:n}),await Promise.all(a.slice(1).map(o=>o.portalItem.reload())),L(r),e.clone()}async function Wa(a,t,e){return V({layer:a,itemType:w,validateLayer:$,createItemData:(r,i)=>Promise.resolve(D(r)),errorNamePrefix:ta,newItem:t,setItemProperties:ma},e)}async function Za(a,t,e){await fa(a);const r=X({itemType:w,errorNamePrefix:y,newItem:t}),i=N(r),n=await Promise.all(a.map(s=>x(s,i,e))),o=await F(a.map((s,l)=>({layer:s,layerJSON:n[l]})));await ha(r,a),await k(r,o,e);for(const s of a)s.portalItem=r.clone();return L(i),r}export{Ha as save,Qa as saveAll,Za as saveAllAs,Wa as saveAs};
