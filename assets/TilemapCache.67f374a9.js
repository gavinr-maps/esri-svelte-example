var q=Object.defineProperty,C=Object.defineProperties;var N=Object.getOwnPropertyDescriptors;var A=Object.getOwnPropertySymbols;var P=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable;var T=(e,i,t)=>i in e?q(e,i,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[i]=t,m=(e,i)=>{for(var t in i||(i={}))P.call(i,t)&&T(e,t,i[t]);if(A)for(var t of A(i))x.call(i,t)&&T(e,t,i[t]);return e},b=(e,i)=>C(e,N(i));import{d3 as g,d4 as j,w as u,bc as k,C as z,m as U,a6 as E,bK as J,W as F,B,E as O,d5 as I,F as M,c$ as R,d6 as K,a9 as d,aa as _,cr as W,ab as G,a7 as H,D as Q}from"./vendor.f5642644.js";const ie={type:g,json:{origins:{service:{read:{source:["tileInfo","minScale","maxScale","minLOD","maxLOD"],reader:V}}}}};function V(e,i,t,a){if(!e)return null;const{minScale:l,maxScale:n,minLOD:o,maxLOD:r}=i;if(o!=null&&r!=null)return a&&a.ignoreMinMaxLOD?g.fromJSON(e):g.fromJSON(b(m({},e),{lods:e.lods.filter(({level:h})=>h!=null&&h>=o&&h<=r)}));if(l!==0&&n!==0){const h=v=>Math.round(1e4*v)/1e4,s=l?h(l):1/0,c=n?h(n):-1/0;return g.fromJSON(b(m({},e),{lods:e.lods.filter(v=>{const f=h(v.scale);return f<=s&&f>=c})}))}return g.fromJSON(e)}class w{constructor(){this.location={left:0,top:0,width:0,height:0},this._allAvailability="unknown",this.byteSize=40}getAvailability(i,t){if(this._allAvailability!=="unknown")return this._allAvailability;const a=(i-this.location.top)*this.location.width+(t-this.location.left),l=a%8,n=a>>3,o=this._tileAvailabilityBitSet;return n<0||n>o.length?"unknown":o[n]&1<<l?"available":"unavailable"}_updateFromData(i){const t=this.location.width,a=this.location.height;let l=!0,n=!0;const o=Math.ceil(t*a/8),r=new Uint8Array(o);let h=0;for(let s=0;s<i.length;s++){const c=s%8;i[s]?(n=!1,r[h]|=1<<c):l=!1,c===7&&++h}n?this._allAvailability="unavailable":l?this._allAvailability="available":(this._allAvailability="unknown",this._tileAvailabilityBitSet=r,this.byteSize+=r.length)}static fromDefinition(i,t){const a=i.service.request||z,{row:l,col:n,width:o,height:r}=i,h={query:{f:"json"}};return t=t?m(m({},h),t):h,a(X(i),t).then(s=>s.data).catch(s=>{if(s&&s.details&&s.details.httpStatus===422)return{location:{top:l,left:n,width:o,height:r},valid:!0,data:j(o*r,0)};throw s}).then(s=>{if(s.location&&(s.location.top!==l||s.location.left!==n||s.location.width!==o||s.location.height!==r))throw new u("tilemap:location-mismatch","Tilemap response for different location than requested",{response:s,definition:{top:l,left:n,width:o,height:r}});return w.fromJSON(s)})}static fromJSON(i){w.validateJSON(i);const t=new w;return t.location=Object.freeze(k(i.location)),t._updateFromData(i.data),Object.freeze(t)}static validateJSON(i){if(!i||!i.location)throw new u("tilemap:missing-location","Location missing from tilemap response");if(i.valid===!1)throw new u("tilemap:invalid","Tilemap response was marked as invalid");if(!i.data)throw new u("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(i.data))throw new u("tilemap:data-mismatch","Data must be an array of numbers");if(i.data.length!==i.location.width*i.location.height)throw new u("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}}function D(e){return`${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}function X(e){let i;if(e.service.type==="vector-tile")i=`${e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`;else{const a=e.service.tileServers;i=`${a&&a.length?a[e.row%a.length]:e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}const t=e.service.query;return t&&(i=`${i}?${t}`),i}var y;const Y=U.getLogger("esri.layers.support.TilemapCache");let p=y=class extends E(H){constructor(e){super(e),this._pendingTilemapRequests={},this._availableLevels={},this.levels=5,this.cacheByteSize=2097152,this.request=z,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new J(this.cacheByteSize),this.handles.add([this.watch(["layer.parsedUrl","layer.tileServers?","layer.apiKey?","layer.customParameters?"],()=>this._initializeTilemapDefinition()),F(this,"layer.tileInfo.lods",e=>this._initializeAvailableLevels(e),!0)]),this._initializeTilemapDefinition()}castLevels(e){return e<=2?(Y.error("Minimum levels for Tilemap is 3, but got ",e),3):e}get size(){return 1<<this.levels}fetchTilemap(e,i,t,a){if(!this._availableLevels[e])return Promise.reject(new u("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const l=this._tmpTilemapDefinition,n=this._tilemapFromCache(e,i,t,l);if(n)return Promise.resolve(n);const o=a&&a.signal;return a=b(m({},a),{signal:null}),new Promise((r,h)=>{B(o,()=>h(Q()));const s=D(l);let c=this._pendingTilemapRequests[s];if(!c){c=w.fromDefinition(l,a).then(f=>(this._tilemapCache.put(s,f,f.byteSize),f));const v=()=>delete this._pendingTilemapRequests[s];this._pendingTilemapRequests[s]=c,c.then(v,v)}c.then(r,h)})}getAvailability(e,i,t){if(!this._availableLevels[e])return"unavailable";const a=this._tilemapFromCache(e,i,t,this._tmpTilemapDefinition);return a?a.getAvailability(i,t):"unknown"}fetchAvailability(e,i,t,a){return this._availableLevels[e]?this.fetchTilemap(e,i,t,a).catch(l=>l).then(l=>{if(l instanceof w){const n=l.getAvailability(i,t);return n==="unavailable"?Promise.reject(new u("tile-map:tile-unavailable","Tile is not available",{level:e,row:i,col:t})):n}if(O(l))throw l;return"unknown"}):Promise.reject(new u("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`))}fetchAvailabilityUpsample(e,i,t,a,l){a.level=e,a.row=i,a.col=t;const n=this.layer.tileInfo;n.updateTileInfo(a);const o=this.fetchAvailability(e,i,t,l).catch(r=>{if(O(r))throw r;if(n.upsampleTile(a))return this.fetchAvailabilityUpsample(a.level,a.row,a.col,a);throw r});return this._fetchAvailabilityUpsamplePrefetch(a.id,e,i,t,l,o),o}async _fetchAvailabilityUpsamplePrefetch(e,i,t,a,l,n){if(!this._prefetchingEnabled)return;const o=`prefetch-${e}`;if(this.handles.has(o))return;const r=new AbortController;n.then(()=>r.abort(),()=>r.abort());let h=!1;const s={remove(){h||(h=!0,r.abort())}};if(this.handles.add(s,o),await I(10,r.signal).catch(()=>{}),h||(h=!0,this.handles.remove(o)),M(r))return;const c={id:e,level:i,row:t,col:a},v=b(m({},l),{signal:r.signal}),f=this.layer.tileInfo;for(let L=0;y._prefetches.length<y._maxPrefetch&&f.upsampleTile(c);++L){const $=this.fetchAvailability(c.level,c.row,c.col,v);y._prefetches.push($);const S=()=>{y._prefetches.removeUnordered($)};$.then(S,S)}}_initializeTilemapDefinition(){var e;if(!this.layer.parsedUrl)return;const{parsedUrl:i,apiKey:t,customParameters:a}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:i.path,query:R(b(m(m({},i.query),a),{token:t!=null?t:(e=i.query)==null?void 0:e.token})),tileServers:this.layer.tileServers,request:this.request,type:this.layer.type},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,i,t,a){a.level=e,a.row=i-i%this.size,a.col=t-t%this.size;const l=D(a);return this._tilemapCache.get(l)}_initializeAvailableLevels(e){this._availableLevels={},e&&e.forEach(i=>this._availableLevels[i.level]=!0)}get test(){const e=this;return{get prefetchingEnabled(){return e._prefetchingEnabled},set prefetchingEnabled(i){e._prefetchingEnabled=i},hasTilemap:(i,t,a)=>!!e._tilemapFromCache(i,t,a,e._tmpTilemapDefinition)}}};p._maxPrefetch=4,p._prefetches=new K({initialSize:y._maxPrefetch}),d([_({constructOnly:!0,type:Number})],p.prototype,"levels",void 0),d([W("levels")],p.prototype,"castLevels",null),d([_({readOnly:!0,type:Number})],p.prototype,"size",null),d([_({constructOnly:!0,type:Number})],p.prototype,"cacheByteSize",void 0),d([_({constructOnly:!0})],p.prototype,"layer",void 0),d([_({constructOnly:!0})],p.prototype,"request",void 0),p=y=d([G("esri.layers.support.TilemapCache")],p);export{p as T,V as n,ie as r};
