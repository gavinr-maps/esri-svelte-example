import{y as U}from"./mat3-DRqs2t5W.js";import{e as W}from"./mat3f64-BBpwCtoL.js";import{h as X,s as E,n as F,c as Y}from"./mat4-ybYUU6jq.js";import{e as O}from"./mat4f64-Dk4dwAN8.js";import{n as c,s as p,d as b,q as u,O as H,c as Z}from"./mathUtils-ClvKsMak.js";import{_ as P,V as _}from"./sphere-7666U3LO.js";import{l as tt}from"./ViewingMode-Dodu7ZZk.js";import{I as st,L as rt}from"./orientedBoundingBox-COq6pSqo.js";class gt{constructor(){this._transform=O(),this._transformInverse=new T({value:this._transform},X,O),this._transformInverseTranspose=new T(this._transformInverse,E,O),this._transformTranspose=new T({value:this._transform},E,O),this._transformInverseRotation=new T({value:this._transform},U,W)}_invalidateLazyTransforms(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()}get transform(){return this._transform}get inverse(){return this._transformInverse.value}get inverseTranspose(){return this._transformInverseTranspose.value}get inverseRotation(){return this._transformInverseRotation.value}get transpose(){return this._transformTranspose.value}setTransformMatrix(t){F(this._transform,t)}multiplyTransform(t){Y(this._transform,this._transform,t)}set(t){F(this._transform,t),this._invalidateLazyTransforms()}setAndInvalidateLazyTransforms(t,r){this.setTransformMatrix(t),this.multiplyTransform(r),this._invalidateLazyTransforms()}}class T{constructor(t,r,e){this._original=t,this._update=r,this._dirty=!0,this._transform=e()}invalidate(){this._dirty=!0}get value(){return this._dirty&&(this._update(this._transform,this._original.value),this._dirty=!1),this._transform}}class et{constructor(t=0){this.offset=t,this.tmpVertex=c()}applyToVertex(t,r,e){const i=b(I,t,r,e),a=Z(Q,i,this.localOrigin),o=this.offset/p(a);return u(this.tmpVertex,i,a,o),this.tmpVertex}applyToAabb(t){const r=ot,e=at,i=ht;for(let s=0;s<3;++s)r[s]=t[0+s]+this.localOrigin[s],e[s]=t[3+s]+this.localOrigin[s],i[s]=r[s];const a=this.applyToVertex(r[0],r[1],r[2]);for(let s=0;s<3;++s)t[s]=a[s],t[s+3]=a[s];const o=s=>{const n=this.applyToVertex(s[0],s[1],s[2]);for(let l=0;l<3;++l)t[l]=Math.min(t[l],n[l]),t[l+3]=Math.max(t[l+3],n[l])};for(let s=1;s<8;++s){for(let n=0;n<3;++n)i[n]=s&1<<n?e[n]:r[n];o(i)}let f=0;for(let s=0;s<3;++s)r[s]*e[s]<0&&(f|=1<<s);if(f!==0&&f!==7){for(let s=0;s<8;++s)if(!(f&s)){for(let n=0;n<3;++n)i[n]=f&1<<n?0:s&1<<n?r[n]:e[n];o(i)}}for(let s=0;s<3;++s)t[s]-=this.localOrigin[s],t[s+3]-=this.localOrigin[s];return t}}class nt{constructor(t=0){this.componentLocalOriginLength=0,this._totalOffset=0,this._offset=0,this._tmpVertex=c(),this._tmpMbs=P(),this._tmpObb=new st,this._resetOffset(t)}_resetOffset(t){this._offset=t,this._totalOffset=t}set offset(t){this._resetOffset(t)}get offset(){return this._offset}set componentOffset(t){this._totalOffset=this._offset+t}set localOrigin(t){this.componentLocalOriginLength=p(t)}applyToVertex(t,r,e){const i=b(I,t,r,e),a=b(Q,t,r,e+this.componentLocalOriginLength),o=this._totalOffset/p(a);return u(this._tmpVertex,i,a,o),this._tmpVertex}applyToAabb(t){const r=this.componentLocalOriginLength,e=t[0],i=t[1],a=t[2]+r,o=t[3],f=t[4],s=t[5]+r,n=Math.abs(e),l=Math.abs(i),y=Math.abs(a),x=Math.abs(o),d=Math.abs(f),V=Math.abs(s),w=.5*(1+Math.sign(e*o))*Math.min(n,x),q=.5*(1+Math.sign(i*f))*Math.min(l,d),$=.5*(1+Math.sign(a*s))*Math.min(y,V),z=Math.max(n,x),A=Math.max(l,d),R=Math.max(y,V),j=Math.sqrt(w*w+q*q+$*$),B=Math.sign(n+e),G=Math.sign(l+i),S=Math.sign(y+a),k=Math.sign(x+o),C=Math.sign(d+f),D=Math.sign(V+s),m=this._totalOffset;if(j<m)return t[0]-=(1-B)*m,t[1]-=(1-G)*m,t[2]-=(1-S)*m,t[3]+=k*m,t[4]+=C*m,t[5]+=D*m,t;const M=m/Math.sqrt(z*z+A*A+R*R),g=m/j,v=g-M,L=-v;return t[0]+=e*(B*L+g),t[1]+=i*(G*L+g),t[2]+=a*(S*L+g),t[3]+=o*(k*v+M),t[4]+=f*(C*v+M),t[5]+=s*(D*v+M),t}applyToMbs(t){const r=p(_(t)),e=this._totalOffset/r;return u(_(this._tmpMbs),_(t),_(t),e),this._tmpMbs[3]=t[3]+t[3]*this._totalOffset/r,this._tmpMbs}applyToObb(t){return rt(t,this._totalOffset,this._totalOffset,tt.Global,this._tmpObb),this._tmpObb}}class it{constructor(t=0){this.offset=t,this.sphere=P(),this.tmpVertex=c()}applyToVertex(t,r,e){const i=this.objectTransform.transform,a=b(I,t,r,e),o=H(a,a,i),f=this.offset/p(o);u(o,o,o,f);const s=this.objectTransform.inverse;return H(this.tmpVertex,o,s),this.tmpVertex}applyToMinMax(t,r){const e=this.offset/p(t);u(t,t,t,e);const i=this.offset/p(r);u(r,r,r,i)}applyToAabb(t){const r=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*r,t[1]+=t[1]*r,t[2]+=t[2]*r;const e=this.offset/Math.sqrt(t[3]*t[3]+t[4]*t[4]+t[5]*t[5]);return t[3]+=t[3]*e,t[4]+=t[4]*e,t[5]+=t[5]*e,t}applyToBoundingSphere(t){const r=p(_(t)),e=this.offset/r;return u(_(this.sphere),_(t),_(t),e),this.sphere[3]=t[3]+t[3]*this.offset/r,this.sphere}}const J=new it;function vt(h){return h!=null?(J.offset=h,J):null}const K=new nt;function Ot(h){return h!=null?(K.offset=h,K):null}const N=new et;function Tt(h){return h!=null?(N.offset=h,N):null}const bt="terrain",I=c(),Q=c(),ot=c(),at=c(),ht=c();export{Tt as I,Ot as L,vt as d,gt as v,bt as w};
