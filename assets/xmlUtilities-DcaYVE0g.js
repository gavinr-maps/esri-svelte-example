const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngine-CLtm9OQA.js","./Accessor-BmwT4B0c.js","./Point-Cz2JYYmX.js","./cast-CsZslgGN.js","./index-4eY77cms.js","./index-Cx51aysm.css","./JSONSupport-DcrLLGjL.js","./writer-DKgfqj4X.js","./geometryEngineBase-B0ZyeKAX.js","./_commonjsHelpers-DCkdB7M8.js","./hydrated-DcIAHEVL.js","./Extent-g5W9hy0j.js","./Polyline-s-JzsQqo.js","./mathUtils-Cfq9PL9W.js"])))=>i.map(i=>d[i]);
import{B as ee,h as xe,s as A,a4 as ke,r as g,m as R,a as re,$ as Pe}from"./Accessor-BmwT4B0c.js";import{y as ge,P as Re}from"./cast-CsZslgGN.js";import{r as Je}from"./enumeration-DpvDkLNI.js";import{o as He}from"./writer-DKgfqj4X.js";import{j as E,g as be,L as Ce}from"./Point-Cz2JYYmX.js";import{y as Ie}from"./commonProperties-B0GHoNP5.js";import{g as we,N as De,i as Be,a as $e,p as Se,f as ze,d as ae,w as Ne,v as Me,h as Oe}from"./multidimensionalUtils-CBM5TBCZ.js";import{c as Ee,w as oe,p as We,l as Le,a as Ge,g as qe,e as le,W as ce,t as Ae,z as je,L as Ve,U as Ue,E as Qe,q as ue}from"./ImageHistogramParameters-DjY5GV8g.js";import{j as Xe,n as Ke,m as Ze,_ as Ye,a as et}from"./RasterSymbolizer-DU-Ljv5-.js";import{z as X,p as tt}from"./TileInfo-DxwC9WcY.js";import{_ as it}from"./index-4eY77cms.js";import{j as nt}from"./Polyline-s-JzsQqo.js";import{S as rt}from"./JSONSupport-DcrLLGjL.js";import{QueueProcessor as st}from"./QueueProcessor-BzFcKfHF.js";import{w as V}from"./Extent-g5W9hy0j.js";import{i as he,m as me,h as fe,x as at,s as ot}from"./RawBlockCache-agRrIZ9j.js";import{a as lt}from"./pixelRangeUtils-Bk2sXCMF.js";import{U as Z,D as ve,R as ct,u as ut,l as ht,f as mt,s as ft}from"./dataUtils-Pv68iOZD.js";import{t as U,j as te,B as de,m as pe,u as dt,o as Y,V as Q,a as pt,r as yt,z as xt,Z as ie}from"./rasterProjectionHelper-Wej15Bp6.js";import{h as ne,l as gt,T as Rt}from"./rasterFunctionHelper-Dw9wV9wU.js";import{d as bt}from"./FeatureSet-B5-Veyin.js";const ye=8,It=256;let wt=0,v=class extends rt{constructor(){super(...arguments),this._tileFetchQueue=new st({concurrency:32,process:(t,i)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t!=null&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:X.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,i=U(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){var i,s;this._set("rasterJobHandler",t),this.datasetFormat==="Function"&&((s=(i=this.primaryRasters)==null?void 0:i.rasters)==null||s.forEach(e=>e.rasterJobHandler=t))}get rasterId(){return this.url||"rasterId-"+wt++}set url(t){this._set("url",ge(t,ee.getLogger(this)))}async open(t){return this._openPromise??(this._openPromise=te().then(()=>this._open(t))),this._openPromise}async fetchTile(t,i,s,e={}){const n=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,a=this.getTileExtentFromTileInfo(t,i,s,n);return e={noClip:!0,...e},this.fetchPixels(a,n.size[0],n.size[1],e)}async identify(t,i={}){var L;t=xe(E,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:e}=i,{rasterInfo:n}=this,{hasMultidimensionalTranspose:a,multidimensionalInfo:r}=n;let{transposedVariableName:o}=i;const l=r!=null&&a&&(e!=null||we(s));l&&!o&&(o=s!=null&&s.length>0?s[0].variableName??void 0:r.variables[0].name,i={...i,transposedVariableName:o}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:c,extent:u}=n,{datumTransformation:h}=i;let m=de(t,c,h);if(!u.intersects(m))return{location:m,value:null};if(n.transform!=null){const C=n.transform.inverseTransform(m);if(!n.nativeExtent.intersects(C))return{location:C,value:null};m=C}let d=0;const p=o!=null&&r!=null&&n.hasMultidimensionalTranspose;if(this.datasetFormat==="Function"){const C=this.primaryRasters.rasters[0];if(p)return C.identify(m,i);const{pixelSize:G}=n,S=3,T=G.x*S/2,D=G.y*S/2,B=new V({xmin:m.x-T,xmax:m.x+T,ymin:m.y-D,ymax:m.y+D,spatialReference:c}),W={interpolation:"nearest",multidimensionalDefinition:s,sliceId:i.sliceId},{pixelBlock:F}=await C.fetchPixels(B,S,S,W),{pixelBlock:k}=await this.fetchPixels(B,S,S,W);if(F==null)return{location:m,value:null};const J=Math.floor(S*S*.5),j=!F.mask||F.mask[J]?F.pixels.map(P=>P[J]):null;let $;return k!=null&&($=!k.mask||k.mask[J]?k.pixels.map(P=>P[J]):void 0),{location:m,value:j,processedValue:$,pyramidLevel:0}}if(!p){if(i.srcResolution)d=pe(i.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(d=await this.computeBestPyramidLevelForLocation(t,i),d==null)return{location:m,value:null}}const x=this.identifyPixelLocation(m,d,null,p);if(x===null)return{location:m,value:null};const{row:y,col:f,rowOffset:b,colOffset:I,blockWidth:_}=x,w=o??i.sliceId,z=he(this.rasterId,w),N=`${d}/${y}/${f}`;let M=me(z,null,N);M==null&&(M=this.fetchRawTile(d,y,f,i),fe(z,null,N,M));const H=await M;if(!((L=H==null?void 0:H.pixels)!=null&&L.length))return{location:m,value:null};const O=b*_+I;return this._processIdentifyResult(H,{srcLocation:m,position:O,pyramidLevel:d,useTransposedTile:!!p,requestSomeSlices:l,identifyOptions:i})}async fetchPixels(t,i,s,e={}){t=dt(t),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:n}=this;if(e.requestRawData&&n)return this._fetchPixels(t,i,s,e);const a=U(t.spatialReference),r=Y(t);if(a==null||r===0||r===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(t,i,s,e);if(r>=3)return{extent:t,pixelBlock:null};const o=[],{xmin:l,xmax:c}=t,u=Math.round(a/(c-l)*i),h=u-Math.round((a/2-l)/(c-l)*i);let m=0;const d=[];for(let f=0;f<=r;f++){const b=new V({xmin:f===0?l:-a/2,xmax:f===r?c-a*f:a/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),I=f===0?u-h:f===r?i-m:u;m+=I,d.push(I);const _=e.disableWrapAround&&f>0?null:this._fetchPixels(b,I,s,e);o.push(_)}const p=(await Promise.all(o)).map(f=>f==null?void 0:f.pixelBlock);let x=null;const y={width:i,height:s};return this.rasterJobHandler?x=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:d},e)).pixelBlock:x=Z(p,y,{blockWidths:d}),{extent:t,srcExtent:Q(t,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:x}}async fetchRawPixels(t,i,s,e={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const n=await this._fetchRawTiles(t,i,s,e),{nativeExtent:a,nativePixelSize:r,storageInfo:o}=this.rasterInfo,l=2**t,c=r.x*l,u=r.y*l,h=new V({xmin:a.xmin+c*i.x,xmax:a.xmin+c*(i.x+s.width-1),ymin:a.ymax-u*(i.y+s.height-1),ymax:a.ymax-u*i.y,spatialReference:a.spatialReference});if(!n)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:m,mosaicSize:d}=n;if(m.length===1&&m[0]!=null&&m[0].width===s.width&&m[0].height===s.height)return{extent:h,srcExtent:h,pixelBlock:n.pixelBlocks[0]};const p=t>0?o.pyramidBlockWidth:o.blockWidth,x=t>0?o.pyramidBlockHeight:o.blockHeight,y={x:i.x%p,y:i.y%x};let f;return this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:m,srcMosaicSize:d,destDimension:s,clipOffset:y,clipSize:s,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:f=Z(m,d,{clipOffset:y,clipSize:s}),{extent:h,srcExtent:h,pixelBlock:f}}fetchRawTile(t,i,s,e){throw new A("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Q(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?Xe(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,s=0){const{customFetchParameters:e}=this.ioConfig,{range:n,query:a,headers:r}=i;s=s??i.retryCount??this.ioConfig.retryCount;const o=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await Re(t,{...i,query:{...a,...e},headers:{...r,...o}})}catch(l){if(s>0)return s--,this.request(t,i,s);throw l}}getSliceIndex(t){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:De(t,i)}getTileExtentFromTileInfo(t,i,s,e){const n=e.lodAt(t);return this.getTileExtent({x:n.resolution,y:n.resolution},i,s,e.origin,e.spatialReference,e.size)}updateTileInfo(){const{storageInfo:t,spatialReference:i,extent:s,pixelSize:e}=this.rasterInfo,{pyramidResolutions:n}=t;if(!t.tileInfo){const a=[],r=t.maximumPyramidLevel||0;let o=(e.x+e.y)/2,l=1/.0254*96*o;for(let u=0;u<=r&&(a.unshift(new tt({level:r-u,resolution:o,scale:l})),u!==r);u++)if(n){const h=(n[u].x+n[u].y)/2;l*=h/o,o=h}else o*=2,l*=2;const c=new E({x:s.xmin,y:s.ymax,spatialReference:i});t.tileInfo=new X({origin:c,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:a}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,s=512,e){const{width:n,height:a,nativeExtent:r,pixelSize:o,spatialReference:l}=t,c=new E({x:r.xmin,y:r.ymax,spatialReference:l});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(n,a))/Math.LN2-8)));const u=this.computeBlockBoundary(r,512,512,{x:r.xmin,y:r.ymax},[o],e);t.storageInfo=new Ke({blockWidth:i,blockHeight:s,pyramidBlockWidth:i,pyramidBlockHeight:s,origin:c,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,s,e,n,a=0,r=2){if(n.length===1&&a>0){n=[...n];let{x:u,y:h}=n[0];for(let m=0;m<a;m++)u*=r,h*=r,n.push({x:u,y:h})}const o=[],{x:l,y:c}=e;for(let u=0;u<n.length;u++){const{x:h,y:m}=n[u];o.push({minCol:Math.floor((t.xmin-l+.1*h)/i/h),maxCol:Math.floor((t.xmax-l-.1*h)/i/h),minRow:Math.floor((c-t.ymax+.1*m)/s/m),maxRow:Math.floor((c-t.ymin-.1*m)/s/m)})}return o}getPyramidPixelSize(t){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(t===0)return i;if(s!=null&&s.length)return s[t-1];const n=e**t;return{x:i.x*n,y:i.y*n}}identifyPixelLocation(t,i,s,e){const{spatialReference:n,nativeExtent:a,storageInfo:r}=this.rasterInfo,{maximumPyramidLevel:o,origin:l,transposeInfo:c}=r,u=e&&c!=null?c.tileSize[0]:r.blockWidth,h=e&&c!=null?c.tileSize[1]:r.blockHeight,m=de(t,n,s);if(!a.intersects(m)||i<0||i>o)return null;const d=this.getPyramidPixelSize(i),{x:p,y:x}=d,y=(l.y-m.y)/x/h,f=(m.x-l.x)/p/u,b=Math.min(h-1,Math.floor((y-Math.floor(y))*h)),I=Math.min(u-1,Math.floor((f-Math.floor(f))*u));return{pyramidLevel:i,row:Math.floor(y),col:Math.floor(f),rowOffset:b,colOffset:I,blockWidth:u,srcLocation:m}}getTileExtent(t,i,s,e,n,a){const[r,o]=a,l=e.x+s*r*t.x,c=l+r*t.x,u=e.y-i*o*t.y,h=u-o*t.y;return new V({xmin:l,xmax:c,ymin:h,ymax:u,spatialReference:n})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,s){const e=this.rasterInfo.storageInfo.blockBoundary[t];return!e||e.maxRow<i||e.maxCol<s||e.minRow>i||e.minCol>s}updateImageSpaceRasterInfo(t){const{pixelSize:i}=t,{width:s,height:e}=t,n=be.WebMercator;t.spatialReference=n,t.extent=t.nativeExtent=new V({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-e,spatialReference:n}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new E({x:1,y:1,spatialReference:n});const{extent:a,storageInfo:r}=t;if(r){r.origin=new E({x:a.xmin,y:a.ymax,spatialReference:n});const{pyramidResolutions:o,tileInfo:l}=r;if(o&&o.forEach(c=>{c.x/=i.x,c.y/=i.y}),l){l.origin=r.origin;const c=(t.nativePixelSize.x+t.nativePixelSize.y)/2;l.lods.forEach((u,h)=>{u.resolution=c*2**h,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(t,i,s,e={}){let n=Y(t);if(n>=2)return{extent:t,pixelBlock:null};const a=this._getSourceDataInfo(t,i,s,e),{pyramidLevel:r,srcResolution:o,srcExtent:l,srcWidth:c,srcHeight:u,ul:h}=a;if(c===0||u===0)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:m}=this,d=m.transform,p=(d==null?void 0:d.type)==="gcs-shift",x=U(t.spatialReference)!=null;!p&&x||(n=Y(a.srcExtent,p));const y=await this._fetchRawTiles(r,h,{width:c,height:u,wrapCount:n},e);if(!y)return{extent:t,srcExtent:l,pixelBlock:null};const f=m.storageInfo,b=r>0?f.pyramidBlockWidth:f.blockWidth,I=r>0?f.pyramidBlockHeight:f.blockHeight;let{x:_,y:w}=m.pixelSize;if(r>0){const{pyramidResolutions:P,pyramidScalingFactor:Fe}=f;if(P!=null&&P[r-1])({x:_,y:w}=P[r-1]);else{const se=Fe**r;_*=se,w*=se}}const z=m.spatialReference,N=new E({x:_,y:w,spatialReference:z}),M=b===c&&I===u&&h.x%b==0&&h.y%I==0,H=new E({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),O=!t.spatialReference.equals(z),L=z.isGeographic?1e-9:1e-4,{datumTransformation:C}=e;if(!O&&M&&y.pixelBlocks.length===1&&b===i&&I===s&&St(o,H,L))return{extent:t,srcExtent:l,srcTilePixelSize:N,pixelBlock:y.pixelBlocks[0]};const G=x&&U(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,S=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");S&&!this.rasterJobHandler&&await te();const T=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:y.extent,pixelSize:H.toJSON(),datumTransformation:C,rasterTransform:d,hasWrapAround:n>0||G,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:S},e):pt({projectedExtent:t,srcBufferExtent:y.extent,pixelSize:H,datumTransformation:C,rasterTransform:d,hasWrapAround:n>0||G,isAdaptive:!1,includeGCSGrid:S});let D;const B=!e.requestRawData,W={rows:T.spacing[0],cols:T.spacing[1]},F=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(r,y.extent.xmin):void 0,{pixelBlocks:k,mosaicSize:J,isPartiallyFilled:j}=y;let $=null;if(this.rasterJobHandler)({pixelBlock:D,localNorthDirections:$}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:k,srcMosaicSize:J,destDimension:B?{width:i,height:s}:null,coefs:B?T.coefficients:null,sampleSpacing:B?W:null,projectDirections:S,gcsGrid:S?T.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:F,blockWidths:null},e));else{const P=Z(k,J,{alignmentInfo:F});D=B?ve(P,{width:i,height:s},T.coefficients,W,e.interpolation):P,S&&T.gcsGrid&&($=ct({width:i,height:s},T.gcsGrid),D=ut(D,this.rasterInfo.dataType,$))}return e.requestRawData||S?{extent:t,srcExtent:l,srcTilePixelSize:N,pixelBlock:D,transformGrid:T,localNorthDirections:$,isPartiallyFilled:j}:{extent:t,srcExtent:l,srcTilePixelSize:N,pixelBlock:D}}async _fetchRawTiles(t,i,s,e){const{origin:n,blockBoundary:a}=this.rasterInfo.storageInfo,{blockWidth:r,blockHeight:o}=this.getBlockWidthHeight(t);let{x:l,y:c}=i,{width:u,height:h,wrapCount:m}=s;const d=this._getRasterTileAlignmentInfo(t,0);e.buffer&&(l-=e.buffer.cols,c-=e.buffer.rows,u+=2*e.buffer.cols,h+=2*e.buffer.rows);let p=0,x=0,y=0;m&&d!=null&&({worldColumnCountFromOrigin:x,originColumnOffset:y,rightPadding:p}=d,x*d.blockWidth-p>=l+u&&(p=0));const f=Math.floor(l/r),b=Math.floor(c/o),I=Math.floor((l+u+p-1)/r),_=Math.floor((c+h+p-1)/o),w=a[t];if(!w)return null;const{minRow:z,minCol:N,maxCol:M,maxRow:H}=w;if(m===0&&(_<z||I<N||b>H||f>M))return null;const O=new Array;let L=!1;const C=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let F=b;F<=_;F++)for(let k=f;k<=I;k++){let J=k;if(!e.disableWrapAround&&m&&d!=null&&x<=k&&(J=k-x-y),F>=z&&J>=N&&H>=F&&M>=J){const j=this._tileFetchQueue.push({pyramidLevel:t,row:F,col:J,options:e},{signal:e.signal});C?O.push(new Promise($=>{j.then(P=>$(P)).catch(()=>{L=!0,$(null)})})):O.push(j)}else O.push(Promise.resolve(null))}if(O.length===0)return null;const G=await Promise.all(O),S={height:(_-b+1)*o,width:(I-f+1)*r},{spatialReference:T}=this.rasterInfo,D=this.getPyramidPixelSize(t),{x:B,y:W}=D;return{extent:new V({xmin:n.x+f*r*B,xmax:n.x+(I+1)*r*B,ymin:n.y-(_+1)*o*W,ymax:n.y-b*o*W,spatialReference:T}),pixelBlocks:G,mosaicSize:S,isPartiallyFilled:L}}_fetchRawTile(t,i,s,e){const n=this.rasterInfo.storageInfo.blockBoundary[t];if(!n)return Promise.resolve(null);const{minRow:a,minCol:r,maxCol:o,maxRow:l}=n;if(i<a||s<r||i>l||s>o)return Promise.resolve(null);const c=he(this.rasterId,e.sliceId),u=`${t}/${i}/${s}`;let h=me(c,e.registryId,u);if(h==null){const m=new AbortController;h=this.fetchRawTile(t,i,s,{...e,signal:m.signal}),fe(c,e.registryId,u,h,m),h.catch(()=>at(c,e.registryId,u))}return e.signal&&ke(e,()=>{ot(c,e.registryId,u)}),h}_computeMagDirValues(t){var l;const{bandCount:i,dataType:s}=this.rasterInfo;if(!(i===2&&s==="vector-magdir"||s==="vector-uv")||(t==null?void 0:t.length)!==2||!((l=t[0])!=null&&l.length))return null;const e=t[0].length;if(s==="vector-magdir"){const c=t[1].map(u=>(u+360)%360);return[t[0],c]}const[n,a]=t,r=[],o=[];for(let c=0;c<e;c++){const[u,h]=ht([n[c],a[c]]);r.push(u),o.push(h)}return[r,o]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=yt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,i,s,e={}){const n={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(n.srcResolution=e.srcResolution,this._updateSourceDataInfo(t,n));const a=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:r,srcHeight:o,pyramidLevel:l}=n,c=r/i,u=o/s,h=l<a&&c*u>=16,m=l===a&&this._requireTooManySrcTiles(r,o,i,s);if(h||m||r===0||o===0){const d=new E({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let p=xt(d,this.rasterInfo.spatialReference,t,n.datumTransformation);const x=!p||e.srcResolution&&p.x+p.y<e.srcResolution.x+e.srcResolution.y;if(h&&e.srcResolution&&x){const y=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(a-l+3>=y){const f=2**y;p={x:e.srcResolution.x*f,y:e.srcResolution.y*f}}}p&&(n.srcResolution=p,this._updateSourceDataInfo(t,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,i,s)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(t,i,s,e){const{tileInfo:n}=this.rasterInfo.storageInfo,a=Math.ceil(t/n.size[0])*Math.ceil(i/n.size[1]),r=t/s,o=i/e,l=Math.max(1,(s+e)/1024);return a>=It*l||r>ye||o>ye}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:s}=this,e=s.spatialReference,{srcResolution:n,datumTransformation:a}=i,{pyramidLevel:r,pyramidResolution:o,excessiveReading:l}=pe(n,s,this.ioConfig.sampling);if(l)return;let c=i.srcExtent||Q(t,e,a);if(c==null)return;const u=s.transform;u&&(c=u.inverseTransform(c)),i.srcExtent=c;const{x:h,y:m}=s.storageInfo.origin,d=Math.floor((c.xmin-h)/o.x+.1),p=Math.floor((m-c.ymax)/o.y+.1),x=Math.floor((c.xmax-h)/o.x-.1),y=Math.floor((m-c.ymin)/o.y-.1),f=c.width<.1*o.x?0:x-d+1,b=c.height<.1*o.y?0:y-p+1;i.pyramidLevel=r,i.pyramidResolution=o,i.srcWidth=f,i.srcHeight=b,i.ul={x:d,y:p}}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,i){const{srcLocation:s,position:e,pyramidLevel:n,useTransposedTile:a}=i,r=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[e]))return{location:s,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!a){const y=t.pixels.map(I=>I[e]),f={location:s,value:y,pyramidLevel:n},b=this._computeMagDirValues(y.map(I=>[I]));return b!=null&&b.length&&(f.magdirValue=b.map(I=>I[0])),f}let l=t.pixels.map(y=>y.slice(e*r,e*r+r)),c=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:h}=i;let m=Be(o,h.transposedVariableName);if(u){const y=$e(m,h.multidimensionalDefinition,h.timeExtent);l=l.map(f=>y.map(b=>f[b])),c=c==null?void 0:c.map(f=>y.map(b=>f[b])),m=y.map(f=>m[f])}const d=t.noDataValues||this.rasterInfo.noDataValue,p={pixels:l,pixelType:t.pixelType};let x;return d!=null&&(lt(p,d),x=p.mask),{location:s,value:null,dataSeries:m.map((y,f)=>{const b={value:(x==null?void 0:x[f])===0?null:l.map(I=>I[f]),multidimensionalDefinition:y.multidimensionalDefinition.map(I=>new Se({...I,isSlice:!0}))};return c!=null&&c.length&&(b.magdirValue=[c[0][f],c[1][f]]),b}),pyramidLevel:n}}};function St(t,i,s){return Math.abs(t.x-i.x)<s&&Math.abs(t.y-i.y)<s}g([R()],v.prototype,"_rasterTileAlignmentInfo",void 0),g([R()],v.prototype,"_tileFetchQueue",void 0),g([R({readOnly:!0})],v.prototype,"_isGlobalWrappableSource",null),g([R({readOnly:!0})],v.prototype,"_hasNoneOrGCSShiftTransform",null),g([R()],v.prototype,"_openPromise",void 0),g([R()],v.prototype,"rasterJobHandler",null),g([R({readOnly:!0})],v.prototype,"rasterId",null),g([R(Ie)],v.prototype,"url",null),g([R({type:String,json:{write:!0}})],v.prototype,"datasetName",void 0),g([R({type:String,json:{write:!0}})],v.prototype,"datasetFormat",void 0),g([R()],v.prototype,"hasUniqueSourceStorageInfo",void 0),g([R()],v.prototype,"rasterInfo",void 0),g([R()],v.prototype,"ioConfig",void 0),g([R()],v.prototype,"sourceJSON",void 0),v=g([re("esri.layers.support.rasterDatasets.BaseRaster")],v);const vt=v,_t=40;let q=class extends vt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,i,s,e={}){var I,_;const{rasters:n,rasterIds:a}=this.primaryRasters;let r=!1;const{interpolation:o}=e,l=(I=this.rasterFunction.flatWebGLFunctionChain)==null?void 0:I.hasFocalFunction;!e.requestRawData&&l&&(r=n.length===1&&!e.skipRasterFunction,e={...e,interpolation:"bilinear",requestRawData:r});const c=n.map(w=>w.fetchPixels(t,i,s,e)),u=await Promise.all(c),h=u.map(w=>w.pixelBlock),m=r||e.requestRawData?u.map(w=>w.srcTilePixelSize):null;if(e.skipRasterFunction||h.every(w=>w==null))return u[0];const d=((_=u.find(w=>w.pixelBlock!=null))==null?void 0:_.extent)??t;let p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:d,primaryPixelBlocks:h,primaryPixelSizes:m,primaryRasterIds:a}):this.rasterFunction.process({extent:d,primaryPixelBlocks:h,primaryPixelSizes:m,primaryRasterIds:a});const{transformGrid:x}=u[0];if(!r||p==null||x==null){const w=e.noClip?null:this.getClippingGeometry(d.spatialReference);return e.noClip||e.requestRawData||p==null||!w||(p=await ne(p,d,w)),{...u[0],pixelBlock:p}}const y={rows:x.spacing[0],cols:x.spacing[1]};let f;this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:i,height:s},coefs:x.coefficients,sampleSpacing:y,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},e)).pixelBlock:f=ve(p,{width:i,height:s},x.coefficients,y,o);const b=e.noClip?null:this.getClippingGeometry(t.spatialReference);return e.noClip||e.requestRawData||f==null||b==null||(f=await ne(f,t,b)),{extent:t,srcExtent:u[0].srcExtent,pixelBlock:f}}getClippingGeometry(t){const i=this._clippingGeometry.get("0");if(!t||!i)return i;const s=kt(t);let e=this._clippingGeometry.get(s);return e!=null||(e=t.equals(i.spatialReference)?i:ie(i,t),this._clippingGeometry.set(s,e)),e}async _open(t){var c,u,h,m;const{rasterFunction:i}=this;(u=(c=this.primaryRasters)==null?void 0:c.rasters)!=null&&u.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&((h=this.primaryRasters.rasters)==null||h.forEach(d=>d.rasterJobHandler=this.rasterJobHandler)));const{rasters:s,rasterIds:e}=this.primaryRasters,n=s.map(d=>d.rasterInfo?void 0:d.open(t));await Promise.all(n);const a=s.map(({rasterInfo:d})=>d),r=i.bind({rasterInfos:a,rasterIds:e});if(i.rawSourceRasterInfos=a,!r.success||a.length===0)throw new A("raster-function:open",`cannot bind the function: ${r.error??""}`);const o=i.functionName==="Table"?i:(m=i.functionArguments)==null?void 0:m.raster;(o==null?void 0:o.functionName)==="Table"&&(i.rasterInfo.attributeTable=bt.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=a[0];this.hasUniqueSourceStorageInfo=a.length===1||a.slice(1).every(d=>Ft(d,l)),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var t;return(t=this.rasterJobHandler)==null?void 0:t.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let i=t==null?void 0:t.clippingGeometry;if(i&&t.clippingType==="inside"){const{extent:s}=this.rasterInfo,{difference:e,densify:n}=await it(async()=>{const{difference:r,densify:o}=await import("./geometryEngine-CLtm9OQA.js");return{difference:r,densify:o}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13]),import.meta.url);let a=n(nt.fromExtent(s),2*(s.width+s.height)/_t);a=ie(a,i.spatialReference),i=e(a,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};g([R({type:String,json:{write:!0}})],q.prototype,"datasetFormat",void 0),g([R()],q.prototype,"tileType",void 0),g([R()],q.prototype,"rasterFunction",void 0),g([R()],q.prototype,"primaryRasters",void 0),q=g([re("esri.layers.support.rasterDatasets.FunctionRaster")],q);const Tt=q;function Ft(t,i){const{storageInfo:s,pixelSize:e,spatialReference:n,extent:a}=t,{storageInfo:r,pixelSize:o,spatialReference:l,extent:c}=i;return e.x===o.x&&e.y===o.y&&n.equals(l)&&a.equals(c)&&s.blockHeight===r.blockHeight&&s.blockWidth===r.blockWidth&&s.maximumPyramidLevel===r.maximumPyramidLevel}function kt(t){return String(t.wkid??t.wkt??t.wkt2)}const Kt=t=>{let i=class extends t{constructor(...e){var n,a;super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=((a=(n=e[0])==null?void 0:n.raster)==null?void 0:a.datasetFormat)==="Function"}get fullExtent(){var e;return(e=this.serviceRasterInfo)==null?void 0:e.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){var n;((n=e==null?void 0:e.functionName)==null?void 0:n.toLowerCase())==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",ge(e,ee.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;if(e){const a=n==null?void 0:n.find(({name:r})=>r===e);return a==null?void 0:a.renderer.clone()}return this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,a){var o,l;const r=(l=(o=n==null?void 0:n.layerDefinition)==null?void 0:o.drawingInfo)==null?void 0:l.renderer;return Ge(r,a)||void 0}async convertVectorFieldData(e,n){const{serviceRasterInfo:a}=this;if(e==null||!a)return null;const r=this._rasterJobHandler.instance,o=a.dataType;return r?r.convertVectorFieldData({pixelBlock:e,dataType:o},n):mt(e,o)}async computeStatisticsHistograms(e,n){await this.load(n),e=xe(qe,e).clone();const{serviceRasterInfo:a}=this;if(a==null)throw new A("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:r}=e;if(r==null)throw new A("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let o=r;const{spatialReference:l}=a;r.spatialReference.equals(l)||(await te(),o=r.type==="extent"?Q(r,l):ie(r,l));const c=e.pixelSize??new E({x:a.pixelSize.x,y:a.pixelSize.y,spatialReference:l}),{extent:u,width:h,height:m}=gt(a,o,c),d=await this.fetchPixels(u,h,m,{...n,interpolation:"nearest"});if(d.pixelBlock==null)throw new A("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const p=await ne(d.pixelBlock,u,o),x=this._rasterJobHandler.instance;return x?x.computeStatisticsHistograms({pixelBlock:p},n):Ze(p)}async createFlowMesh(e,n){const a=this._rasterJobHandler.instance;return a?a.createFlowMesh(e,n):ft(e.meshType,e.simulationSettings,e.flowData,n.signal!=null?n.signal:new AbortController().signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const a=ze({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:a}}async updateRasterFunction(){var e;return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=(e=this.rasterFunction)==null?void 0:e.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n}=this;if(!e||!n||!this.renderer)return;const{rasterInfo:a}=this.raster,r=ae(a,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=r==null?void 0:r.name,l=le({...this.renderer.toJSON(),variableName:o});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(l))return;const c=this._rasterJobHandler.instance;c&&(n.rasterInfo=ce(a,o),n.rendererJSON=l,n.bind(),await c.updateSymbolizer(n),this._cachedRendererJson=l)}async applyRenderer(e,n){const a=e==null?void 0:e.pixelBlock;if(!(a!=null&&a.pixels&&a.pixels.length>0))return null;let r;await this.updateRenderer();const o=this._rasterJobHandler.instance,l=this.bandIds??[];return r=o?await o.symbolize({...e,simpleStretchParams:n,bandIds:l}):this.symbolizer.symbolize({...e,simpleStretchParams:n,bandIds:l}),r}getTileUrl(e,n,a){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${a}`:""}getCompatibleTileInfo(e,n,a=!1){if(!this.loaded||n==null)return null;if(a&&e.equals(this.spatialReference))return this.tileInfo;const r=Ce(e);return X.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){var n;return this.loaded?((n=this._compatibleFullExtent)!=null&&n.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,a,r={}){var l;if(s(this),r.requestAsImageElement){const c=this.getTileUrl(e,n,a);return Re(c,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then(u=>u.data)}const{serviceRasterInfo:o}=this;if(o.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null){const c=r.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,n,a,c),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),((l=this.renderer)==null?void 0:l.type)==="raster-shaded-relief"&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,a,r)}async fetchPixels(e,n,a,r={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),a=Math.round(a),this.raster.fetchPixels(e,n,a,r))}async identify(e,n={}){var l;await this.load();const{raster:a,serviceRasterInfo:r}=this;if((r==null?void 0:r.multidimensionalInfo)!=null&&!(r.hasMultidimensionalTranspose&&(we(n.multidimensionalDefinition)||n.transposedVariableName||n.timeExtent))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const o=(l=this.multidimensionalSubset)==null?void 0:l.areaOfInterest;if(o&&!o.contains(e))throw new A("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return a.identify(e,n)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){var r,o,l;const e=(r=this.serviceRasterInfo)==null?void 0:r.multidimensionalInfo;if(e==null||((o=this.serviceRasterInfo)==null?void 0:o.dataType)!=="standard-time")return!1;const n=this.multidimensionalDefinition,a=(l=n==null?void 0:n[0])==null?void 0:l.variableName;return e.variables.some(c=>c.name===a&&(!(n!=null&&n[0].dimensionName)||c.dimensions.some(u=>u.name==="StdTime")))}getStandardTimeValue(e){return new Date(Ne(e)).toISOString()}getMultidimensionalSubsetVariables(e){var a;const n=e??((a=this.serviceRasterInfo)==null?void 0:a.multidimensionalInfo);return Me(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Oe(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&this.raster.datasetFormat==="Function"&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(this._rasterJobHandler.connectionPromise!=null)return this._rasterJobHandler.connectionPromise;const e=new Ae;return this._rasterJobHandler.connectionPromise=e.initialize().then(async()=>{s(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.raster.datasetFormat==="Function"&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){var e;if(this.interpolation==null){s(this);const{raster:n}=this,a=je(n.rasterInfo,n.tileType,(e=this.sourceJSON)==null?void 0:e.defaultResamplingMethod);this._set("interpolation",a)}}_configDefaultRenderer(e="no"){var h,m,d;s(this);const{rasterInfo:n}=this.raster,a=ae(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=a==null?void 0:a.name,o=Ve({variableName:r,rasterFunctionName:(h=this.rasterFunction)==null?void 0:h.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=(o==null?void 0:o.bandIds)??Ue(n)),!this.renderer||e==="override"){const p=Qe(this.raster),x=(o==null?void 0:o.renderer)??ue(n,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:p}),y=n.statistics,f=y&&y.length>0?y[0]:null,b=(f==null?void 0:f.max)??0,I=(f==null?void 0:f.min)??0;this.raster.datasetFormat==="WCSServer"&&x.type==="raster-stretch"&&(b>1e24||I<-1e24)&&(x.dynamicRangeAdjustment=!0,x.customStatistics=null,x.stretchType==="none"&&(x.stretchType="min-max")),this.renderer=x}const l=le({...this.renderer.toJSON(),variableName:r}),c=ce(n,r);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=c):this.symbolizer=new Ye({rendererJSON:l,rasterInfo:c});const u=this.symbolizer.bind();if(u.success){if(e==="auto"){const{colormap:p}=this.raster.rasterInfo,x=this.renderer;if(p!=null&&x.type==="raster-colormap"){const y=ue(this.raster.rasterInfo);JSON.stringify(y)!==JSON.stringify(x)&&this._configDefaultRenderer("override")}else if(x.type==="raster-stretch"){const y=(m=this.bandIds)==null?void 0:m.length,f=(d=x.customStatistics)==null?void 0:d.length;!x.dynamicRangeAdjustment&&f&&y&&f!==y&&this._configDefaultRenderer("override")}}}else ee.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){var u;if(this._isConstructedFromFunctionRaster&&this.raster.datasetFormat==="Function"){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",oe.fromJSON(h)))}let e,n=this.raster,a=!1;n.datasetFormat==="Function"?(e=n.primaryRasters.rasters,n=e[0],a=!0):e=[n];const{rasterFunction:r}=this;if(r){const h={raster:n};e.length>1&&e.forEach(p=>h[p.url]=p);const m=Rt(((u=r.functionDefinition)==null?void 0:u.toJSON())??r.toJSON(),h),d=new Tt({rasterFunction:m});d.rasterJobHandler=this._rasterJobHandler.instance,await d.open(),this.raster=d}else this.raster=n,await n.open();if(this._cachedRendererJson=null,!a&&!r)return;const{bandIds:o}=this,{bandCount:l}=this.raster.rasterInfo,c=o!=null&&o.length?o.some(h=>h>=l):l>=3;o&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}};function s(e){if(!e.raster||!e.serviceRasterInfo)throw new A("imagery-tile","no raster")}return g([R({clonable:!1})],i.prototype,"_cachedRendererJson",void 0),g([R({clonable:!1})],i.prototype,"_cachedRasterFunctionJson",void 0),g([R({clonable:!1})],i.prototype,"_compatibleFullExtent",void 0),g([R({clonable:!1})],i.prototype,"_isConstructedFromFunctionRaster",void 0),g([R({clonable:!1})],i.prototype,"_rasterJobHandler",void 0),g([R({clonable:!1})],i.prototype,"_rasterFunctionUpdatePromise",void 0),g([R({type:[Pe],json:{write:{overridePolicy(){var e;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((e=this.bandIds)==null?void 0:e.join(","))!=="0,1,2"}}}}})],i.prototype,"bandIds",void 0),g([R({json:{origins:{service:{read:{source:"copyrightText"}}}}})],i.prototype,"copyright",void 0),g([R({json:{read:!1}})],i.prototype,"fullExtent",null),g([R({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Je(et)],i.prototype,"interpolation",void 0),g([R()],i.prototype,"ioConfig",void 0),g([R({type:[Se],json:{write:!0}})],i.prototype,"multidimensionalDefinition",null),g([R({type:Ee,json:{write:!0}})],i.prototype,"multidimensionalSubset",void 0),g([R()],i.prototype,"raster",void 0),g([R({type:oe})],i.prototype,"rasterFunction",null),g([R()],i.prototype,"serviceRasterInfo",void 0),g([R()],i.prototype,"sourceJSON",void 0),g([R({readOnly:!0,type:be,json:{read:!1}})],i.prototype,"spatialReference",void 0),g([R({type:X})],i.prototype,"tileInfo",void 0),g([R(Ie)],i.prototype,"url",null),g([R()],i.prototype,"renderer",null),g([R({types:Le,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var n;const e=((n=this.renderer)==null?void 0:n.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:We,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],i.prototype,"internalRenderer",null),g([He("internalRenderer")],i.prototype,"readRenderer",null),g([R({clonable:!1})],i.prototype,"symbolizer",void 0),i=g([re("esri.layers.mixins.ImageryTileMixin")],i),i};function K(t,i){if(!t||!i)return[];let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=[];if(i){const a=K(t,s);for(let r=0;r<a.length;r++)K(a[r],i).forEach(o=>e.push(o));return e}const n=t.getElementsByTagNameNS("*",s);if(!n||n.length===0)return[];for(let a=0;a<n.length;a++)e.push(n[a]||n.item(a));return e}function _e(t,i){if(!t||!i)return null;let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=K(t,s);return e.length>0?i?_e(e[0],i):e[0]:null}function Te(t,i=null){const s=i?_e(t,i):t;let e;return s?(e=s.textContent||s.nodeValue,e?e.trim():null):null}function Pt(t,i){const s=K(t,i),e=[];let n;for(let a=0;a<s.length;a++)n=s[a].textContent||s[a].nodeValue,n&&(n=n.trim(),n!==""&&e.push(n));return e}function Zt(t,i=null){const s=Te(t,i);return(s==null?void 0:s.split(" ").map(e=>Number(e)))??[]}function Yt(t,i){return Pt(t,i).map(s=>Number(s))}function ei(t,i){const s=Te(t,i);return Number(s)}function ti(t,i){var n;const s=(n=t==null?void 0:t.nodeName)==null?void 0:n.toLowerCase(),e=i.toLowerCase();return s.slice(s.lastIndexOf(":")+1)===e}function ii(t){return t.nodeName.slice(t.nodeName.lastIndexOf(":")+1)}export{Kt as K,vt as X,Tt as a,ii as c,_e as e,ti as i,Pt as l,K as n,ei as o,Zt as r,Te as t,Yt as u};
