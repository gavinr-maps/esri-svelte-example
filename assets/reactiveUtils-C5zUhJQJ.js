import{d as M}from"./asyncUtils-CWX51uTe.js";import{V as w}from"./Collection-CEdjem1-.js";import{f as g,g as x,h as P,i as $,u as m,m as j,j as v,l as d}from"./Accessor-BLX9ikPh.js";import{k as Y}from"./Accessor-BLX9ikPh.js";import{t as H,i as O,e as R}from"./subclass-BZA_h8Db.js";import"./tslib.es6-B3Jf3DVX.js";import"./Evented-BHRw9x22.js";import"./shared-B3wH2qpO.js";import"./SimpleObservable-KocWTzVy.js";function h(t,r,n={}){return p(t,r,n,C)}function F(t,r,n={}){return p(t,r,n,L)}function p(t,r,n={},o){let e=null;const s=n.once?(a,i)=>{o(a)&&(d(e),r(a,i))}:(a,i)=>{o(a)&&r(a,i)};if(e=g(t,s,n.sync,n.equals),n.initial){const a=t();s(a,a)}return e}function V(t,r,n,o={}){let e=null,s=null,a=null;function i(){var u;e&&s&&(s.remove(),(u=o.onListenerRemove)==null||u.call(o,e),e=null,s=null)}function c(u){o.once&&o.once&&d(a),n(u)}const l=h(t,(u,f)=>{var y;i(),x(u)&&(e=u,s=P(u,r,c),(y=o.onListenerAdd)==null||y.call(o,u))},{sync:o.sync,initial:!0});return a=R(()=>{l.remove(),i()}),a}function G(t,r){return A(t,null,r)}function J(t,r){return A(t,L,r)}function A(t,r,n){if($(n))return Promise.reject(m());const o=t();if(r!=null&&r(o))return Promise.resolve(o);let e=null;function s(){e=d(e)}return new Promise((a,i)=>{e=H([j(n,()=>{s(),i(m())}),p(t,c=>{s(),a(c)},{sync:!1,once:!0},r??C)])})}function C(t){return!0}function L(t){return!!t}function K(t,r,n={}){let o=!1;const e=h(t,(s,a)=>{o||r(s,a)},n);return{remove(){e.remove()},pause(){o=!0},resume(){o=!1}}}function b(t,r){const n=new w,o=V(t,"after-splice",({added:e,start:s,deleteCount:a})=>{const i=n.splice(s,a);for(const c of i)c.remove();if(e!=null&&e.length){const c=e.map(r);n.addMany(c,s)}},{sync:!0,onListenerRemove:()=>n.drain(e=>e.remove()),onListenerAdd:e=>n.addMany(e.items.map(r))});return n.addHandles(o),n}function N(t,r){const n=new w,o=b(t,i=>M(async c=>{const l=await r(i,c);if($(c))throw l.remove(),m();return l})),e=()=>null,s=async i=>{const c=await i.promise,l=o.indexOf(i);l<0||n.splice(l,1,c)};n.addMany(o.items.map(e));for(const i of o)v(s(i));const a=o.on("after-splice",({added:i,start:c,deleteCount:l})=>{const u=n.splice(c,l);for(const f of u)f==null||f.remove();if(i!=null&&i.length){n.addMany(i.map(e),c);for(const f of i)v(s(f))}});return n.addHandles([O(o),a]),n}const Q={sync:!0},S={initial:!0},T={sync:!0,initial:!0};export{Y as autorun,S as initial,b as mapCollection,N as mapCollectionAsync,V as on,G as once,K as pausable,Q as sync,T as syncAndInitial,h as watch,F as when,J as whenOnce};
