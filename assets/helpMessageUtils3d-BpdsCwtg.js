import{Q as l,$ as b}from"./Point-Cz2JYYmX.js";import{o as M}from"./vec32-Dvg_eL9J.js";import{n as P}from"./vec3f64-BLpZdpfb.js";import{a as S,b as T}from"./elevationInfoUtils-D26wVF2d.js";import"./Accessor-BmwT4B0c.js";import"./cast-CsZslgGN.js";import"./index-4eY77cms.js";import"./JSONSupport-DcrLLGjL.js";import"./writer-DKgfqj4X.js";import"./common-DQOJ18NT.js";import"./unitConversionUtils-rg07EgOm.js";import"./lengthUtils-_77UiyVF.js";function K(e,o){const m=e==null?void 0:e.geometry;if(!e||(m==null?void 0:m.type)!=="mesh"||!o)return;const{renderCoordsHelper:p,elevationProvider:x}=o,{camera:c}=o.state,{extent:r}=m,{center:h,spatialReference:t}=r,z=l(t),n=b(t),$=l(p.spatialReference),v=r.width*z,w=r.height*n,d=(r.zmax??0)*n,f=d-(r.zmin??0)*n,y=Math.max(v,w,f)/$,{x:s,y:a}=h,u=h.z??0;M(i,s,a,u),p.toRenderCoords(i,t,i);const g=y/c.computeScreenPixelSizeAt(i);if(g>c.width*H)return"meshTooClose";if(g<A)return"meshTooFar";const C=S(e),{absoluteZ:R}=T(s,a,d,t,o,C);return R<(x.getElevation(s,a,u,t,"ground")??0)*n+f*U?"meshUnderground":"mesh"}const A=20,H=1,U=.1,i=P();export{K as getDrawMeshHelpMessage};
