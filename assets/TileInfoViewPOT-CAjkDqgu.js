import{i as Y,b2 as j,V as X,E as Z,Z as B,aD as D}from"./Accessor-BmwT4B0c.js";import{P as J,E as z}from"./cast-CsZslgGN.js";import{p as Q}from"./workers-Cds_sd9m.js";import{I as V,E as b}from"./enums-BRzLM11V.js";import{t as x}from"./Rect-CUzevAry.js";import{G as tt,D as N,F as y}from"./enums-D9v74xTE.js";import{p as G,w as K}from"./Texture-BVJ22uHh.js";import{a as et}from"./pbf-BsmI3A9L.js";import{u as st}from"./rasterizingUtils-C1EbvluX.js";import{e as S}from"./TileKey-DBTeo_j0.js";import{o as it,M as rt,h as at,f as nt}from"./mat3-CR8GKnhD.js";import{e as C}from"./DefaultUI-BwWVKFUS.js";import{i as W}from"./memoryEstimations-Bcyf-mHz.js";import{h as ht}from"./TileStrategy-CtmYSAoK.js";import{c as ot}from"./RenderableTile-FJVLrFon.js";import{E as m,o as A}from"./BufferObject-BJilD_hc.js";import{e as F}from"./config-BOD8--da.js";import{r as lt}from"./DefaultVertexAttributeLayouts-wSIZdMhB.js";import{z as ct}from"./TileInfo-DxwC9WcY.js";class P{constructor(t,s){this._width=0,this._height=0,this._free=[],this._width=t,this._height=s,this._free.push(new x(0,0,t,s))}get width(){return this._width}get height(){return this._height}allocate(t,s){if(t>this._width||s>this._height)return new x;let e=null,i=-1;for(let r=0;r<this._free.length;++r){const a=this._free[r];t<=a.width&&s<=a.height&&(e===null||a.y<=e.y&&a.x<=e.x)&&(e=a,i=r)}return e===null?new x:(this._free.splice(i,1),e.width<e.height?(e.width>t&&this._free.push(new x(e.x+t,e.y,e.width-t,s)),e.height>s&&this._free.push(new x(e.x,e.y+s,e.width,e.height-s))):(e.width>t&&this._free.push(new x(e.x+t,e.y,e.width-t,e.height)),e.height>s&&this._free.push(new x(e.x,e.y+s,t,e.height-s))),new x(e.x,e.y,t,s))}release(t){for(let s=0;s<this._free.length;++s){const e=this._free[s];if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)e.width+=t.width;else if(e.x===t.x&&e.width===t.width&&e.y+e.height===t.y)e.height+=t.height;else if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)e.x=t.x,e.width+=t.width;else{if(t.x!==e.x||t.width!==e.width||t.y+t.height!==e.y)continue;e.y=t.y,e.height+=t.height}this._free.splice(s,1),this.release(t)}this._free.push(t)}}let $=class{constructor(t,s,e){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=s,this._glyphSource=e,this._binPack=new P(t-4,s-4),this._glyphData.push(new Uint8Array(t*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(t,s){const e=[],i=this._glyphSource,r=new Set,a=1/256;for(const o of s){const h=Math.floor(o*a);r.add(h)}const n=[];return r.forEach(o=>{const h=t+o;if(this._rangePromises.has(h))n.push(this._rangePromises.get(h));else{const l=i.getRange(t,o).then(()=>{this._rangePromises.delete(h)},()=>{this._rangePromises.delete(h)});this._rangePromises.set(h,l),n.push(l)}}),Promise.all(n).then(()=>{let o=this._glyphIndex[t];o||(o={},this._glyphIndex[t]=o);for(const h of s){const l=o[h];if(l){e[h]={sdf:!0,rect:l.rect,metrics:l.metrics,page:l.page,code:h};continue}const g=i.getGlyph(t,h);if(!(g!=null&&g.metrics))continue;const f=g.metrics;let u;if(f.width===0)u=new x(0,0,0,0);else{const c=f.width+6,d=f.height+2*3;let w=c%4?4-c%4:4,I=d%4?4-d%4:4;w===1&&(w=5),I===1&&(I=5),u=this._binPack.allocate(c+w,d+I),u.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new P(this.width-4,this.height-4),u=this._binPack.allocate(c+w,d+I));const M=this._glyphData[this._currentPage],k=g.bitmap;let U,E;if(k)for(let v=0;v<d;v++){U=c*v,E=this.width*(u.y+v+1)+u.x;for(let L=0;L<c;L++)M[E+L+1]=k.at(U+L)}}o[h]={rect:u,metrics:f,tileIDs:null,page:this._currentPage},e[h]={sdf:!0,rect:u,metrics:f,page:this._currentPage,code:h},this._dirties[this._currentPage]=!0}return e})}removeGlyphs(t){for(const s in this._glyphIndex){const e=this._glyphIndex[s];if(!e)continue;let i;for(const r in e)if(i=e[r],i.tileIDs.delete(t),i.tileIDs.size===0){const a=this._glyphData[i.page],n=i.rect;let o,h;for(let l=0;l<n.height;l++)for(o=this.width*(n.y+l)+n.x,h=0;h<n.width;h++)a[o+h]=0;delete e[r],this._dirties[i.page]=!0}}}bind(t,s,e,i=0){if(!this._textures[e]){const a=new G;a.pixelFormat=tt.ALPHA,a.wrapMode=N.CLAMP_TO_EDGE,a.width=this.width,a.height=this.height,this._textures[e]=new K(t,a,new Uint8Array(this.width*this.height))}const r=this._textures[e];r.setSamplingMode(s),this._dirties[e]&&r.setData(this._glyphData[e]),t.bindTexture(r,i),this._dirties[e]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0}};class T{constructor(t){if(this._metrics=[],!t)return void(this._allBitmaps=null);const s=new Map;let e=0;for(;t.next();)switch(t.tag()){case 1:{const a=t.getMessage();for(;a.next();)switch(a.tag()){case 3:{const n=a.getMessage();let o,h,l,g,f,u,p;for(;n.next();)switch(n.tag()){case 1:o=n.getUInt32();break;case 2:h=n.getBytes();break;case 3:l=n.getUInt32();break;case 4:g=n.getUInt32();break;case 5:f=n.getSInt32();break;case 6:u=n.getSInt32();break;case 7:p=n.getUInt32();break;default:n.skip()}if(n.release(),o){const c=(h==null?void 0:h.length)??0;this._metrics[o]={width:l,height:g,left:f,top:u,advance:p,startOffset:e,length:c},s.set(o,h),e+=c}break}default:a.skip()}a.release();break}default:t.skip()}const i=new Uint8Array(e),r=this._metrics;for(const[a,n]of s){const{startOffset:o,length:h}=r[a];if(n)for(let l=0;l<h;++l)i[o+l]=n[l]}this._allBitmaps=i}getMetrics(t){return this._metrics[t]}getBitmap(t){if(!this._allBitmaps)return;const s=this._metrics[t];if(s===void 0)return;const{startOffset:e,length:i}=s;return i!==0?new ft(this._allBitmaps,e,i):void 0}}class ut{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(t){return this._ranges[t]}addRange(t,s){this._ranges[t]=s}}let H=class{constructor(t){this._glyphInfo={},this._baseURL=t}getRange(t,s){const e=this._getFontStack(t);if(e.getRange(s))return Promise.resolve();const i=256*s,r=i+255;if(this._baseURL){const a=this._baseURL.replace("{fontstack}",t).replace("{range}",i+"-"+r);return J(a,{responseType:"array-buffer"}).then(n=>{e.addRange(s,new T(new et(new Uint8Array(n.data),new DataView(n.data))))}).catch(()=>{e.addRange(s,new T)})}return e.addRange(s,new T),Promise.resolve()}getGlyph(t,s){const e=this._getFontStack(t);if(!e)return;const i=Math.floor(s/256),r=e.getRange(i);return r?{metrics:r.getMetrics(s),bitmap:r.getBitmap(s)}:void 0}_getFontStack(t){let s=this._glyphInfo[t];return s||(s=this._glyphInfo[t]=new ut),s}};class ft{constructor(t,s,e){this._array=t,this._start=s,this.length=e}at(t){return 0<=t&&t<this.length?this._array[this._start+t]:void 0}}const pt="dasharray-";class R{constructor(t,s,e=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,s<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=t,this._pageHeight=s,e>0&&(this._maxItemSize=e),this._binPack=new P(t-4,s-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const t of this._textures)t&&t.dispose();this._textures.length=0}getWidth(t){return t>=this._size.length?-1:this._size[t][0]}getHeight(t){return t>=this._size.length?-1:this._size[t][1]}getPageSize(t){return t>=this._size.length?null:this._size[t]}setSpriteSource(t){if(this.dispose(),this.pixelRatio=t.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new P(this._pageWidth-4,this._pageHeight-4);const s=Math.floor(this._pageWidth),e=Math.floor(this._pageHeight),i=new Uint32Array(s*e);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=t}getSpriteItem(t,s=!1){let e,i,r=this._mosaicRects[t];if(r)return r;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(t&&t.startsWith(pt)?([e,i]=this._rasterizeDash(t),s=!0):e=this._sprites.getSpriteInfo(t),!(e!=null&&e.width)||!e.height||e.width<0||e.height<0))return null;const a=e.width,n=e.height,[o,h,l]=this._allocateImage(a,n);return o.width<=0?null:(this._copy(o,e,h,l,s,i),r={type:"sprite",rect:o,width:a,height:n,sdf:e.sdf,simplePattern:!1,rasterizationScale:e.pixelRatio??1,samplingMode:"Linear",page:h},this._mosaicRects[t]=r,r)}getSpriteItems(t){const s={};for(const e of t)s[e.name]=this.getSpriteItem(e.name,e.repeat);return s}getMosaicItemPosition(t,s){const e=this.getSpriteItem(t,s),i=e==null?void 0:e.rect;if(!i)return null;i.width=e.width,i.height=e.height;const r=e.width,a=e.height,n=2;return{tl:[i.x+n,i.y+n],br:[i.x+n+r,i.y+n+a],page:e.page}}bind(t,s,e=0,i=0){if(e>=this._size.length||e>=this._mosaicsData.length)return;if(!this._textures[e]){const a=new G;a.wrapMode=N.CLAMP_TO_EDGE,a.width=this._size[e][0],a.height=this._size[e][1],this._textures[e]=new K(t,a,new Uint8Array(this._mosaicsData[e].buffer))}const r=this._textures[e];r.setSamplingMode(s),this._dirties[e]&&r.setData(new Uint8Array(this._mosaicsData[e].buffer)),t.bindTexture(r,i),this._dirties[e]=!1}static _copyBits(t,s,e,i,r,a,n,o,h,l,g){let f=i*s+e,u=o*a+n;if(g){u-=a;for(let p=-1;p<=l;p++,f=((p+l)%l+i)*s+e,u+=a)for(let c=-1;c<=h;c++)r[u+c]=t[f+(c+h)%h]}else for(let p=0;p<l;p++){for(let c=0;c<h;c++)r[u+c]=t[f+c];f+=s,u+=a}}_copy(t,s,e,i,r,a){if(!this._sprites||this._sprites.loadStatus!=="loaded"||e>=this._mosaicsData.length)return;const n=new Uint32Array(a?a.buffer:this._sprites.image.buffer),o=this._mosaicsData[e],h=2,l=a?s.width:this._sprites.width;R._copyBits(n,l,s.x,s.y,o,i[0],t.x+h,t.y+h,s.width,s.height,r),this._dirties[e]=!0}_allocateImage(t,s){t+=2,s+=2;const e=Math.max(t,s);if(this._maxItemSize&&this._maxItemSize<e){const n=new x(0,0,t,s);return this._mosaicsData.push(new Uint32Array(t*s)),this._dirties.push(!0),this._size.push([t,s]),this._textures.push(void 0),[n,this._mosaicsData.length-1,[t,s]]}let i=t%4?4-t%4:4,r=s%4?4-s%4:4;i===1&&(i=5),r===1&&(r=5);const a=this._binPack.allocate(t+i,s+r);return a.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new P(this._pageWidth-4,this._pageHeight-4),this._allocateImage(t,s)):[a,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(t){const s=/\[(.*?)\]/,e=t.match(s);if(!e)return null;const i=e[1].split(",").map(Number),r=t.slice(t.lastIndexOf("-")+1),[a,n,o]=st(i,r);return[{x:0,y:0,width:n,height:o,sdf:!0,pixelRatio:1},new Uint8Array(a.buffer)]}}class Wt{constructor(t,s,e,i){this._layer=t,this._styleRepository=s,this.devicePixelRatio=e,this._sourceDataMaxLOD=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){var t,s,e;(t=this._connection)==null||t.close(),this._connection=null,this._styleRepository=null,this._layer=null,(s=this._spriteMosaic)==null||s.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=Y(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&((e=this._startOptionsInputSignal)==null||e.removeEventListener("abort",this._inputSignalEventListener)),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(t){this._requestSprite(t);const s=this._layer.currentStyleInfo.glyphsUrl,e=new H(s?z(s,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new $(1024,1024,e),this._broadcastPromise=Q("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then(i=>{var r;if(this._layer&&((r=this._connection)==null||r.close(),this._connection=i,this._layer&&!this._connection.closed)){const a=i.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},t);Promise.all(a).catch(n=>j(n))}})}_requestSprite(t){var a,n;(a=this._spriteSourceAbortController)==null||a.abort();const s=new AbortController;this._spriteSourceAbortController=s;const e=t==null?void 0:t.signal;this._inputSignalEventListener&&((n=this._startOptionsInputSignal)==null||n.removeEventListener("abort",this._inputSignalEventListener)),this._startOptionsInputSignal=null,e&&(this._inputSignalEventListener=dt(s),e.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:i}=s,r={...t,signal:i};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,r),this._spriteSourcePromise.then(o=>{X(i),this._spriteMosaic=new R(1024,1024,250),this._spriteMosaic.setSpriteSource(o)})}async updateStyle(t){const s=[];for(const e of t)e.type===V.SPRITES_CHANGED?s.push({type:V.SPRITES_CHANGED,data:{spriteSource:null}}):s.push(e);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",s)),this._broadcastPromise}setSpriteSource(t){const s=new R(1024,1024,250);return s.setSpriteSource(t),this._spriteMosaic=s,this._spriteSourcePromise=Promise.resolve(t),this._spriteSourceAbortController=null,s}async setStyle(t,s,e){await this._broadcastPromise,this._styleRepository=t,this._sourceDataMaxLOD=e,this._requestSprite();const i=new H(this._layer.currentStyleInfo.glyphsUrl?z(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new $(1024,1024,i),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:s,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(t,s){const e=await this._getRefKeys(t,s);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),e,s)}async fetchTilePBFs(t){const s=Object.keys(this._layer.sourceNameToSource),e={},i=await this._getRefKeys(t,e),r=[],a=[];for(let n=0;n<i.length;n++)if(i[n].value==null||s[n]==null)a.push(null);else{const o=i[n].value,h=this._getTilePayload(o,s[n],e);h.then(l=>{r.push({...l,key:o})}),a.push(h)}return Promise.all(a).then(()=>r)}async parseTileData(t,s){const e=t&&t.data;if(!e)return null;const{sourceName2DataAndRefKey:i,transferList:r}=e;return Object.keys(i).length===0?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:i,styleLayerUIDs:t.styleLayerUIDs},{...s,transferList:r}))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}async _getTilePayload(t,s,e){const i=S.pool.acquire(t.id),r=this._layer.sourceNameToSource[s],{level:a,row:n,col:o}=i;S.pool.release(i);try{return{protobuff:await r.requestTile(a,n,o,e),sourceName:s}}catch(h){if(Z(h))throw h;return{protobuff:null,sourceName:s}}}async _getRefKeys(t,s){const e=this._layer.sourceNameToSource,i=new Array;for(const r in e){const a=e[r].getRefKey(t,s);i.push(a)}return B(i)}_getSourcesData(t,s,e){const i=[];for(let r=0;r<s.length;r++)if(s[r].value==null||t[r]==null)i.push(null);else{const a=s[r].value,n=this._getTilePayload(a,t[r],e);i.push(n)}return B(i).then(r=>{const a={},n=[];for(let o=0;o<r.length;o++){const h=r[o].value;if(h&&h.protobuff&&h.protobuff.byteLength>0){const l=s[o].value.id;a[h.sourceName]={refKey:l,protobuff:h.protobuff},n.push(h.protobuff)}}return{sourceName2DataAndRefKey:a,transferList:n}})}}function dt(_){return()=>_.abort()}class O{constructor(t,s){this.layerUIDs=[],this.isDestroyed=!1,this._data=t;let e=1;const i=new Uint32Array(t);this.layerUIDs=[];const r=i[e++];for(let a=0;a<r;a++)this.layerUIDs[a]=i[e++];this.bufferDataOffset=e,s&&(this.layer=s.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return this._data==null}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(t){this._data!=null&&(this.doPrepareForRendering(t,this._data,this.bufferDataOffset),this._data=null)}}class gt extends O{constructor(t,s){super(t,s),this.type=b.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const e=new Uint32Array(t);let i=this.bufferDataOffset;this.lineIndexStart=e[i++],this.lineIndexCount=e[i++];const r=e[i++];if(r>0){this.patternMap=new Map;for(let a=0;a<r;a++){const n=e[i++],o=e[i++],h=e[i++];this.patternMap.set(n,[o,h])}}this.bufferDataOffset=i}get usedMemory(){var t,s;return(((t=this.data)==null?void 0:t.byteLength)??0)+(((s=this.vao)==null?void 0:s.cachedMemory)??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=D(this.vao)}doPrepareForRendering(t,s,e){const i=new Uint32Array(s),r=new Int32Array(i.buffer),a=i[e++],n=m.createVertex(t,y.STATIC_DRAW,new Int32Array(r.buffer,4*e,a));e+=a;const o=i[e++],h=m.createIndex(t,y.STATIC_DRAW,new Uint32Array(i.buffer,4*e,o));e+=o;const l=this.layer.lineMaterial;this.vao=new A(t,l.getAttributeLocations(),l.getLayoutInfo(),new Map([["geometry",n]]),h)}}class _t extends O{constructor(t,s){super(t,s),this.type=b.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const e=new Uint32Array(t);let i=this.bufferDataOffset;this.fillIndexStart=e[i++],this.fillIndexCount=e[i++],this.outlineIndexStart=e[i++],this.outlineIndexCount=e[i++];const r=e[i++];if(r>0){this.patternMap=new Map;for(let a=0;a<r;a++){const n=e[i++],o=e[i++],h=e[i++];this.patternMap.set(n,[o,h])}}this.bufferDataOffset=i}get usedMemory(){var t,s,e;return(((t=this.data)==null?void 0:t.byteLength)??0)+(((s=this.fillVAO)==null?void 0:s.cachedMemory)??0)+(((e=this.outlineVAO)==null?void 0:e.cachedMemory)??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=D(this.fillVAO),this.outlineVAO=D(this.outlineVAO)}doPrepareForRendering(t,s,e){const i=new Uint32Array(s),r=new Int32Array(i.buffer),a=i[e++],n=m.createVertex(t,y.STATIC_DRAW,new Int32Array(r.buffer,4*e,a));e+=a;const o=i[e++],h=m.createIndex(t,y.STATIC_DRAW,new Uint32Array(i.buffer,4*e,o));e+=o;const l=i[e++],g=m.createVertex(t,y.STATIC_DRAW,new Int32Array(r.buffer,4*e,l));e+=l;const f=i[e++],u=m.createIndex(t,y.STATIC_DRAW,new Uint32Array(i.buffer,4*e,f));e+=f;const p=this.layer,c=p.fillMaterial,d=p.outlineMaterial;this.fillVAO=new A(t,c.getAttributeLocations(),c.getLayoutInfo(),new Map([["geometry",n]]),h),this.outlineVAO=new A(t,d.getAttributeLocations(),d.getLayoutInfo(),new Map([["geometry",g]]),u)}}class yt extends O{constructor(t,s,e){super(t,s),this.type=b.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const i=new Uint32Array(t),r=new Int32Array(t),a=new Float32Array(t);let n=this.bufferDataOffset;this.isIconSDF=!!i[n++];const o=i[n++],h=i[n++],l=i[n++],g=new S(o,h,l,0),f=i[n++];for(let d=0;d<f;d++){const w=i[n++],I=i[n++],M=i[n++];this.iconPerPageElementsMap.set(w,[I,M])}const u=i[n++];for(let d=0;d<u;d++){const w=i[n++],I=i[n++],M=i[n++];this.glyphPerPageElementsMap.set(w,[I,M])}const p=i[n++],c=i[n++];this.iconOpacity=new Int32Array(p),this.textOpacity=new Int32Array(c),n=ot(i,r,a,n,this.symbols,e,g),this.bufferDataOffset=n}get usedMemory(){var t,s,e;return(((t=this.data)==null?void 0:t.byteLength)??0)+(((s=this.iconVAO)==null?void 0:s.cachedMemory)??0)+(((e=this.textVAO)==null?void 0:e.cachedMemory)??0)+W(this.iconOpacity)+W(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let t=0;for(const s of this.iconPerPageElementsMap.values())t+=s[1];for(const s of this.glyphPerPageElementsMap.values())t+=s[1];return t/3}doDestroy(){this.iconVAO=D(this.iconVAO),this.textVAO=D(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const t=this.iconOpacity,s=this.iconVAO.vertexBuffers.get("opacity");t.length>0&&t.byteLength===s.usedMemory&&s.setSubData(t,0,0,t.length);const e=this.textOpacity,i=this.textVAO.vertexBuffers.get("opacity");e.length>0&&e.byteLength===i.usedMemory&&i.setSubData(e,0,0,e.length)}doPrepareForRendering(t,s,e){const i=new Uint32Array(s),r=new Int32Array(i.buffer),a=i[e++],n=m.createVertex(t,y.STATIC_DRAW,new Int32Array(r.buffer,4*e,a));e+=a;const o=i[e++],h=m.createIndex(t,y.STATIC_DRAW,new Uint32Array(i.buffer,4*e,o));e+=o;const l=i[e++],g=m.createVertex(t,y.STATIC_DRAW,new Int32Array(r.buffer,4*e,l));e+=l;const f=i[e++],u=m.createIndex(t,y.STATIC_DRAW,new Uint32Array(i.buffer,4*e,f));e+=f;const p=m.createVertex(t,y.STATIC_DRAW,this.iconOpacity.buffer),c=m.createVertex(t,y.STATIC_DRAW,this.textOpacity.buffer),d=this.layer,w=d.iconMaterial,I=d.textMaterial;this.iconVAO=new A(t,w.getAttributeLocations(),w.getLayoutInfo(),new Map([["geometry",n],["opacity",p]]),h),this.textVAO=new A(t,I.getAttributeLocations(),I.getLayoutInfo(),new Map([["geometry",g],["opacity",c]]),u)}}class mt extends O{constructor(t,s){super(t,s),this.type=b.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const e=new Uint32Array(t);let i=this.bufferDataOffset;this.circleIndexStart=e[i++],this.circleIndexCount=e[i++],this.bufferDataOffset=i}get usedMemory(){var t,s;return(((t=this.data)==null?void 0:t.byteLength)??0)+(((s=this.vao)==null?void 0:s.cachedMemory)??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=D(this.vao)}doPrepareForRendering(t,s,e){const i=new Uint32Array(s),r=new Int32Array(i.buffer),a=i[e++],n=m.createVertex(t,y.STATIC_DRAW,new Int32Array(r.buffer,4*e,a));e+=a;const o=i[e++],h=m.createIndex(t,y.STATIC_DRAW,new Uint32Array(i.buffer,4*e,o));e+=o;const l=this.layer.circleMaterial;this.vao=new A(t,l.getAttributeLocations(),l.getLayoutInfo(),new Map([["geometry",n]]),h)}}class q extends lt{constructor(t,s,e,i,r,a,n,o=null){super(t,s,e,i,r,a,4096,4096),this.styleRepository=n,this._memCache=o,this.type="vector-tile",this._referenced=1,this._hasSymbolBuckets=!1,this._usedMemory=256,this.layerData=new Map,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.parentTile=null,this.childrenTiles=new Set,this.featureIndex=null,this.triangleCount=0,this._processed=!1,this.id=t.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<F}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<F)}get wasRequested(){return this.status==="errored"||this.status==="loaded"||this.status==="reloading"}setData(t){this.changeDataImpl(t),this.requestRender(),this.ready(),this._processed=!0}deleteLayerData(t){var e,i;let s=!1;for(const r of t){const a=this.layerData.get(r);a&&(this._usedMemory-=a.usedMemory,a.type===b.SYMBOL&&this.symbols.delete(r)&&(s=!0),a.destroy(),this.layerData.delete(r))}(e=this._memCache)==null||e.updateSize(this.key.id,this),s&&((i=this.featureIndex)==null||i.clear(),this.emit("symbols-changed")),this.requestRender()}processed(){return this._processed}hasData(){return this.layerData.size>0}hasFeatures(){const t=this.layerData.values();for(const s of t)if(s.hasData())return!0;return!1}dispose(){this.status!=="unloaded"&&(q._destroyRenderBuckets(this.layerData),this.layerData.clear(),this.featureIndex=null,this._usedMemory=0,this.destroy(),this.status="unloaded")}release(){--this._referenced==0&&(this.dispose(),this.stage=null)}retain(){++this._referenced}get cachedMemory(){return this._usedMemory}get usedMemory(){return this._usedMemory}get usedMemoryPerReference(){return this._usedMemory/(this._referenced||1)}changeDataImpl(t){var e,i;(e=this.featureIndex)==null||e.clear();let s=!1;if(t){const{bucketsWithData:r,emptyBuckets:a}=t,n=this._createRenderBuckets(r);if(a&&a.byteLength>0){const o=new Uint32Array(a);for(const h of o)this._deleteLayerData(h)}for(const[o,h]of n)this._deleteLayerData(o),h.type===b.SYMBOL&&(this.symbols.set(o,h.symbols),s=!0),this._usedMemory+=h.usedMemory,this.layerData.set(o,h);(i=this._memCache)==null||i.updateSize(this.key.id,this)}this._hasSymbolBuckets=!1;for(const r of this.layerData.values())r.type===b.SYMBOL&&(this._hasSymbolBuckets=!0);s&&this.emit("symbols-changed")}attachWithContext(t){this.stage={context:t,trashDisplayObject(s){s.processDetach()},untrashDisplayObject:()=>!1}}setTransform(t){super.setTransform(t);const s=this.resolution/(t.resolution*t.pixelRatio),e=this.width/this.rangeX*s,i=this.height/this.rangeY*s,r=[0,0];t.toScreen(r,[this.x,this.y]);const a=this.transforms.tileUnitsToPixels;it(a),rt(a,a,r),at(a,a,Math.PI*t.rotation/180),nt(a,a,[e,i,1])}_createTransforms(){return{displayViewScreenMat3:C(),tileMat3:C(),tileUnitsToPixels:C()}}static _destroyRenderBuckets(t){if(!t)return;const s=new Set;for(const e of t.values())s.has(e)||(e.destroy(),s.add(e));t.clear()}_createRenderBuckets(t){const s=new Map,e=new Map;for(const i of t){const r=this._deserializeBucket(i,e);for(const a of r.layerUIDs)s.set(a,r)}return s}_deserializeBucket(t,s){let e=s.get(t);if(e)return e;switch(new Uint32Array(t)[0]){case b.FILL:e=new _t(t,this.styleRepository);break;case b.LINE:e=new gt(t,this.styleRepository);break;case b.SYMBOL:e=new yt(t,this.styleRepository,this);break;case b.CIRCLE:e=new mt(t,this.styleRepository)}return s.set(t,e),e}_deleteLayerData(t){if(!this.layerData.has(t))return;const s=this.layerData.get(t);this._usedMemory-=s.usedMemory,s.destroy(),this.layerData.delete(t)}}class Ft extends ht{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(t){const s=S.pool.acquire(t),e=s.level===0?null:S.getId(s.level-1,s.row>>1,s.col>>1,s.world);return S.pool.release(s),e}getTileCoverage(t,s,e=!0,i){const r=super.getTileCoverage(t,s,e,i);if(!r)return r;const a=1<<r.lodInfo.level;return r.spans=r.spans.filter(n=>n.row>=0&&n.row<a),r}scaleToLevel(t){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[t])return this._levelByScale[t];{const s=this._fullCacheLodInfos;if(t>s[0].scale)return s[0].level;let e,i;for(let r=0;r<s.length-1;r++)if(i=s[r+1],t>i.scale)return e=s[r],e.level+(e.scale-t)/(e.scale-i.scale);return s[s.length-1].level}}_initializeFullCacheLODs(t){let s;if(t[0].level===0)s=t.map(e=>({level:e.level,resolution:e.resolution,scale:e.scale}));else{const e=this.tileInfo.size[0],i=this.tileInfo.spatialReference;s=ct.create({size:e,spatialReference:i}).lods.map(r=>({level:r.level,resolution:r.resolution,scale:r.scale}))}for(let e=0;e<s.length;e++)this._levelByScale[s[e].scale]=s[e].level;this._fullCacheLodInfos=s}}export{Wt as p,Ft as t,q as y};
