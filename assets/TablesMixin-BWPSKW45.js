import{l as c}from"./CollectionFlattener-CkyePFnC.js";import{e as d}from"./Evented-CXIxDjmW.js";import{V as p}from"./reactiveUtils-BFQ0BtrB.js";import{n as f}from"./collectionUtils-Dm1icNvk.js";import{y as u,b as m,n as l}from"./subclass-BR3PhgZG.js";import{h as b}from"./Accessor-D6mNnsWy.js";import{f as g}from"./Layer-CfUiPX3n.js";function B(i){return new c({getCollections:()=>[i.tables,i.layers],getChildrenFunction:r=>{const a=[];return"tables"in r&&a.push(r.tables),"layers"in r&&a.push(r.layers),a},itemFilterFunction:r=>{const a=r.parent;return!!a&&"tables"in a&&a.tables.includes(r)}})}function I(i){for(const r of i.values())r==null||r.destroy();i.clear()}function y(i,r,a){let e,t;if(i)for(let o=0,n=i.length;o<n;o++){if(e=i.at(o),(e==null?void 0:e[r])===a)return e;if((e==null?void 0:e.type)==="group"&&(t=y(e.layers,r,a),t))return t}}const T=i=>{let r=class extends i{constructor(...e){super(...e),this.layers=new p;const t=s=>{s.parent&&"remove"in s.parent&&s.parent.remove(s)},o=s=>{s.parent=this,this.layerAdded(s),s.type!=="elevation"&&s.type!=="base-elevation"||l.getLogger(this).error(`Layer 'title:${s.title}, id:${s.id}' of type '${s.type}' is not supported as an operational layer and will therefore be ignored.`)},n=s=>{s.parent=null,this.layerRemoved(s)};this.addHandles([this.layers.on("before-add",s=>{if(s.item===this)return s.preventDefault(),void l.getLogger(this).error("#add()","Cannot add layer to itself.");t(s.item)}),this.layers.on("after-add",s=>o(s.item)),this.layers.on("after-remove",s=>n(s.item))])}destroy(){const e=this.layers.toArray();for(const t of e)t.destroy();this.layers.destroy()}set layers(e){this._set("layers",f(e,this._get("layers")))}add(e,t){const o=this.layers;if(t=o.getNextIndex(t),e instanceof g){const n=e;n.parent===this?this.reorder(n,t):o.add(n,t)}else b(e)?e.then(n=>{this.destroyed||this.add(n,t)}):l.getLogger(this).error("#add()","The item being added is not a Layer or a Promise that resolves to a Layer.")}addMany(e,t){const o=this.layers;let n=o.getNextIndex(t);e.slice().forEach(s=>{s.parent!==this?(o.add(s,n),n+=1):this.reorder(s,n)})}findLayerById(e){return y(this.layers,"id",e)}findLayerByUid(e){return y(this.layers,"uid",e)}remove(e){return this.layers.remove(e)}removeMany(e){return this.layers.removeMany(e)}removeAll(){return this.layers.removeAll()}reorder(e,t){return this.layers.reorder(e,t)}layerAdded(e){}layerRemoved(e){}};return d([u()],r.prototype,"layers",null),r=d([m("esri.support.LayersMixin")],r),r};function h(i,r,a){if(i)for(let e=0,t=i.length;e<t;e++){const o=i.at(e);if(o[r]===a)return o;if((o==null?void 0:o.type)==="group"){const n=h(o.tables,r,a);if(n)return n}}}const C=i=>{let r=class extends i{constructor(...a){super(...a),this.tables=new p,this.addHandles([this.tables.on("after-add",e=>{const t=e.item;t.parent&&t.parent!==this&&"tables"in t.parent&&t.parent.tables.remove(t),t.parent=this,t.type!=="feature"&&l.getLogger(this).error(`Layer 'title:${t.title}, id:${t.id}' of type '${t.type}' is not supported as a table and will therefore be ignored.`)}),this.tables.on("after-remove",e=>{e.item.parent=null})])}destroy(){const a=this.tables.toArray();for(const e of a)e.destroy();this.tables.destroy()}set tables(a){this._set("tables",f(a,this._get("tables")))}findTableById(a){return h(this.tables,"id",a)}findTableByUid(a){return h(this.tables,"uid",a)}};return d([u()],r.prototype,"tables",null),r=d([m("esri.support.TablesMixin")],r),r};export{I as a,T as l,C as n,B as t};
