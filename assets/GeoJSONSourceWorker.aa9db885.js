var e=Object.defineProperty,t=Object.defineProperties,i=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable,a=(t,i,s)=>i in t?e(t,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[i]=s,o=(e,t)=>{for(var i in t||(t={}))n.call(t,i)&&a(e,i,t[i]);if(s)for(var i of s(t))r.call(t,i)&&a(e,i,t[i]);return e};import{L as l,dB as d,w as u,fa as p,fb as y,cd as c,bs as f,r as m,bH as h,c6 as g,aM as b,c3 as I,c5 as F,fc as j}from"./vendor.d0a39f0f.js";import{m as _}from"./FeatureStore.2b302d70.js";import{g as E,f as T}from"./quantizationUtils.2d4b616a.js";import{H as q}from"./QueryEngine.c9f49fa3.js";import{I as x,T as w,k as O}from"./geojson.aa9ea6ad.js";import{u as D,i as R,n as S}from"./clientSideDefaults.67fdee82.js";import{y as Q,d as v,c as P,u as k,h as C}from"./sourceUtils.f4154c33.js";import"./PooledRBush.4b631a20.js";import"./centroid.1404a86d.js";import"./json.62026198.js";import"./WhereClause.1eaac7f4.js";import"./QueryEngineCapabilities.47963c2d.js";import"./utils.f10afb6d.js";import"./spatialQuerySupport.2755696c.js";const Z={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};class A{constructor(){this._queryEngine=null}destroy(){this._queryEngine&&this._queryEngine&&this._queryEngine.destroy(),this._queryEngine=this._requiredFields=this._fieldsIndex=this._createDefaultAttributes=null}async load(e){const s=[];await this._checkProjection(e.spatialReference);let n=null;e.url&&(n=(await l(e.url,{responseType:"json"})).data,await x(n));const r=w(n,{geometryType:e.geometryType}),a=e.fields||r.fields||[],b=null!=e.hasZ?e.hasZ:r.hasZ,I=r.geometryType,F=e.objectIdField||("number"===r.objectIdFieldType?r.objectIdFieldName:"OBJECTID")||"OBJECTID",j=e.spatialReference||d;let T=e.timeInfo;if("string"===r.objectIdFieldType&&s.push({name:"geojson-layer:unsupported-id-type",message:"Feature ids are of type string and can't be honored."}),a===r.fields&&r.unknownFields.length>0&&s.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:r.unknownFields}}),F){let e=null;a.some((t=>t.name===F&&(e=t,!0)))?(e.type="esriFieldTypeOID",e.editable=!1,e.nullable=!1):a.unshift({alias:F,name:F,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const t of a){if(null==t.name&&(t.name=t.alias),null==t.alias&&(t.alias=t.name),!t.name)throw new u("geojson-layer:invalid-field-name","field name is missing",{field:t});if(t.name===F&&(t.type="esriFieldTypeOID"),-1===p.jsonValues.indexOf(t.type))throw new u("geojson-layer:invalid-field-type",`invalid type for field "${t.name}"`,{field:t})}const Q={};this._requiredFields=[];for(const t of a)if("esriFieldTypeOID"!==t.type&&"esriFieldTypeGlobalID"!==t.type){t.editable=null==t.editable||!!t.editable,t.nullable=null==t.nullable||!!t.nullable;const e=y(t);t.nullable||void 0!==e?Q[t.name]=e:this._requiredFields.push(t)}if(this._fieldsIndex=new c(a),T){if(T.startTimeField){const e=this._fieldsIndex.get(T.startTimeField);e?(T.startTimeField=e.name,e.type="esriFieldTypeDate"):T.startTimeField=null}if(T.endTimeField){const e=this._fieldsIndex.get(T.endTimeField);e?(T.endTimeField=e.name,e.type="esriFieldTypeDate"):T.endTimeField=null}if(T.trackIdField){const e=this._fieldsIndex.get(T.trackIdField);e?T.trackIdField=e.name:(T.trackIdField=null,s.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:T}}))}T.startTimeField||T.endTimeField||(s.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:T}}),T=null)}const v=I?D(I):null,P={warnings:s,featureErrors:[],layerDefinition:(k=o({},Z),C={drawingInfo:v,templates:R(Q),extent:null,geometryType:I,objectIdField:F,fields:a,hasZ:!!b,timeInfo:T},t(k,i(C)))};var k,C;this._queryEngine=new q({fields:a,geometryType:I,hasM:!1,hasZ:b,objectIdField:F,spatialReference:j,timeInfo:T,featureStore:new _({geometryType:I,hasM:!1,hasZ:b}),cacheSpatialQueries:!0}),this._createDefaultAttributes=S(Q,F),this._nextObjectId=r.maxObjectId+1;const A=O(n,{geometryType:I,hasZ:b,objectIdField:"number"===r.objectIdFieldType?F:null});if(!f(j,d))for(const t of A)m(t.geometry)&&(t.geometry=h(E(g(t.geometry,I,b,!1),d,j)));return this._loadInitialFeatures(P,A),P}async applyEdits(e){const{spatialReference:t,geometryType:i}=this._queryEngine;return await Promise.all([Q(t,i),T(e.adds,t),T(e.updates,t)]),this._applyEdits(e)}queryFeatures(e={},t={}){return this._queryEngine.executeQuery(e,t.signal)}queryFeatureCount(e={},t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}queryObjectIds(e={},t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}queryExtent(e={},t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}querySnapping(e,t={}){return this._queryEngine.executeQueryForSnapping(e,t.signal)}_loadInitialFeatures(e,t){const{featureStore:i,objectIdField:s}=this._queryEngine,n=[];for(const r of t){const t=this._createDefaultAttributes(),i=v(this._fieldsIndex,t,r.attributes,this._requiredFields,!0,e.warnings);i?e.featureErrors.push(i):(this._assignObjectId(t,r.attributes,!0),r.attributes=t,r.objectId=t[s],n.push(r))}if(i.addMany(n),e.layerDefinition.extent=this._queryEngine.fullExtent,e.layerDefinition.timeInfo){const{start:t,end:i}=this._queryEngine.timeExtent;e.layerDefinition.timeInfo.timeExtent=[t,i]}return e}_applyEdits(e){const{adds:t,updates:i,deletes:s}=e,n={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t&&t.length&&this._applyAddEdits(n,t),i&&i.length&&this._applyUpdateEdits(n,i),s&&s.length){for(const e of s)n.deleteResults.push(P(e));this._queryEngine.featureStore.removeManyById(s)}return{fullExtent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent,featureEditResults:n}}_applyAddEdits(e,t){const{addResults:i}=e,{geometryType:s,hasM:n,hasZ:r,objectIdField:a,spatialReference:o,featureStore:l}=this._queryEngine,d=[];for(const u of t){if(u.geometry&&s!==b(u.geometry)){i.push(k("Incorrect geometry type."));continue}const t=this._createDefaultAttributes(),n=v(this._fieldsIndex,t,u.attributes,this._requiredFields);if(n)i.push(n);else{if(this._assignObjectId(t,u.attributes),u.attributes=t,null!=u.uid){const t=u.attributes[a];e.uidToObjectId[u.uid]=t}m(u.geometry)&&(u.geometry=E(C(u.geometry,o),u.geometry.spatialReference,o)),d.push(u),i.push(P(u.attributes[a]))}}l.addMany(I([],d,s,r,n,a))}_applyUpdateEdits({updateResults:e},t){const{geometryType:i,hasM:s,hasZ:n,objectIdField:r,spatialReference:a,featureStore:o}=this._queryEngine;for(const l of t){const{attributes:t,geometry:d}=l,u=t&&t[r];if(null==u){e.push(k(`Identifier field ${r} missing`));continue}if(!o.has(u)){e.push(k(`Feature with object id ${u} missing`));continue}const p=F(o.getFeature(u),i,n,s);if(m(d)){if(i!==b(d)){e.push(k("Incorrect geometry type."));continue}p.geometry=E(C(d,a),d.spatialReference,a)}if(t){const i=v(this._fieldsIndex,p.attributes,t,this._requiredFields);if(i){e.push(i);continue}}o.add(j(p,i,n,s,r)),e.push(P(u))}}_assignObjectId(e,t,i=!1){const s=this._queryEngine.objectIdField;i&&isFinite(t[s])?e[s]=t[s]:e[s]=this._nextObjectId++}async _checkProjection(e){try{await T(d,e)}catch{throw new u("geojson-layer","Projection not supported")}}}export{A as default};
