import{q as G,f as A,t as L,x as M}from"./Accessor-D6mNnsWy.js";import{d as N}from"./reactiveUtils-BFQ0BtrB.js";import{a as q}from"./dehydratedFeatureComparison-NNZuxUKF.js";import{x as D}from"./hydratedFeatures-DHwl8sGq.js";import{j}from"./elevationInfoUtils-C0SzfJu0.js";import{w as B}from"./InteractiveToolBase-BwczmwYA.js";import{e as J}from"./SnappingContext-lR2hMWGP.js";import{I as K,F as Q}from"./Scheduler-CDoWuxMK.js";function rn({predicate:n=()=>!0,snappingManager:t,snappingContext:o,updatingHandles:l,useZ:e=!0}){const i=new B;if(t==null)return{snappingStep:[z,i],cancelSnapping:z};let p,u=null,a=null,c=null;const f=()=>{u=G(u),t.doneSnapping(),a==null||a.frameTask.remove(),a=null,p=A(p),c=null},g=R(t,e,i);let d=null,s=null,Z=null;return{snappingStep:[r=>{if(!n(r))return r;const{action:P}=r;if(P==="start"){const{info:x}=r,S=V(t.view);if(a=W(o,r,S),a.context.selfSnappingZ=null,!e&&x!=null){const m=Y(o.coordinateHelper,x.handle.component);m!=null&&(a.context.selfSnappingZ={value:m,elevationInfo:o.elevationInfo??j})}}if(a!=null){const{context:x,originalScenePos:S,originalPos:m}=a,{mapEnd:T,mapStart:k,scenePoints:H}=r,v=C(m,y(T,k)),w=y(k,m),O={...r,action:"update"},U=a.context,h=X(S,H),I=t.update({point:v,scenePoint:h,context:x});if(Z=I,E(T,I,w,e),d=v,s=h,P!=="end"){const{frameTask:b}=a;u==null&&(u=new AbortController),c=F=>{l.addPromise(L(g({frameTask:b,event:O,context:U,point:v,scenePoint:h,delta:w,getLastState:()=>({point:d,scenePoint:s,updatePoint:F.forceUpdate?null:Z})},u.signal)))},c({forceUpdate:!1}),p==null&&(p=N(()=>t.options.effectiveEnabled,()=>c==null?void 0:c({forceUpdate:!0})))}}return P==="end"&&f(),r},i],cancelSnapping:r=>(f(),r)}}function R(n,t,o){return M(async({frameTask:l,point:e,scenePoint:i,context:p,event:u,delta:a,getLastState:c},f)=>{const g=await l.schedule(()=>n.snap({point:e,scenePoint:i,context:p,signal:f}),f);if(g.valid){let d=await l.schedule(()=>g.apply(),f);const s=c();s.point!=null&&e!==s.point&&(d=n.update({point:s.point,scenePoint:s.scenePoint,context:p})),s.updatePoint!=null&&q(d,s.updatePoint)||(E(u.mapEnd,d,a,t),o.execute(u))}})}function V(n){return n.type==="3d"?n.resourceController.scheduler.registerTask(K.SNAPPING):Q}function W(n,t,o){return{context:new J({editGeometryOperations:n.editGeometryOperations,elevationInfo:n.elevationInfo,pointer:n.pointer,vertexHandle:t.info!=null?t.info.handle:null,excludeFeature:n.excludeFeature,feature:n.feature,visualizer:n.visualizer}),originalPos:t.snapOrigin!=null?n.coordinateHelper.vectorToDehydratedPoint(t.snapOrigin):t.mapStart,originalScenePos:t.scenePoints!=null?t.scenePoints.sceneStart:null,frameTask:o}}function C(n,[t,o,l]){const e=D(n);return e.x+=t,e.y+=o,e.hasZ&&(e.z+=l),e}function X(n,t){return n==null||t==null?null:C(n,y(t.sceneEnd,t.sceneStart))}function y(n,t){const o=n.hasZ&&t.hasZ?n.z-t.z:0;return[n.x-t.x,n.y-t.y,o]}function E(n,t,[o,l,e],i){n.x=t.x+o,n.y=t.y+l,i&&n.hasZ&&t.hasZ&&(n.z=t.z+e)}function Y(n,t){if(!n.hasZ())return null;const o=t.vertices;let l=null;for(const e of o){const i=n.getZ(e.pos);if(l!=null&&i!=null&&Math.abs(i-l)>1e-6)return null;l==null&&(l=i)}return l}function z(n){return n}export{rn as f};
