import{$ as g,O as v}from"./subclass-BZA_h8Db.js";import{O as $}from"./quat-4pa1e6ds.js";import{e as M}from"./quatf64-CCm9z-pX.js";import{Q as d}from"./vec32-Dvg_eL9J.js";import{t as c,n as h}from"./vec3f32-nZdmKIgz.js";import{g as I}from"./Point-Cg0-ChZE.js";import{n as y}from"./projectBuffer-Bs7GwaPY.js";import{u as w,c as l,i as S,f as F}from"./PointCloudWorkerUtil-BMHmT1-d.js";import{I as O}from"./orientedBoundingBox-DOAJUK5g.js";import"./mat3f64-BBpwCtoL.js";import"./vec3f64-BLpZdpfb.js";import"./common-DQOJ18NT.js";import"./vec42-YcqnINSP.js";import"./tslib.es6-B3Jf3DVX.js";import"./Accessor-BLX9ikPh.js";import"./cast-Bjksrh93.js";import"./writer-DNAwXnhG.js";import"./assets-C43MgM-v.js";import"./index-Bh2oEzTI.js";import"./jsonMap-0cxwUWs2.js";import"./mathUtils-C4_ghTv4.js";import"./geodesicConstants-DWQLYX7F.js";import"./PointCloudUniqueValueRenderer-CiNZlN7O.js";import"./enumeration-Ba5njXdz.js";import"./RendererLegendOptions-B-4se3aU.js";import"./Clonable-D3rtuBWg.js";import"./Color-BCS62Hs5.js";import"./colorUtils-0bJDPow9.js";import"./ColorStop-Dk3U5tCk.js";import"./I3SBinaryReader-D1r70N_w.js";import"./VertexAttribute-Cq4MnHjR.js";import"./mat3-BRl2i9Bz.js";import"./mat4f64-Dk4dwAN8.js";import"./vec4f64-o2zAXfmz.js";import"./spatialReferenceEllipsoidUtils-DBE_OFra.js";import"./computeTranslationToOriginAndRotation-Q27G6TBL.js";import"./mat4-GpOFENPA.js";import"./plane-IENfwZlB.js";import"./vec2f64-miziP1SN.js";import"./mathUtils-BG-eq9fO.js";import"./ViewingMode-Dodu7ZZk.js";class x{transform(t){const r=this._transform(t),o=[r.points.buffer,r.rgb.buffer];r.pointIdFilterMap!=null&&o.push(r.pointIdFilterMap.buffer);for(const n of r.attributes)"buffer"in n.values&&g(n.values.buffer)&&n.values.buffer!==r.rgb.buffer&&o.push(n.values.buffer);return Promise.resolve({result:r,transferList:o})}_transform(t){const r=w(t.schema,t.geometryBuffer);let o=r.length/3,n=null;const f=new Array,a=l(t.primaryAttributeData,r,o);t.primaryAttributeData!=null&&a&&f.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:a});const u=l(t.modulationAttributeData,r,o);t.modulationAttributeData!=null&&u&&f.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:u});let i=S(t.rendererInfo,a,u,o);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const p=t.filterAttributesData.filter(v).map(e=>{const D=l(e,r,o),b={attributeInfo:e.attributeInfo,values:D};return f.push(b),b});n=new Uint32Array(o),o=F(r,i,n,t.filterInfo,p)}for(const p of t.userAttributesData){const e=l(p,r,o);f.push({attributeInfo:p.attributeInfo,values:e})}3*o<i.length&&(i=new Uint8Array(i.buffer.slice(0,3*o))),J(r,o,t.elevationOffset);const s=z(r,o,O.fromData(t.obbData),I.fromJSON(t.inSR),I.fromJSON(t.outSR));return{obbData:t.obbData,points:s,rgb:i,attributes:f,pointIdFilterMap:n}}}function z(m,t,r,o,n){if(!y(m,o,0,m,n,0,t))throw new Error("Can't reproject");const f=c(r.center),a=h(),u=h(),i=c(r.halfSize);$(A,r.quaternion);const s=new Float32Array(3*t);for(let p=0;p<t;p++){let e=3*p;a[0]=m[e]-f[0],a[1]=m[e+1]-f[1],a[2]=m[e+2]-f[2],d(u,a,A),i[0]=Math.max(i[0],Math.abs(u[0])),i[1]=Math.max(i[1],Math.abs(u[1])),i[2]=Math.max(i[2],Math.abs(u[2])),s[e++]=a[0],s[e++]=a[1],s[e]=a[2]}return r.halfSize=i,s}function J(m,t,r){if(r!==0)for(let o=0;o<t;o++)m[3*o+2]+=r}const A=M();function gt(){return new x}export{gt as default};
