import{s as f}from"./Accessor-BHnuXKD2.js";import{$ as u,Q as c}from"./Point-XGrwlf63.js";import{v as p,A as m,g as h}from"./FeatureTemplates-C1EjsYST.js";import{p as d}from"./customElement-Cbe8ahDx.js";import{createPresetServiceEdit as g}from"./createPresetServiceEdit-D3Rj5pNI.js";import{j as v}from"./Polyline-BmuD2-ZN.js";import{l as y,y as b}from"./jsonUtils-Cu7OBRmN.js";function x({edits:t,mode:e,relationships:n,shape:r,templatePart:s},a=""){if(s===null)return;const{template:o}=s;if(!p(o))throw new f("shared-template:template-not-loaded","A template part's template must be loaded before use");if(m(o)){if(!y(r))throw new f("shared-template:invalid-geometry","Preset templates must have a point geometry");g({geometry:r,template:o,edits:t,relationships:n,rotation:0,mode:e,tag:a})}else h(o)&&d({geometry:r,template:o,edits:t,relationships:n,tag:a})}function A(t,e){if(!t||!b(t))return null;if(!e.hasZ&&!e.hasM)return t;let n=null,r=null;const s=e.hasZ&&e.hasM?3:2;switch(e.type){case"point":n=e.hasZ?e.z:null,r=e.hasM?e.m:null;break;case"polygon":case"polyline":{const o=e.type==="polygon"?e.rings:e.paths;for(const i of o)for(const l of i)e.hasZ&&(n===null||l[2]>n)&&(n=l[2]),e.hasM&&(r===null||l[s]>r)&&(r=l[s])}break;case"multipoint":for(const o of e.points)e.hasZ&&(n===null||o[2]>n)&&(n=o[2]),e.hasM&&(r===null||o[s]>r)&&(r=o[s]);break;default:return t}const a=M(t.rings,e.hasZ,e.hasM,n,r);return new v({rings:a,spatialReference:t.spatialReference,hasZ:e.hasZ,hasM:e.hasM})}function D(t){let e=1;return(t.spatialReference.vcsWkid||t.spatialReference.latestVcsWkid)&&(e=u(t.spatialReference)/c(t.spatialReference)),e}function N(t){let e=!1;return t.byNumber!==void 0&&(e=t.byNumber===!0),e}function W(t){let e=0;return t.count!==void 0&&(e=t.count),e}function q(t,e){let n=0;return e?t.proportional!==void 0&&(n=t.proportional):t.distanceValue!==void 0&&(n=t.distanceValue),e&&(n/=100),n}function z(t){return t.isProportional===!0}function B(t){return t.createUnique!==!1}function E(t){let e=0;return t.offsetDistance!==void 0&&(e=t.offsetDistance),t.side!==void 0&&t.side===1&&(e*=-1),e}function O(t){return t.vertexBeforeOffset===!0}function M(t,e,n,r,s){const a=[];for(const o of t)a.push(Z(o,e,n,r,s));return a}function Z(t,e,n,r,s){const a=[];for(const o of t){const i=[o[0],o[1]];e&&(i[2]=r),n&&(i[e?3:2]=s),a.push(i)}return a}export{E as b,A as c,W as d,x as f,q as g,N as h,O as j,D as m,B as v,z as y};
