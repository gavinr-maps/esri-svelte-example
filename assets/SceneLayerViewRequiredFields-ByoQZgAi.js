const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngine-CtEcpiHE.js","./Accessor-BHnuXKD2.js","./Point-XGrwlf63.js","./cast-BA_-jlhc.js","./index-tefRSezt.js","./index-Cx51aysm.css","./JSONSupport-CGdeqxpk.js","./writer-B2bQV2uU.js","./geometryEngineBase-yFIvKOkM.js","./_commonjsHelpers-DCkdB7M8.js","./hydrated-Dw-Mfo_Y.js","./Extent-CBBGeHb-.js","./Polyline-BmuD2-ZN.js","./mathUtils-DV9iOXpW.js"])))=>i.map(i=>d[i]);
import{_ as q}from"./index-tefRSezt.js";import{r as p,m as y,a as N,B as O,G as V,V as T,b2 as M,i as G,c as z,g as C,k as B}from"./Accessor-BHnuXKD2.js";import{a as K,n as Q,b as H}from"./TemporalSceneLayerView-B3wLL0v7.js";import{w as R,c as J,d as W,P as X}from"./reactiveUtils-BR0C1Kq4.js";import{O as Y,L as Z,k as ee,K as te}from"./projection-B2I9Bzj_.js";import{y as re}from"./LayerView-DF8EqCYi.js";import{e as P}from"./uuid-Cl5lrJ4c.js";import{r as ne}from"./featureQueryAll-xezK3WCp.js";import{a as L,N as ie,a0 as oe,a2 as se}from"./opacityUtils-CSd4XoR2.js";let h=class extends re{constructor(){super(...arguments),this.layer=null,this.filter=null,this._geometryEngine=null,this._projectionEngineLoaded=!1,this._abortController=new AbortController}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(e){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}get layerFilter(){return K(this._layerFilter)}get _layerFilter(){var f;const e=(f=this.layer)==null?void 0:f.filter;if(e==null||e.geometries.length<1)return null;const r=this._geometryEngine;if(r==null||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine)return Q;const i=e.geometries.at(0).spatialReference,o=e.geometries.toArray().map(n=>{try{n=r.simplify(n)}catch{return O.getLogger(this).warnOncePerTick("Failed to simplify scene filter mask polygon. Polygon will be ignored."),null}if(n==null)return null;if(n.spatialReference.equals(i))return n;try{return Y(n,i)}catch{return O.getLogger(this).warnOncePerTick("Failed to project scene filter mask polygon. Polygon will be ignored."),null}}).filter(V).sort((n,a)=>n.extent.xmin-a.extent.xmin),s=new Set,d=new Array,u=new Array;for(let n of o){const a=n.extent.xmin;if(d.length=0,s.forEach(l=>{if(a>=l.extent.xmax)return u.push(l),void s.delete(l);n.extent.ymin<=l.extent.ymax&&n.extent.ymax>=l.extent.ymin&&r.intersects(n,l)&&d.push(l)}),d.length>0){d.push(n);try{n=r.union(d)}catch{O.getLogger(this).warnOncePerTick("Failed to unify filter mask polygons. Polygon will be ignored.");continue}d.pop(),d.forEach(l=>s.delete(l))}s.add(n)}return s.forEach(n=>u.push(n)),u.length>0?{spatialRelationship:e.spatialRelationship,geometries:u}:null}get _filterNeedsProjectionEngine(){const e=this.layer.filter;if(e==null||e.geometries.length<=1)return!1;const r=e.geometries.at(0).spatialReference;return e.geometries.some(({spatialReference:i})=>!i.equals(r)&&!Z(i,r))}get layerFilterUpdating(){return H(this._layerFilter)}initialize(){const{signal:e}=this._abortController;R(()=>{var r,i,o;return this.destroyed||!this._geometryEngine&&((o=(i=(r=this.layer)==null?void 0:r.filter)==null?void 0:i.geometries)==null?void 0:o.length)},e).then(async()=>{T(e),this._geometryEngine=await q(()=>import("./geometryEngine-CtEcpiHE.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13]),import.meta.url)}).catch(M),this._projectionEngineLoaded=ee(),R(()=>this.destroyed||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine,e).then(async()=>{T(e),await te(),this._projectionEngineLoaded=!0}).catch(M)}destroy(){this._abortController=G(this._abortController)}highlight(e){throw new Error("Not implemented")}queryFeatures(e,r){throw new Error("Not implemented")}queryObjectIds(e,r){throw new Error("Not implemented")}queryFeatureCount(e,r){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(e,r){throw new Error("Not implemented")}};p([y()],h.prototype,"layer",void 0),p([y()],h.prototype,"availableFields",null),p([y()],h.prototype,"maximumNumberOfFeatures",null),p([y({readOnly:!0})],h.prototype,"maximumNumberOfFeaturesExceeded",null),p([y()],h.prototype,"filter",void 0),p([y({readOnly:!0})],h.prototype,"layerFilter",null),p([y({readOnly:!0})],h.prototype,"_layerFilter",null),p([y()],h.prototype,"_geometryEngine",void 0),p([y()],h.prototype,"_projectionEngineLoaded",void 0),p([y()],h.prototype,"_filterNeedsProjectionEngine",null),p([y()],h.prototype,"layerFilterUpdating",null),h=p([N("esri.views.layers.SceneLayerView")],h);const ve=h,le={setAttribute(){},rollback(){},commit(){}};var E;function Oe(t,e){const r=e.attributes[t.objectIdField];if(r==null)return le;const i=t.sessions.get(r);if(i)return i;const o=z(e.attributes),s=new Set,d=t.i3sOverrides.createInteractiveEditSession(r),u=new Map,f=(l,g)=>{const c=u.get(l);if(c==null){const m=g.indexOf(r);return u.set(l,m),m}return c};let n=E.EDITING;const a={setAttribute(l,g){if(n!==E.EDITING)return;const c=t.fieldsIndex.get(l);if(!c)return;const m=t.attributeStorageInfo.findIndex(F=>F.name===c.name);if(m<0)return;if(!(l in o))throw new Error(`Attribute "${l}" is not an attribute of the edited feature.`);d.setAttribute(m,g);const I=t.attributeStorageInfo[m];let b=!1;s.add(l),t.forEachNode((F,x)=>{const _=f(F,x);if(_===-1)return;const v=t.getAttributeData(F.index);if(v){const A=v[I.name];A&&(A[_]=g,t.setAttributeData(F.index,v,e),b=!0)}}),b&&t.clearMemCache()},rollback(){if(n===E.EDITING){for(const l of s)this.setAttribute(l,o[l]);d.remove(),n=E.ROLLED_BACK,t.sessions.delete(r)}},commit(){n===E.EDITING&&(d.remove(),n=E.COMMITTED,t.sessions.delete(r))}};return t.sessions.set(r,a),a}function ae(t,e,r){const{gidToFeatureInfo:i,oidToFeatureInfo:o,fieldsIndex:s,objectIdField:d,globalIdField:u,featureOrIdentifierList:f}=r;if(!r.featuresResolved&&f!=null){for(const n of f){const a={feature:null,oid:-1,gid:null};if("attributes"in n){a.feature=n;const l=n.attributes;if(l!=null)for(const g in l){if(a.oid!==-1&&a.gid!=null)break;const c=s.normalizeFieldName(g);c===d&&(a.oid=l[g]??-1),c===u&&(a.gid=l[g])}}else a.oid=n.objectId??-1,a.gid=n.globalId;a.gid!=null&&i.set(a.gid,a),a.oid!==-1&&o.set(a.oid,a)}r.featuresResolved=!0}return(t!==-1?o.get(t):null)??(e!=null?i.get(e):null)}function $(t,e,r,i,o=null,s=!0){const d=[],u={gidToFeatureInfo:new Map,oidToFeatureInfo:new Map,featuresResolved:r==null,fieldsIndex:t.fieldsIndex,objectIdField:t.objectIdField,globalIdField:t.globalIdField,featureOrIdentifierList:r};for(const f of e){if(f.error!=null)continue;const n=f.objectId??-1,a=f.globalId,l=(n===-1||s?ae(n,a,u):null)??{feature:null,oid:n,gid:a},g={oid:n===-1?l.oid:n,gid:a??l.gid,feature:l.feature,result:f};d.push(g);const c=g.gid?P(g.gid):null;if(g.oid===-1&&c!=null&&o!=null&&(g.oid=o.get(c)??-1),g.oid===-1&&c!=null){let m=i.get(c);m==null&&(m={gid:g.gid,edits:[]},i.set(c,m)),m.edits.push(g)}}return d}async function Ae(t,e){var d,u,f;const r=new Map,i=$(t,e.addedFeatures,(d=e.edits)==null?void 0:d.addFeatures,r),o=$(t,e.updatedFeatures,(u=e.edits)==null?void 0:u.updateFeatures,r),s=$(t,e.deletedFeatures,(f=e.edits)==null?void 0:f.deleteFeatures,r,e.globalIdToObjectId,!1);return r.size>0&&await de(t,r),{adds:i.filter(n=>n.oid!==-1),updates:o.filter(n=>n.oid!==-1),deletes:s.filter(n=>n.oid!==-1)}}async function de(t,e){const r=t.i3sOverrides.layer.associatedLayer;if((r==null?void 0:r.globalIdField)==null)return;const i=r.createQuery(),{objectIdField:o,globalIdField:s}=r;i.where=Array.from(e.values()).map(({gid:f})=>`${s}='${f}'`).join(" OR "),i.returnGeometry=!1,i.outFields=[o,s],i.cacheHint=!1;const d=await J(ne(r,i));if(!d.ok)return;const u=d.value.features;for(const f of u){const n=f.attributes[s],a=f.attributes[o];if(n==null||a==null||a===-1)continue;const l=e.get(P(n));if(l!=null)for(const g of l.edits)g.oid=a}}function Ne(t,e){const r=new Map,i=o=>{for(const{oid:s,feature:d}of o){const u=d==null?void 0:d.geometry;(u==null?void 0:u.type)==="mesh"&&r.set(s,u)}};i(e.adds),i(e.updates);for(const o of e.deletes)r.set(o.oid,null);for(const[o,s]of r)t.i3sOverrides.updateGeometry(o,s)}function $e(t,e){var g;const r=ce(t,e),i=ue(t,e);if(r.size===0&&i.size===0)return;const o=new Map;for(let c=0;c<t.attributeStorageInfo.length;c++)o.set(t.attributeStorageInfo[c].name,c);let s=!1;r.forEach((c,m)=>{const I=t.getAttributeData(m);let b=!1;c.forEach((F,x)=>{const _=I!=null?I[x]:null,v=o.get(x);for(const{featureIndex:A,value:j,featureId:U}of F)_&&(_[A]=j,b=!0,s=!0),t.i3sOverrides.updateAttributeValue(U,v,j)}),b&&t.setAttributeData(m,I,null)}),s&&t.clearMemCache();const{fieldsIndex:d,i3sOverrides:u,objectIdField:f,globalIdField:n}=t,a=(g=u.layer.associatedLayer)==null?void 0:g.infoFor3D,l=new Set(a?[...Object.values(a.assetMapFieldRoles),...Object.values(a.transformFieldRoles)]:[]);for(const[c,m]of i){u.featureAdded(c);const{attributes:I}=m;for(const b in I){if(b!==f&&b!==n&&l.has(b))continue;const F=d.normalizeFieldName(b),x=F!=null?o.get(F):null;if(x==null)continue;const _=I[b];u.updateAttributeValue(c,x,_)}}}function ue(t,e){var o;const r=new Map,i=e.adds;if(!i||i.length===0||t.globalIdField==null)return r;for(const s of i){const d=s.oid,u=s.feature;((o=u==null?void 0:u.geometry)==null?void 0:o.type)==="mesh"&&r.set(d,u)}return r}function ce(t,e){const r=e.updates;if(!r||r.length===0)return new D;const i=new D,o=new Map;for(let s=0;s<t.attributeStorageInfo.length;s++)o.set(t.attributeStorageInfo[s].name,s);return t.forEachNode((s,d)=>{for(const u of r){if(u.feature==null)continue;const f=u.feature,n=u.oid,a=d.indexOf(n);for(const l in f.attributes){const g=t.fieldsIndex.normalizeFieldName(l),c=fe(i,s.index,g),m=f.attributes[l];c.push({featureIndex:a,featureId:n,value:m})}}}),i}function fe(t,e,r){const i=ge(t,e),o=r!=null&&i.get(r);if(o)return o;const s=new Array;return i.set(r,s),s}function ge(t,e){const r=t.get(e);if(r)return r;const i=new pe;return t.set(e,i),i}(function(t){t[t.EDITING=0]="EDITING",t[t.ROLLED_BACK=1]="ROLLED_BACK",t[t.COMMITTED=2]="COMMITTED"})(E||(E={}));const pe=Map,D=Map;function Le(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,get:function(){const{layer:t,layer:{fieldsIndex:e},requiredFields:r}=this;return t.outFields?L(e,[...ie(e,t.outFields),...r]):L(e,r)}}}}const k=t=>{let e=class extends t{constructor(){super(...arguments),this._numUpdating=0}get updating(){return this._numUpdating>0}autoUpdateAsync(r,i){const o=B(async s=>{++this._numUpdating;try{const d=await s;this.destroyed||this._set(r,d)}catch{O.getLogger(this).warn(`Async update of "${String(r)}" failed. Async update functions should not throw exceptions.`)}--this._numUpdating});return W(i,o,X)}};return p([y({readOnly:!0})],e.prototype,"updating",null),p([y()],e.prototype,"_numUpdating",void 0),e=p([N("esri.core.AsyncUpdate")],e),e};let S=class extends k(C){};S=p([N("esri.core.AsyncUpdate")],S);let w=class extends k(C){get layer(){return this.layerView.layer}get requiredFields(){const{layerView:{layer:{fieldsIndex:t},definitionExpressionFields:e},rendererFields:r,labelingFields:i,viewFilterFields:o}=this;return L(t,[...e??[],...r??[],...i??[],...o??[]])}constructor(t){super(t)}initialize(){this.addHandles([this.autoUpdateAsync("rendererFields",async()=>{const{fieldsIndex:t,renderer:e}=this.layer;return e?this._getFieldsAsync(r=>e.collectRequiredFields(r,t)):null}),this.autoUpdateAsync("labelingFields",async()=>{const{layer:t}=this;return t.labelsVisible?this._getFieldsAsync(e=>oe(e,t)):null}),this.autoUpdateAsync("viewFilterFields",()=>{const{layer:t,mergedFilter:e}=this.layerView;return this._getFieldsAsync(r=>se(r,t,e))})])}async _getFieldsAsync(t){const e=new Set;try{return await t(e),Array.from(e).sort()}catch(r){return O.getLogger(this).error(r),null}}};p([y()],w.prototype,"layerView",void 0),p([y()],w.prototype,"layer",null),p([y()],w.prototype,"requiredFields",null),p([y()],w.prototype,"rendererFields",void 0),p([y()],w.prototype,"labelingFields",void 0),p([y()],w.prototype,"viewFilterFields",void 0),w=p([N("esri.views.3d.layers.support.SceneLayerViewRequiredFields")],w);export{w as a,Ae as b,$e as c,Ne as f,Le as i,Oe as s,ve as w};
