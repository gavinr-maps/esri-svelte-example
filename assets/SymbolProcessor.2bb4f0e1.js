import{m as e,ab as t,ad as s,ca as r,fs as i,v as a,I as o,b8 as n,bF as l,q as c,r as d,gR as f,G as h,j5 as u,bI as m}from"./vendor.d0a39f0f.js";import{k as p,u as g,l as y,E as b,t as _}from"./Matcher.475ab8e3.js";import{n as v}from"./schemaUtils.c72e3829.js";import{p as I}from"./BaseProcessor.f85f5775.js";import{v as S}from"./ComputedAttributeStorage.61e51d59.js";import"./definitions.e5e12ce7.js";import"./Utils.ea926aef.js";import"./Texture.6f578e52.js";import"./tileUtils.de6627be.js";import"./TileClipper.863da83f.js";import"./GeometryUtils.1bcb906c.js";import"./visualVariablesUtils.684ffd7c.js";import"./visualVariablesUtils.076fa3c6.js";import"./MaterialKey.376930c0.js";import"./CIMSymbolHelper.0ef4e080.js";import"./earcut.9760c2d2.js";import"./quantizationUtils.2d4b616a.js";import"./json.62026198.js";import"./Rect.db562a93.js";import"./BidiEngine.af5bfcbd.js";import"./MD5.86afbcc5.js";import"./FeatureSetReader.3c31cb94.js";import"./centroid.1404a86d.js";function j(e,t){return(!e.minScale||e.minScale>=t)&&(!e.maxScale||e.maxScale<=t)}function w(e){const t=e.message,s={message:{data:{},tileKey:t.tileKey,tileKeyOrigin:t.tileKeyOrigin},transferList:new Array};for(const r in t.data){const e=t.data[r];if(s.message.data[r]=null,d(e)){const t=e.stride,i=e.indices.slice(0),a=e.vertices.slice(0),o=e.records.slice(0),n={stride:t,indices:i,vertices:a,records:o,metrics:l(e.metrics,(e=>e.slice(0)))};s.transferList.push(i,a,o),s.message.data[r]=n}}return s}e.getLogger("esri.views.2d.layers.features.processors.SymbolProcessor");let D=class extends I{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))])}destroy(){}get supportsTileUpdates(){return!0}forEachBufferId(e){this._bufferIds.forEach((t=>{t.forEach(e)}))}async update(e,t){const s=t.schema.processors[0];if("symbol"!==s.type)return;const o=r(this._schema,s);i(o,"mesh")&&(a("esri-2d-update-debug")&&console.debug("Applying Update - Processor:",o),e.mesh=!0,e.why.mesh.push("Symbology changed"),this._schema=s,this._factory=this._createFactory(s),this._factory.update(s,this.tileStore.tileScheme.tileInfo))}onTileMessage(e,t,s,r){return o(r),this._onTileData(e,t,s,r)}onTileClear(e){return this._bufferData.delete(e.key.id),this._bufferIds.delete(e.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:{clear:!0}})}onTileError(e,t,s){const r=s.signal,i={tileKey:e.id,error:t};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:r})}onTileUpdate(e){for(const t of e.removed)this._bufferData.has(t.key.id)&&this._bufferData.delete(t.key.id),this._bufferIds.has(t.key.id)&&this._bufferIds.delete(t.key.id);for(const t of e.added)this._bufferData.forEach((e=>{for(const s of e)s.message.tileKey===t.id&&this._updateTileMesh("append",t,w(s),[],!1,!1,null)}))}_addBufferData(e,t){this._bufferData.has(e)||this._bufferData.set(e,[]),this._bufferData.get(e).push(w(t))}_createFactory(e){const{geometryType:t,objectIdField:s,fields:r}=this.service,i={geometryType:t,fields:r,spatialReference:n.fromJSON(this.spatialReference)},a=new p(((e,t)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",e,t)),this.tileStore.tileScheme.tileInfo),{matcher:o,aggregateMatcher:c}=e.mesh;return this._store=a,this._matchers.feature=g(o,a,i),this._matchers.aggregate=l(c,(e=>g(e,a,i))),new y(t,s,a)}async _onTileData(e,t,s,r){o(r);const{type:i,addOrUpdate:a,remove:n}=t,l=t.end,h=!!this._schema.mesh.sortKey;if(!a){const t={type:i,addOrUpdate:null,remove:n,clear:!1,end:l,sort:h};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},r)}const u=this._processFeatures(e,a,s,r);try{const s=await u;if(c(s)){const t={type:i,addOrUpdate:null,remove:n,clear:!1,end:l,sort:h};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},r)}const a=[];for(const t of s){let s=!1;const r=t.message.bufferIds,i=e.key.id,o=t.message.tileKey;if(i!==o&&d(r)){if(!this.tileStore.get(o))continue;let e=this._bufferIds.get(o);e||(e=new Set,this._bufferIds.set(o,e));const t=Array.from(r);for(const r of t){if(e.has(r)){s=!0;break}e.add(r)}}s||(this._addBufferData(i,t),a.push(t))}await f(a.map((s=>{const a=e.key.id===s.message.tileKey,o=a?t.remove:[],n=a&&t.end;return this._updateTileMesh(i,e,s,o,n,t.clear,r.signal)})))}catch(m){this._handleError(e,m,r)}}async _updateTileMesh(e,t,s,r,i,a,n){const c=e,d=s.message.tileKey,f=!!this._schema.mesh.sortKey;d!==t.key.id&&(i=!1);const h=l(s,(e=>e.message)),u=l(s,(e=>e.transferList))||[],p={type:c,addOrUpdate:h,remove:r,clear:!1,end:i,sort:f},g={transferList:m(u)||[],signal:n};return o(g),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:d,data:p},g)}async _processFeatures(e,t,s,r){if(c(t)||!t.hasFeatures)return null;const i={transform:e.transform,hasZ:!1,hasM:!1},a=this._factory,n={viewingMode:"",scale:e.scale},l=await this._matchers.feature,d=await this._matchers.aggregate;o(r);const f=this._getLabelInfos(e,t);return await a.analyze(t.getCursor(),l,d,i,n),o(r),this._writeFeatureSet(e,t,i,f,a,s)}_writeFeatureSet(e,t,s,r,i,a){const o=t.getSize(),n="simple"===this._schema.mesh.matcher.type&&this._schema.mesh.matcher.isDotDensity,l=new b(e.key.id,{features:o,records:o,metrics:0},n,a,!0),c={viewingMode:"",scale:e.scale},f=t.getCursor();for(;f.next();)try{const t=f.getDisplayId(),a=d(r)?r.get(t):null;i.writeCursor(l,f,s,c,e.level,a)}catch(u){}const h=e.tileInfoView.tileInfo.isWrappable;return l.serialize(h)}_handleError(e,t,s){if(!h(t)){const r={tileKey:e.id,error:t.message};return this.remoteClient.invoke("tileRenderer.onTileError",r,{signal:s.signal})}}_getLabelingSchemaForScale(e){const t=this._schema.mesh.labels;if(c(t))return null;if("subtype"===t.type){const s={type:"subtype",classes:{}};let r=!1;for(const i in t.classes){const a=t.classes[i].filter((t=>j(t,e.scale)));r=r||!!a.length,s.classes[i]=a}return r?s:null}const s=t.classes.filter((t=>j(t,e.scale)));return s.length?{type:"simple",classes:s}:null}_getLabels(e,t){if("subtype"===t.type){var s;const r=this.service.subtypeField,i=u(r,"Expected to find subtype Field"),a=e.readAttribute(i);return null==a?[]:null!=(s=t.classes[a])?s:[]}return t.classes}_getLabelInfos(e,t){const s=this._getLabelingSchemaForScale(e);if(c(s))return null;const r=new Map,i=t.getCursor();for(;i.next();){const e=i.getDisplayId(),t=[],a=S(e),o=a&&1!==i.readAttribute("cluster_count")?"aggregate":"feature",n=this._getLabels(i,s);for(const s of n){if(s.target!==o)continue;const r=i.getStorage(),n=a&&"feature"===o?r.getComputedStringAtIndex(i.readAttribute("referenceId"),s.fieldIndex):r.getComputedStringAtIndex(e,s.fieldIndex);if(!n)continue;const l=v(n.toString()),c=l[0],d=l[1];this._store.getMosaicItem(s.symbol,_(c)).then((e=>{t[s.index]={glyphs:e.glyphMosaicItems,rtl:d,index:s.index}}))}r.set(e,t)}return r}};D=t([s("esri.views.2d.layers.features.processors.SymbolProcessor")],D);var T=D;export{T as default};
