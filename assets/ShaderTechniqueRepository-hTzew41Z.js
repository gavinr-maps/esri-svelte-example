import{b as u}from"./subclass-BZA_h8Db.js";import{t as f}from"./NestedMap-GuqgquCN.js";import{a as m}from"./ShaderTechniqueConfiguration-CBbn2DCi.js";class w{constructor(e){this.context=e,this._debug=!1,this._precompiling=this._debug?0:1,this._cache=new f,this._frameCounter=0,this._keepAliveFrameCount=h}get precompiling(){return this._precompiling}set precompiling(e){this._precompiling=e,e===0&&this.context.rctx.gl.flush()}get viewingMode(){return this.context.viewingMode}destroy(){this._debug&&this._cache.forEach((e,t)=>{e.forEach(r=>{r.refCount>0&&console.error(`Unreleased ${t} shader technique, refCount ${r.refCount}`)})}),this._cache.forAll(e=>e.technique.destroy()),this._cache.clear()}precompile(e,t=a){++this.precompiling,this.acquire(e,t).release(),--this.precompiling}acquire(e,t=a){const r=t.key.code;let o=this._cache.get(e,r);if(o==null){if(this._precompiling===0){let c=`Uncached shader compile in ${new Error().stack}
  for configuration
${t.decode()}`;const i=this._cache.getInner(e);throw i!=null&&i.size&&(c+=`

  cached configurations:
`,c+=Array.from(i.values()).map(l=>t.decode(l.technique.key)).sort().join(`

`)),console.log(c),new u(c)}const s=new e(this.context,t,()=>this._release(s));o=new p(s),this._cache.set(e,r,o)}return++o.refCount,o.technique}_release(e){if(e==null||this._cache.empty)return;const t=this._cache.get(e.constructor,e.key.code);t!=null&&(--t.refCount,t.refCount===0&&(t.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==h&&this._cache.forEach((e,t)=>{e.forEach((r,o)=>{r.refCount===0&&r.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(r.technique.destroy(),this._cache.delete(t,o))})})}async reloadAll(){const e=new Array;this._cache.forEach(t=>e.push(_(t))),await Promise.all(e)}}class p{constructor(e){this.technique=e,this.refCount=0,this.refZeroFrame=0}}const h=-1;async function _(n){let e=!0;n.forEach(async t=>{await t.technique.reload(e),e=!1})}const a=new m;export{w as o,a as s};
