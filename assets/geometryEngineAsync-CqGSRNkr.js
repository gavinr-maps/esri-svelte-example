import{p as h}from"./workers-Cds_sd9m.js";import{j as l}from"./Point-Cz2JYYmX.js";import{f as m}from"./jsonUtils-CwFG8yN4.js";import"./Accessor-BmwT4B0c.js";import"./Queue-BQesTh_6.js";import"./SimpleObservable-CvOkykwM.js";import"./cast-CsZslgGN.js";import"./index-4eY77cms.js";import"./JSONSupport-DcrLLGjL.js";import"./intl-Duiy0OzY.js";import"./Promise-DfET-uns.js";import"./writer-DKgfqj4X.js";import"./Extent-g5W9hy0j.js";import"./Polyline-s-JzsQqo.js";import"./mathUtils-Cfq9PL9W.js";function n(e){var t;return Array.isArray(e)?(t=e[0])==null?void 0:t.spatialReference:e==null?void 0:e.spatialReference}function p(e){return e&&(Array.isArray(e)?e.map(p):e.toJSON?e.toJSON():e)}function o(e){return Array.isArray(e)?e.map(t=>m(t)):m(e)}function S(e,t){let r;return Array.isArray(e)?r=e:(r=[],r.push(e),t!=null&&r.push(t)),r}let f;async function w(){return f||(f=h("geometryEngineWorker",{strategy:"distributed"})),f}async function a(e,t){return(await w()).invoke("executeGEOperation",{operation:e,parameters:p(t)})}async function d(e,t){const r=await w();return Promise.all(r.broadcast("executeGEOperation",{operation:e,parameters:p(t)}))}function H(e){return a("extendedSpatialReferenceInfo",[e])}async function I(e,t){return o(await a("clip",[n(e),e,t]))}async function P(e,t){return o(await a("cut",[n(e),e,t]))}function k(e,t){return a("contains",[n(e),e,t])}function q(e,t){return a("crosses",[n(e),e,t])}function B(e,t,r){return a("distance",[n(e),e,t,r])}function C(e,t){return a("equals",[n(e),e,t])}function G(e,t){return a("intersects",[n(e),e,t])}function $(e,t){return a("touches",[n(e),e,t])}function W(e,t){return a("within",[n(e),e,t])}function F(e,t){return a("disjoint",[n(e),e,t])}function K(e,t){return a("overlaps",[n(e),e,t])}function M(e,t,r){return a("relate",[n(e),e,t,r])}function Q(e){return a("isSimple",[n(e),e])}async function U(e){return o(await a("simplify",[n(e),e]))}async function X(e,t=!1){return o(await a("convexHull",[n(e),e,t]))}async function Y(e,t){return o(await a("difference",[n(e),e,t]))}async function Z(e,t){return o(await a("symmetricDifference",[n(e),e,t]))}async function _(e,t){return o(await a("intersect",[n(e),e,t]))}async function ee(e,t=null){const r=S(e,t);return o(await a("union",[n(r),r]))}async function te(e,t,r,i,s,u){return o(await a("offset",[n(e),e,t,r,i,s,u]))}async function re(e,t,r,i=!1){const s=[n(e),e,t,r,i];return o(await a("buffer",s))}async function ae(e,t,r,i,s,u){const g=[n(e),e,t,r,i,s,u];return o(await a("geodesicBuffer",g))}async function ne(e,t,r=!0){const i=await a("nearestCoordinate",[n(e),e,t,r]);return{...i,coordinate:l.fromJSON(i.coordinate)}}async function ie(e,t){const r=await a("nearestVertex",[n(e),e,t]);return{...r,coordinate:l.fromJSON(r.coordinate)}}async function oe(e,t,r,i){return(await a("nearestVertices",[n(e),e,t,r,i])).map(s=>({...s,coordinate:l.fromJSON(s.coordinate)}))}function y(e){var t;return"xmin"in e?e.center:"x"in e?e:(t=e.extent)==null?void 0:t.center}async function se(e,t,r){if(e==null)throw new c;const i=e.spatialReference;if((r=r??y(e))==null)throw new c;const s=e.constructor.fromJSON(await a("rotate",[i,e,t,r]));return s.spatialReference=i,s}async function ce(e,t){if(e==null)throw new c;const r=e.spatialReference;if((t=t??y(e))==null)throw new c;const i=e.constructor.fromJSON(await a("flipHorizontal",[r,e,t]));return i.spatialReference=r,i}async function ue(e,t){if(e==null)throw new c;const r=e.spatialReference;if((t=t??y(e))==null)throw new c;const i=e.constructor.fromJSON(await a("flipVertical",[r,e,t]));return i.spatialReference=r,i}async function fe(e,t,r,i){return o(await a("generalize",[n(e),e,t,r,i]))}async function le(e,t,r){return o(await a("densify",[n(e),e,t,r]))}async function pe(e,t,r,i=0){return o(await a("geodesicDensify",[n(e),e,t,r,i]))}function ye(e,t){return a("planarArea",[n(e),e,t])}function me(e,t){return a("planarLength",[n(e),e,t])}function we(e,t,r){return a("geodesicArea",[n(e),e,t,r])}function de(e,t,r){return a("geodesicLength",[n(e),e,t,r])}async function ge(e,t){return o(await a("intersectLinesToPoints",[n(e),e,t]))}async function he(e,t){await d("changeDefaultSpatialReferenceTolerance",[e,t])}async function Se(e){await d("clearDefaultSpatialReferenceTolerance",[e])}class c extends Error{constructor(){super("Illegal Argument Exception")}}export{re as buffer,he as changeDefaultSpatialReferenceTolerance,Se as clearDefaultSpatialReferenceTolerance,I as clip,k as contains,X as convexHull,q as crosses,P as cut,le as densify,Y as difference,F as disjoint,B as distance,C as equals,H as extendedSpatialReferenceInfo,ce as flipHorizontal,ue as flipVertical,fe as generalize,we as geodesicArea,ae as geodesicBuffer,pe as geodesicDensify,de as geodesicLength,_ as intersect,ge as intersectLinesToPoints,G as intersects,Q as isSimple,ne as nearestCoordinate,ie as nearestVertex,oe as nearestVertices,te as offset,K as overlaps,ye as planarArea,me as planarLength,M as relate,se as rotate,U as simplify,Z as symmetricDifference,$ as touches,ee as union,W as within};
