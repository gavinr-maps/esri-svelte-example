import{d as Me,m as rn}from"./Viewpoint-C4FqWA2d.js";import"./geometry-D964gYQX.js";import{d as zt}from"./Graphic-DsxsIjhH.js";import{_ as _n}from"./asyncUtils-CWX51uTe.js";import{n as Gt,b as Bn}from"./subclass-BZA_h8Db.js";import{n as mn,r as Ht,a as jn}from"./Cyclical-oTUX3aX7.js";import{s as O}from"./Accessor-BLX9ikPh.js";import{n as Pt,u as Dt}from"./mat3-BRl2i9Bz.js";import{e as Lt}from"./mat3f64-BBpwCtoL.js";import{e as pn}from"./mat4f64-Dk4dwAN8.js";import{s as C,v as kn,g as I,c as ue,u as fe,P,r as z,K as Ut,A as _e,_ as re,E as He,q as on,o as x,y as Bt,p as ve,I as jt,X as vn,W as kt,N as qt}from"./vec32-Dvg_eL9J.js";import{n as m,r as de,_ as xn,t as qn}from"./vec3f64-BLpZdpfb.js";import{I as ie,K as Zn,H as Wn}from"./projection-B971H0Re.js";import{C as Zt}from"./computeTranslationToOriginAndRotation-Q27G6TBL.js";import{c as Pe,i as De}from"./projectPointToVector-GINIbYMz.js";import{t as Ee,c as Jn}from"./projectVectorToPoint-DcLtSZYw.js";import{n as xe}from"./projectVectorToVector-G2uWGoIb.js";import{u as Wt,p as Jt,v as Kt,w as Xt,q as Kn,l as sn,M as Vt,g as Yt,E as Qt,y as ea}from"./aaBoundingBox-BE7cC1jD.js";import{N as na,v as cn,c as Xn,b as ta,Q as aa,u as ra}from"./Polyline-D9YkgmM_.js";import{b as Z,H as ia,I as oa,L as sa,P as ca,s as la,u as ua,c as fa,l as Vn,v as ma,j as Yn}from"./frustum-CQrOepbv.js";import{u as pa}from"./scaleUtils-D_Nw3nhM.js";import{i as Ae,g as Oe,R as da,j as R,n as ha}from"./Point-Cg0-ChZE.js";import{T as ga}from"./dehydratedFeatureUtils-B--Sgpdi.js";import{M as j,b as ln,s as S,l as qe,o as En,r as ya}from"./mathUtils-C4_ghTv4.js";import{l as dn}from"./ViewingMode-Dodu7ZZk.js";import{R as Ta,l as Ra,p as $a,b as wa}from"./mat4-GpOFENPA.js";import{t as An,n as Ma,r as _a}from"./vec2f64-miziP1SN.js";import{w as hn}from"./Extent-Bf3YTe7m.js";import{T as va}from"./vec2-maR1OrZI.js";import{k as Qn,L as xa,Q as Ea,E as Aa}from"./sphere-C77djCO6.js";import{m as Oa,v as Sa,b as ba}from"./lineSegment-D7sKPPYf.js";import{q as Fa,l as On,M as Sn,z as bn,Z as Ia,d as Ca,W as ge,O as Na}from"./plane-IENfwZlB.js";import{s as za,p as Ga}from"./vec42-YcqnINSP.js";import{n as Ha}from"./vec4f64-o2zAXfmz.js";import{e as et}from"./common-DQOJ18NT.js";import{l as Pa,s as Da}from"./earthUtils-ByXwmaX5.js";import{j as La}from"./mathUtils-BG-eq9fO.js";import{a as Ze}from"./ElevationProvider-C95wyCKc.js";import{r as Ua}from"./spatialReferenceSupport-yRFduOSO.js";function Ki(e,n,t,a){return e.renderCoordsHelper.fromRenderCoords(n.eye,Le,a)!=null&&na(t,Le)}function Ba(e,n){return e.elevationProvider?e.elevationProvider.getElevation(n[0],n[1],n[2],e.renderCoordsHelper.spatialReference,"ground")??0:0}function he(e,n,t,a){const r=e.state.camera.clone();n&&t&&a&&(r.eye=n,r.center=t,r.up=a),ja(e,r.ray,W)||C(W,r.center);const i=e.state.constraints,o=i.minimumPoiDistance;if(kn(r.eye,W)<o){const s=i.collision.enabled;C(te,r.viewForward),I(te,te,o),s?r.eye=ue(Le,W,te):fe(W,r.eye,te);const c=e.renderCoordsHelper,l=c.getAltitude(r.eye),u=i.collision.elevationMargin;s&&l<u&&(ue(te,W,r.eye),r.eye=c.setAltitude(Le,u,r.eye),fe(W,r.eye,te))}return r.center=W,r}function Fn(e,n,t){if(!e.state.isGlobal||!e.stateManager.constraintsManager)return!1;const a=Ba(e,n),r=e.stateManager.constraintsManager.nearFarHeuristic,{far:i}=r.compute(n,t,e.renderDataExtent,a,qa),o=i*i;return kn(n,t)>o}function ja(e,n,t){let a=In[e.viewingMode];a||(a=ga(e.state.viewingMode),a.options.backfacesTerrain=!e.state.isGlobal,a.options.invisibleTerrain=!0,In[e.viewingMode]=a);const{isGlobal:r}=e.state;return!(!e.sceneIntersectionHelper.intersectRay(n,a,t)||Fn(e,n.origin,t))||!(!e.renderCoordsHelper.intersectManifold(n,0,t)||Fn(e,n.origin,t))||!!r&&ka(n,t,Ae(e.spatialReference).radius)}function ka(e,n,t){const a=P(e.origin,e.origin)-t*t,r=a>0?Math.sqrt(a)/3:1;return I(n,e.direction,r/z(e.direction)),fe(n,n,e.origin),!0}const In={},Le=m(),W=m(),te=m(),qa={near:0,far:0};function Za(e,n){const t=[],a=[];return Ie(t,e,n,D.LEFT),Ie(a,t,n,D.BOTTOM),Ie(t,a,n,D.RIGHT),Ie(a,t,n,D.TOP),a}function Ie(e,n,t,a){const r=Wa(t,a);if(e.length=0,n.length){r(Ce,n[0],n[0])===F.INSIDE&&ye(e,n[0]);for(let i=0;i<n.length;i++){const o=n[i===n.length-1?0:i+1];switch(r(Ce,n[i],o)){case F.INSIDE:ye(e,o);break;case F.INSIDE_OUT:ye(e,An(Ce));break;case F.OUTSIDE_IN:ye(e,An(Ce)),ye(e,o);case F.OUTSIDE:}}}}function ye(e,n){e.length!==0&&va(e.at(-1),n)||e.push(n)}function Wa(e,n){const t=n===D.LEFT||n===D.RIGHT?0:1,a=e[n],r=n===D.LEFT||n===D.BOTTOM?le.MIN:le.MAX,i=t===0?1:0;return(o,s,c)=>{if(s[t]<a&&c[t]<a)return r===le.MIN?F.OUTSIDE:F.INSIDE;if(s[t]>a&&c[t]>a)return r===le.MIN?F.INSIDE:F.OUTSIDE;const l=(c[i]-s[i])/(c[t]-s[t]),u=s[i]+l*(a-s[t]);return o[t]=a,o[i]=u,(s[t]<a?1:-1)*r>0?F.OUTSIDE_IN:F.INSIDE_OUT}}var le,F,D;(function(e){e[e.MIN=1]="MIN",e[e.MAX=-1]="MAX"})(le||(le={})),function(e){e[e.OUTSIDE=0]="OUTSIDE",e[e.INSIDE=1]="INSIDE",e[e.OUTSIDE_IN=2]="OUTSIDE_IN",e[e.INSIDE_OUT=3]="INSIDE_OUT"}(F||(F={})),function(e){e[e.LEFT=0]="LEFT",e[e.BOTTOM=1]="BOTTOM",e[e.RIGHT=2]="RIGHT",e[e.TOP=3]="TOP"}(D||(D={}));const Ce=Ma();let Cn=class{get planes(){return this.frustum}get points(){return this._points}get mutablePoints(){return this._points}get direction(){return this._direction}get origin(){return this._origin}constructor(n){this.renderCoordsHelper=n,this.frustum=ia(),this._points=oa(),this.lines=new Array(12),this._origin=m(),this._direction=m(),this._altitude=null;for(let t=0;t<12;t++)this.lines[t]={origin:null,direction:m(),endpoint:null}}update(n){sa(n.viewMatrix,n.projectionMatrix,this.frustum,this._points),C(this._origin,n.eye),C(this._direction,n.viewForward),this._altitude=this.renderCoordsHelper.getAltitude(this._origin),this._updateLines()}updatePoints(n){for(let t=0;t<this._points.length;t++)C(this._points[t],n[t]);ca(this.frustum,this._points),this._updateLines()}get altitude(){return this._altitude}intersectsSphere(n){return la(this.frustum,n)}intersectsRay(n){return ua(this.frustum,n)}intersectsLineSegment(n,t){return fa(this.frustum,n,t)}intersectsPoint(n){return Vn(this.frustum,n)}_updateLines(){const n=this._points;for(let t=0;t<4;t++){const a=t+4;Ye(this.lines[t],n[t],n[a]),Ye(this.lines[t+4],n[t],t===3?n[0]:n[t+1]),Ye(this.lines[t+8],n[a],t===3?n[4]:n[a+1])}}};var B;function Ye(e,n,t){e.origin=n,e.endpoint=t,Ut(e.direction,n,t)}Cn.planePointIndices=ma,Cn.nearFarLineIndices=[[Z.NEAR_BOTTOM_LEFT,Z.FAR_BOTTOM_LEFT],[Z.NEAR_BOTTOM_RIGHT,Z.FAR_BOTTOM_RIGHT],[Z.NEAR_TOP_RIGHT,Z.FAR_TOP_RIGHT],[Z.NEAR_TOP_LEFT,Z.FAR_TOP_LEFT]],function(e){e[e.NEAR_FAR_BOTTOM_LEFT=0]="NEAR_FAR_BOTTOM_LEFT",e[e.NEAR_FAR_BOTTOM_RIGHT=1]="NEAR_FAR_BOTTOM_RIGHT",e[e.NEAR_FAR_TOP_RIGHT=2]="NEAR_FAR_TOP_RIGHT",e[e.NEAR_FAR_TOP_LEFT=3]="NEAR_FAR_TOP_LEFT",e[e.NEAR_BOTTOM=4]="NEAR_BOTTOM",e[e.NEAR_RIGHT=5]="NEAR_RIGHT",e[e.NEAR_TOP=6]="NEAR_TOP",e[e.NEAR_LEFT=7]="NEAR_LEFT",e[e.FAR_BOTTOM=8]="FAR_BOTTOM",e[e.FAR_RIGHT=9]="FAR_RIGHT",e[e.FAR_TOP=10]="FAR_TOP",e[e.FAR_LEFT=11]="FAR_LEFT"}(B||(B={}));const Ja=m(),Ne=m();function nt(){return{direction:m(),up:m()}}function tt(e,n,t,a,r){let i=_e(Ja,e),o=P(i,a);const s=o>0;o=Math.abs(o),o>.99&&(o=Math.abs(P(n,a)),o<.99?(C(i,n),s&&I(i,i,-1)):i=null);let c=0;if(i){I(Ne,a,P(a,i)),ue(i,i,Ne);const u=P(i,r)/(z(i)*z(r));re(Ne,i,r),c=(P(Ne,a)>0?1:-1)*j(ln(u))}const l=j(ln(-P(a,e)/z(e)));return t?(t.heading=c,t.tilt=l,t):{heading:c,tilt:l}}function at(e,n,t,a){ue(Nn,t,n),Fa(a,Oa(n,Nn),e)||e===t||C(e,t)}const Nn=m(),rt=de(0,1,0),it=de(0,0,1),Te=pn(),L=m(),U=m();function ot(e,n,t,a=nt()){const{direction:r,up:i}=a;return Ta(Te,-S(n)),Ra(Te,Te,S(t)),He(r,it,Te),I(r,r,-1),He(i,rt,Te),a}function Ka(e,n,t,a){return tt(n,t,a,it,rt)}function Xa(e,n,t,a){const r=ot(e,t,a),i=m();return I(i,r.direction,-n),fe(i,i,e),{up:r.up,eye:i,heading:t,tilt:a}}function Va(e){return j(e)}function Ya(e){return S(e)}function Qa(e,n,t,a,r){const i=e.renderSpatialReference,o=e.spatialReference??n.spatialReference;return Pe(n,L,i),Pe(n,U,i),L[0]-=t/2,U[0]+=t/2,L[1]-=a/2,U[1]+=a/2,xe(L,i,L,o),xe(U,i,U,o),r?(r.xmin=L[0],r.ymin=L[1],r.xmax=U[0],r.ymax=U[1],r.spatialReference=o):r=new hn(L[0],L[1],U[0],U[1],o),r}function er(e,n){const t=e.frustum,{renderCoordsHelper:a}=e,r=a.getAltitude(n),i=e.spatialReference,o=e.state.camera.eye,s=[],c=t.planes[Yn.FAR];for(let l=0;l<4;l++){const u=t.lines[l];a.intersectInfiniteManifold(Qn(u.origin,u.direction),r,N)||nr(N,t,a,u.endpoint,r),at(N,o,N,c),s.push(_a(N[0],N[1]))}return tr(Za(s,a.extent),a,i)}function nr(e,n,t,a,r){const i=n.lines[B.FAR_LEFT].direction,o=(r-t.getAltitude(a))/i[2];on(e,a,i,o)}function tr(e,n,t){const a=e.map(r=>(x(N,r[0],r[1],0),n.fromRenderCoords(N,N,t),[N[0],N[1]]));return a.length<=2?new cn({spatialReference:t}):(a.push(a[0].slice()),Xn(a)||a.reverse(),new cn({rings:[a],spatialReference:t}))}const N=m(),ar=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:Ka,eyeForCenterWithHeadingTilt:Xa,eyeTiltToLookAtTilt:Ya,headingTiltToDirectionUp:ot,lookAtTiltToEyeTilt:Va,toArea:er,toExtent:Qa},Symbol.toStringTag,{value:"Module"}));function rr(e,n,t){e.worldUpAtPosition(n,zn),ue(Qe,t,n);const a=z(Qe);return a===0?0:ln(P(Qe,zn)/a)}const zn=m(),Qe=m(),st=de(0,0,1),ct=_e(m(),de(1,1,1)),ir=new mn(-180,180),Re=pn(),J=m(),se=m();function lt(e,n,t,a=nt()){re(J,e,st),P(J,J)===0&&re(J,e,ct),$a(Re,-S(n),e),wa(Re,Re,-S(t),J);const{up:r,direction:i}=a;return re(r,J,e),_e(r,r),He(r,r,Re),_e(i,e),Bt(i,i),He(i,i,Re),a}function or(e,n,t,a){const r=J,i=se;return _e(r,e),re(se,r,st),P(se,se)===0&&re(se,r,ct),re(i,se,r),tt(n,t,a,r,i)}function sr(e,n,t,a){const r={eye:m(),up:null,tilt:a,heading:t},i=J;i[0]=e[0],i[1]=e[2],i[2]=-e[1];const o=n,s=S(t),c=S(a),l=Math.sin(s),u=Math.cos(s),p=Math.sin(c),f=Math.cos(c),h=z(i);let d;if(Math.abs(c)<1e-8)d=o+h;else{const be=h/p,Fe=qe(o/be),Ve=Math.PI-c-Fe;d=be*Math.sin(Ve)}const T=f*o,y=o*o*(p*p),A=u*u*y,M=d-T,$=M*M,_=A*(A+$-i[1]*i[1]);if(_<0)return I(r.eye,i,d/h),r.tilt=0,ze(r,e);const k=Math.sqrt(_),V=i[1]*M,Y=A+$;let Q;if(Q=u>0?-k+V:k+V,Math.abs(Y)<1e-8)return h<1e-8?(r.eye[0]=0,r.eye[1]=0,r.eye[2]=o):I(r.eye,i,d/h),r.tilt=0,en(r.eye),ze(r,e);r.eye[1]=Q/Y;const w=l*l*y,ee=p*o,oe=u*ee*r.eye[1],q=r.eye[1]*r.eye[1],G=1-q,H=Math.sqrt(G),ne=A*q+w-2*oe*H*M+G*$;return Math.abs(ne)<1e-8?(I(r.eye,i,d/h),r.tilt=0,en(r.eye),ze(r,e)):(r.eye[0]=(G*(d*i[0]-T*i[0])-ee*H*(i[0]*r.eye[1]*u+i[2]*l))/ne,r.eye[2]=(G*(d*i[2]-T*i[2])-ee*H*(i[2]*r.eye[1]*u-i[0]*l))/ne,I(r.eye,r.eye,d),en(r.eye),ze(r,e))}function en(e){const n=e[1];e[1]=-e[2],e[2]=n}function ze(e,n){const t=lt(n,e.heading,e.tilt);return e.up=t.up,e}function cr(e,n,t){const a=z(n),r=Math.sqrt(t*t+a*a-2*t*a*Math.cos(Math.PI-e)),i=qe(t/(r/Math.sin(e)));return j(e-i)}function lr(e,n,t){const a=S(e),r=z(n);return qe(t/(r/Math.sin(a)))+a}function ur(e,n,t,a,r){let i,o,s,c;const l=n.latitude,u=Ae(e.spatialReference).radius,p=n.longitude,f=Pa(l,t,u)/2;i=p-f,o=p+f;const h=S(l),d=(1+Math.sin(h))/(1-Math.sin(h)),T=(d+1)*Math.tan(a/u/2),y=T*T;function A($){const _=Math.PI/2;return($=Ht.normalize($,-_))>_&&($=Math.PI-$),$}if(s=1.5*Math.PI-2*Math.atan(.5*(T+Math.sqrt(4*d+y))),c=s+a/u,s=A(s),c=A(c),c<s){const $=c;c=s,s=$}if(s=Math.max(j(s),-90),c=Math.min(j(c),90),o=ir.monotonic(i,o),o-i>180){const $=(o-i-180)/2;i+=$,o-=$}const M=e.spatialReference&&e.spatialReference.isGeographic?e.spatialReference:Oe.WGS84;return r?(r.xmin=i,r.ymin=s,r.xmax=o,r.ymax=c,r.spatialReference=M):r=new hn(i,s,o,c,M),e.spatialReference&&e.spatialReference.isWebMercator&&da(r,!1,r),r}function fr(e,n){const t=e.frustum,{renderCoordsHelper:a}=e,r=a.getAltitude(n),i=e.spatialReference,o=a.referenceEllipsoid.radius,s=e.state.camera,c=s.eye,l=1+ve(c,n)/(o+r),u=Math.sqrt(l*l-1),{minCurvature:p,maxCurvature:f,minSamples:h,maxSamples:d}=hr,T=dr(e),y=ya((u-p)/(f-p),0,1),A=Math.round(En(h,d,y)),M=s.aboveGround,$=t.planes[Yn.FAR],_=[],k=On(xn,gr,Sn()),V=On(xn,yr,Sn());za(nn,0,0,0,0);const Y=w=>{};for(let w=0;w<4;w++){const ee=w===B.NEAR_FAR_BOTTOM_RIGHT&&!M||w===B.NEAR_FAR_TOP_LEFT&&M?1-T:0,oe=w===B.NEAR_FAR_BOTTOM_RIGHT&&M||w===B.NEAR_FAR_TOP_LEFT&&!M?T:1,q=t.lines[w],G=t.lines[w===3?0:w+1];for(let H=0;H<A;H++){const ne=H/A,be=w===B.NEAR_FAR_BOTTOM_RIGHT?1-(1-ne)**2:w===B.NEAR_FAR_TOP_LEFT?ne**2:ne,Fe=H===0?0:En(ee,oe,be),Ve=jt(Rr,q.origin,G.origin,Fe),Ct=La(q.direction,G.direction,Fe,Tr);a.intersectManifoldClosestSilhouette(Qn(Ve,Ct),r,E),at(E,c,E,$),_.push(qn(E)),_.length!==0&&Y(vn(_.at(-1),E));const Nt=(bn(k,E)?1:0)|(bn(V,E)?2:0);nn[Nt]=1}}_.length>2&&Y(vn(_[0],_.at(-1)));const Q=mr(Ga(nn)>1?pr(ut(_,k),V):[_],a,i);return new cn({rings:Q,spatialReference:i})}function mr(e,n,t){const a=2*et();return e.map(r=>{const i=[];let o=!1;for(const s of r)n.fromRenderCoords(s,E,t),Math.abs(s[0])<a&&Math.abs(s[1])<a?(i.push([null,E[1]]),i.push([null,E[1]]),o=!0):i.push([E[0],E[1]]);if(o)for(let s=0;s<i.length;s++){const c=i[s];if(c[0]!=null)continue;const l=i[s+1],u=i.at(s===0?-1:s-1);c[0]=u[0],s++;const p=i.at(s===i.length-1?0:s+1);l[0]=p[0]}return i.push(i[0]),Xn(i)||i.reverse(),i})}function pr(e,n){const t=[];for(const a of e)t.push(...ut(a,n));return t}function ut(e,n){const t=[],a=[],r=et();for(let o=0;o<e.length;o++){const s=e[o],c=o===e.length-1?e[0]:e[o+1],l=ba(s,c,$r),u=Ia(n,l.origin,l.vector,Ca.NONE,E);switch(u){case ge.INSIDE:t.push(s);break;case ge.OUTSIDE:a.push(s);break;case ge.INTERSECTS_INSIDE_OUT:case ge.INTERSECTS_OUTSIDE_IN:{const[p,f,h]=u===ge.INTERSECTS_INSIDE_OUT?[1,t,a]:[-1,a,t],d=Na(n),T=on(m(),E,d,p*r),y=on(m(),E,d,p*-r);f.push(s),f.push(T),h.push(y)}}}const i=[];return t.length&&i.push(t),a.length&&i.push(a),i}function dr(e){const{renderCoordsHelper:n,state:{camera:t}}=e,{center:a,eye:r}=t,i=Math.abs(n.getAltitude(a)),o=Math.abs(Math.PI/2-rr(n,a,r));return xa(Gn,n.referenceEllipsoid.radius+i),Ea(Gn,o,t.distance,t.fovY)}const hr={minCurvature:S(5),maxCurvature:S(50),minSamples:1,maxSamples:6},gr=de(1,0,0),yr=de(0,1,0),Tr=m(),Rr=m(),E=m(),Gn=Aa(),$r=Sa(),nn=Ha(),wr=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:or,eyeForCenterWithHeadingTilt:sr,eyeTiltToLookAtTilt:lr,headingTiltToDirectionUp:lt,lookAtTiltToEyeTilt:cr,toArea:fr,toExtent:ur},Symbol.toStringTag,{value:"Module"})),gn=()=>Gt.getLogger("esri.views.3d.support.cameraUtils"),ft=39.37,mt=96,Mr=mt*ft,un=1,_r=8,vr=5,pt=1,xr={heading:0,tilt:0},we=m(),Er=new mn(-20037508342788905e-9,20037508342788905e-9),Ar=new mn(-180,180);var v;function K(e){return e.spatialReference??Oe.WGS84}function X({state:e}){return e.isGlobal?wr:ar}function Vi(e,n,t,a,r){return X(e).headingTiltToDirectionUp(n,t,a,r)}function Se(e,n){if(n==null)return null;const t=e.renderSpatialReference,a=X(e).headingTiltToDirectionUp,r=m();if(!Pe(n.position,r,t))return null;const i=a(r,n.heading,n.tilt);I(i.direction,i.direction,e.state.camera.distance),fe(i.direction,i.direction,r);const o=he(e,r,i.direction,i.up);return o.fov=S(n.fov),o.row=n.layout.row,o.rows=n.layout.rows,o.column=n.layout.column,o.columns=n.layout.columns,o}(function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"})(v||(v={}));const ce=m();function We(e,n,t){const a=e.renderSpatialReference,r=pe(e,n.eye,n.viewForward,n.up,xr);let i=K(e);return xe(n.eye,a,ce,i)||(i=Oe.WGS84,xe(n.eye,a,ce,i)),t==null?t=new Me(new R(ce,i),r.heading,r.tilt,j(n.fov)):(t.position.x=ce[0],t.position.y=ce[1],t.position.z=ce[2],t.position.spatialReference=i,t.heading=r.heading,t.tilt=r.tilt,t.fov=j(n.fov)),t.layout.row=n.row,t.layout.rows=n.rows,t.layout.column=n.column,t.layout.columns=n.columns,t}function Hn(e,n){const{camera:t}=e.state,{unitInMeters:a}=e.renderCoordsHelper;return t.width/2/t.pixelRatio/(mt*ft/(n/=a))/Math.tan(t.fovX/2)}function Or(e,n){const{camera:t}=e.state,{unitInMeters:a}=e.renderCoordsHelper,r=n*Math.tan(t.fovX/2),i=t.width/2/t.pixelRatio;return Mr/(i/r)*a}function Sr(e,n,t,a){const r=a.levelAtScale(n),i=dt(pe(e,t.eye,t.viewForward,t.up).tilt),o=Math.max(r-i,0);return a.scaleAtLevel(o)}function Pn(e,n,t){const a=t.levelAtScale(e),r=dt(n);return t.scaleAtLevel(a+r)}function dt(e){return 2*((e>90?180-e:e)/90)**2}function yn(e,n,t){var o,s,c,l;const a=(o=e.basemapTerrain)==null?void 0:o.tilingScheme;if(!a)return 0;if(t==null){const u=(c=(s=e.pointsOfInterest)==null?void 0:s.cameraOnSurface)==null?void 0:c.renderLocation;t=(u&&((l=e.renderCoordsHelper)==null?void 0:l.getAltitude(u)))??0}const r=Ae(e.spatialReference).radius,i=e.state.viewingMode===dn.Local?n.eye[2]:z(n.eye)-r;return Sr(e,Or(e,Math.abs(i-t)),n,a)}function Je(e,n,t){const a=Se(e,n);return a?yn(e,a,t):0}const br=1,Fr=100;function Tn(e,n,t,a){var l,u,p,f;if(n===0)return 0;const r=ve(t.eye,a),i=(l=e.basemapTerrain)==null?void 0:l.tilingScheme;if(!i)return gn().error("#scaleToTargetDistance()","Cannot compute distance from scale without a tiling scheme"),r;const o=(p=(u=e.pointsOfInterest)==null?void 0:u.cameraOnSurface)==null?void 0:p.renderLocation,s=(o&&((f=e.renderCoordsHelper)==null?void 0:f.getAltitude(o)))??0;let c=r;if(e.state.viewingMode===dn.Local){const h=pe(e,t.eye,t.viewForward,t.up).tilt,d=Hn(e,Pn(n,h,i))-Math.abs(t.eye[2]-s),T=t.eye[2]<s,y=d/Math.cos(S(h));c=T?c-y:c+y}else{let h=1/0,d=0;const T=pe(e,t.eye,t.viewForward,t.up);let y=Ue(e,T.heading,T.tilt,a,r,v.ADJUST);if(!y)return c;const A=Ae(e.spatialReference).radius,M=z(t.eye)<A+s;for(;h>br&&d<Fr;){const $=z(y.eye),_=M?180-y.tilt:y.tilt,k=S(_),V=Math.sin(k)*$,Y=Math.cos(k)*$,Q=Hn(e,Pn(n,y.tilt,i)),w=M?A+s-Q:A+s+Q,ee=qe(V/w),oe=Math.cos(ee)*w-Y,q=ve(y.eye,a);c=M?q-oe:q+oe,y=Ue(e,T.heading,T.tilt,a,c,v.ADJUST);const G=$n(e,y,j(t.fov));if(!y||!G)return c;const H=Je(e,G,s);h=Math.abs(n-H),++d}}return c}async function Ir(e,n,t,a,r,i){const o=await me(e,n,e.state.camera.distance,a,r,i);O(i);const s=Se(e,o);if(!s)return a;const c=m();return e.renderCoordsHelper.toRenderCoords(n,c),me(e,n,Tn(e,t,s,c),a,r,i)}function Dn(e,n,t,a,r,i){return $n(e,Ue(e,a.heading,a.tilt,n,t,r),a.fov,i)}async function me(e,n,t,a,r,i){const o=await gt(e,a.heading,a.tilt,n,t,r,i);return O(i),At(e,o,a.fov,i)}function pe(e,n,t,a,r){return X(e).directionToHeadingTilt(n,t,a,r)}function ht(e,n){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(n,we,e.spatialReference)&&e.elevationProvider&&(Ze(e.elevationProvider,we)??0)>we[2]-pt)}async function Cr(e,n,t){if(ht(e,n))return!0;const{elevationProvider:a,spatialReference:r,renderCoordsHelper:i}=e;if(a==null||!i.fromRenderCoords(n,we,r))return!1;const[o,s,c]=we,l=await a.queryElevation(o,s,c,r,"ground",t)??0;return O(t),l>c-pt}async function Nr(e,n,t){const a=m();if(n==null)return C(a,e.state.camera.center);if(n instanceof R){const{renderSpatialReference:r,basemapTerrain:i,elevationProvider:o}=e,s=n.spatialReference;if(await De(n,a,r,0,{signal:t}),O(t),n.z==null&&i!=null&&o!=null){const c=await o.queryElevation(n.x,n.y,n.z??0,s,"ground",t);O(t),c!=null&&e.renderCoordsHelper.setAltitude(a,c)}return a}return C(a,n)}function zr(e,n){const t=m();if(n==null)return C(t,e.state.camera.center);if(n instanceof R){if(!Pe(n,t,e.renderSpatialReference))return null;const{basemapTerrain:a,elevationProvider:r}=e;if(n.z==null&&a!=null&&r!=null){const i=Ze(r,n);i!=null&&e.renderCoordsHelper.setAltitude(t,i)}return t}return C(t,n)}function Ue(e,n,t,a,r,i){return yt(e,n,t,a instanceof R?a:null,zr(e,a),r,i)}async function gt(e,n,t,a,r,i,o){const s=a instanceof R?a:null,c=await Nr(e,a,o);return O(o),Tt(e,n,t,s,c,r,i,o)}function yt(e,n,t,a,r,i,o){if(r==null||!a&&(a=new R({spatialReference:K(e)}),!Ee(r,e.renderSpatialReference,a)))return null;const s=Rt(e,n,t,r,i,o);if($t(e,t,o)&&ht(e,s.eye)){const{tilt:c,mode:l}=wt(e,t,r,i);return yt(e,n,c,a,r,i,l)}return Mt(s,r)}async function Tt(e,n,t,a,r,i,o,s){a||(a=new R({spatialReference:K(e)}),await Jn(r,e.renderSpatialReference,a,{signal:s})||(a=null)),O(s);const c=Rt(e,n,t,r,i,o);if($t(e,t,o)&&await Cr(e,c.eye,s)){O(s);const{tilt:l,mode:u}=wt(e,t,r,i);return Tt(e,n,l,a,r,i,u,s)}return Mt(c,r)}function Rt(e,n,t,a,r,i){const o=Pr(e,n,t,a,r=Math.max(r,e.state.constraints.minimumPoiDistance),i);return(0,X(e).eyeForCenterWithHeadingTilt)(a,r,o.heading,o.tilt)}function $t(e,n,t){const a=e.map.ground.navigationConstraint;return t===v.ADJUST&&e.state.isGlobal&&n>0&&(a==null||a.type==="stay-above")}function wt(e,n,t,a){const r=Et(e,t,a,Lr(e,a,n,t));return{tilt:r,mode:n-r<1?v.LOCKED:v.ADJUST}}function Mt(e,n){return{...e,center:qn(n)}}function _t(e,n){const{state:t,spatialReference:a}=e,r=n.spatialReference;return t.isGlobal&&Ua(r,dn.Global)||t.isLocal&&a.equals(r)}function vt(e,n){let t,a,r;if(e.state.isGlobal){const u=new R(n.xmin,n.ymin,n.spatialReference),p=new R(n.xmax,n.ymax,n.spatialReference),f=n.spatialReference.isGeographic?Ar:Er;t=new R({x:f.center(u.x,p.x),y:(p.y+u.y)/2,z:n.zmax!=null&&n.zmin!=null?(n.zmax+n.zmin)/2:void 0,spatialReference:n.spatialReference});const h=Ae(n.spatialReference),d=Da(t,u,p);a=d.lon,r=d.lat,f.diff(u.x,p.x)>f.range/2&&(a+=h.halfCircumference),a=Math.min(a,h.halfCircumference),r=Math.min(r,h.halfCircumference)}else{const u=e.renderSpatialReference??n.spatialReference;u.equals(n.spatialReference)||(n=Zn(n,u)),a=n.xmax-n.xmin,r=n.ymax-n.ymin;const p=n.zmax!=null&&n.zmin!=null?(n.zmax+n.zmin)/2:void 0;t=new R({x:n.xmin+.5*a,y:n.ymin+.5*r,z:p,spatialReference:u})}const i=n.zmax!=null&&n.zmin!=null?n.zmax-n.zmin:0,o=e.state.camera,s=1/Math.tan(o.fovX/2),c=1/Math.tan(o.fovY/2),l=1/Math.tan(o.fov/2);return{center:t,distance:Math.max(.5*a*s,.5*r*c,.5*i*l)/un}}async function xt(e,n,t,a,r,i){const o=_t(e,n)?n:await ie(n,e.spatialReference,{signal:i});O(i);const{center:s,distance:c}=vt(e,o),l=await gt(e,t,a,s,c,r,i);return O(i),At(e,l,e.camera.fov,i)}function Gr(e,n,t,a,r,i){let o;try{o=_t(e,n)?n:Zn(n,e.spatialReference)}catch{return null}const{center:s,distance:c}=vt(e,o),l=Ue(e,t,a,s,c,r);return l==null?null:$n(e,l,e.camera.fov,i)}function Yi(e,n,t){const a=e.renderSpatialReference,r=new R({spatialReference:K(e)});if(!Ee(t,a,r))return null;const i=Math.tan(n.fovX/2),o=Math.tan(n.fovY/2),s=kt(n.eye,t),c=2*s*i*un,l=2*s*o*un;return X(e).toExtent(e,r,c,l)}function Qi(e,n){return X(e).toArea(e,n)}function Hr(e,n,t){const a=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(t/a)/Math.LN2>_r)return!0;const r=n,i=e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;return ve(r,i)/(Math.tan(.5*e.state.camera.fov)*a)>vr}function Pr(e,n,t,a,r,i){let o=0;return i===v.ADJUST&&Hr(e,a,r)?(n=0,o=Dr(e,r,t,a)):o=Rn(e,a,r,t),o=e.state.constraints.clampTilt(r,o),{heading:n,tilt:t=Et(e,a,r,o)}}const Be=.7;function Dr(e,n,t,a){const r=Rn(e,a,n,t);if(!e.state.constraints.tilt)return r;const i=e.state.constraints.tilt(n);i.max=Math.min(i.max,.5*Math.PI);const o=i.min*(1-Be)+i.max*Be;return Math.min(r,o)}function Lr(e,n,t,a){let r=Rn(e,a,n,t);if(!e.state.constraints.tilt)return r;const i=e.state.constraints.tilt(n);return r=Math.min(r,.5*Math.PI),i.min*(1-Be)+r*Be}function Et(e,n,t,a){return X(e).lookAtTiltToEyeTilt(a,n,t)}function Rn(e,n,t,a){return X(e).eyeTiltToLookAtTilt(a,n,t)}function $n(e,n,t,a){if(n==null)return null;const r=e.renderSpatialReference,i=new R({spatialReference:K(e)});return Ee(n.eye,r,i)?(a??(a=new Me),a.position=i,a.heading=n.heading,a.tilt=n.tilt,a.fov=t,a):null}async function At(e,n,t,a){const r=e.renderSpatialReference,i=new R({spatialReference:K(e)});return await Jn(n.eye,r,i,{signal:a}),O(a),new Me(i,n.heading,n.tilt,t)}function eo(e,n){var a;const t=(a=e.basemapTerrain)==null?void 0:a.tilingScheme;if(t)return t.levelAtScale(n);gn().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Ur(e,n){var a;const t=(a=e.basemapTerrain)==null?void 0:a.tilingScheme;if(t)return t.scaleAtLevel(n);gn().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}const Br=.66;function Ot(e){return 360-jn.normalize(e)}function Ke(e){return jn.normalize(360-e)}function jr(e,n,t){const a=n.camera;if(a!=null)return kr(a,K(e));const{targetGeometry:r}=n;if(r==null)return null;const{camera:i,mode:o}=bt(e,n.rotation,t);if(r.type==="point")return Zr(e,n,r,i,o);const s=r.extent;return s==null?null:Gr(e,s,i.heading,i.tilt,o)}async function St(e,n,t,a){const r=n.camera;if(r!=null)return qr(r,K(e),a);const{targetGeometry:i}=n;if(i==null)throw new Error("Viewpoint has no targetGeometry!");const{camera:o,mode:s}=bt(e,n.rotation,t);if(i.type==="point")return Wr(e,n,i,o,s,a);const c=i.extent;if(c==null)throw new Error("Target geometry has no extent!");return xt(e,c,o.heading,o.tilt,s,a)}function kr(e,n){const t=e.position;let a;try{a=Wn(t,n)}catch{return null}if(!a)return null;const r=e.clone();return r.position=a.clone(),r}async function qr(e,n,t){const a=e.position,r=await ie(a,n,{signal:t});O(t);const i=e.clone();return i.position=r.clone(),i}function bt(e,n,t){const a=We(e,e.state.camera);let r=v.ADJUST;return n!=null&&(a.heading=Ot(n),r=v.LOCKED),t!=null&&(a.tilt=t),{camera:a,mode:r}}function Zr(e,n,t,a,r){const i=e.spatialReference;let o;try{o=Wn(t.clone(),i)}catch{return null}if(!o)return null;let s=e.state.camera.distance;const c=Dn(e,o,s,a,r),l=n.scale!=null?Se(e,c):null;if(l){const u=m();return e.renderCoordsHelper.toRenderCoords(o,u),s=Tn(e,n.scale,l,u),Dn(e,o,s,a,r)}return c}async function Wr(e,n,t,a,r,i){const o=e.spatialReference,s=await ie(t.clone(),o,{signal:i});O(i);let c=e.state.camera.distance;const l=await me(e,s,c,a,r,i);O(i);const u=n.scale!=null?Se(e,l):null;if(u){const p=m();return e.renderCoordsHelper.toRenderCoords(s,p),c=Tn(e,n.scale,u,p),me(e,s,c,a,r,i)}return l}function Jr(e,n,t=null){return t==null&&(t=new rn),Mn(e,null,n.clone(),t)}async function Kr(e,n,t){const a=ii(e,n);if(!a)throw new Bn("viewpointutils-create:no-target","Missing target for creating viewpoint");const r=new Me({fov:e.camera.fov}),i=new rn({camera:r});if(a.target instanceof rn)return ae(await Yr(e,a.target,a,t,i));if(a.target instanceof Me)return ae(await It(e,a.target,t,i));const o=a.scale!=null||a.zoom!=null;if(a.target instanceof hn){const l=a.target.xmin===a.target.xmax||a.target.ymin===a.target.ymax;return ae(o||l?await fn(e,a,a.target.center,r,t,i):await ti(e,a,a.target,r,t,i))}const s=new si,c=o?Xr(e,a):void 0;if(await Ft(e,a.target,c,s,t),isFinite(s.boundingBox[0])){let l;if(Jt(s.boundingBox,g),b.x=g[0],b.y=g[1],b.z=g[2],b.spatialReference=e.spatialReference,isFinite(b.z)&&s.hasZ?l=Kt(s.boundingBox):(b.z=void 0,l=aa(Xt(s.boundingBox,ci))),o||l)return ae(await fn(e,a,b,r,t,i));const u=oi(e,s.screenSpaceObjects);return ae(await ri(e,a,b,s.boundingBox,u,r,t,i))}return a.position?ae(await ei(e,a,r,i,t)):ae(await ni(e,a,r,t,i))}function wn(e,n){return n.scale==null&&n.zoom!=null?Ur(e,n.zoom):n.scale}function Xr(e,n){const t=wn(e,n);return t?pa(t):void 0}function Xe(e,n){let t=!1;return n.heading!=null?(e.heading=n.heading,t=!0):n.rotation!=null&&(e.heading=Ot(n.rotation),t=!0),n.tilt!=null&&(e.tilt=n.tilt,t=!0),n.fov!=null&&(e.fov=n.fov),t}function Mn(e,n,t,a){const r=e.spatialReference||Oe.WGS84;if(n??(n=Se(e,t)),n==null)return a;const i=new R({spatialReference:r});return Ee(n.center,e.renderSpatialReference,i)&&(a.targetGeometry=i,a.scale=yn(e,n),a.rotation=Ke(t.heading),a.camera=t),a}async function je(e,n,t,a){var p;const r=()=>new Bn("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!n)throw r();n.type==="mesh"&&(n=n.extent);const i=e.basemapTerrain.spatialReference;if(!n.hasZ&&e.basemapTerrain){let f;switch(n.type){case"point":f=n;break;case"multipoint":case"polyline":f=(p=n.extent)==null?void 0:p.center;break;case"extent":f=n.center;break;case"polygon":f=n.centroid}f!=null&&i&&e.elevationProvider?(f=await ie(f,i,{signal:a}),g[2]=Ze(e.elevationProvider,f)??0):g[2]=0}const o=li[n.type],s=new Array;if(o(n,n.hasZ?f=>{s.push([f[0],f[1],f[2]])}:f=>{s.push([f[0],f[1]])},g),s.length===0)throw r();const c=n.spatialReference,l=e.spatialReference,u=await ie(new ra({spatialReference:c,hasZ:n.hasZ,hasM:!1,points:s}),l,{signal:a});if(n.hasZ&&(t.hasZ=!0),n.hasZ)for(const[f,h,d]of u.points)g[0]=f,g[1]=h,g[2]=d,sn(t.boundingBox,g);else for(const[f,h]of u.points)g[0]=f,g[1]=h,sn(t.boundingBox,g)}async function Vr(e,n,t,a,r){const i=await _n(e.whenViewForGraphic(n));if(i.ok===!1||i.value==null||!("whenGraphicBounds"in i.value))return void await je(e,n.geometry,a,r);const o=i.value,s=await _n(o.whenGraphicBounds(n,{minDemResolution:t}));if(s.ok===!1||!s.value)return void await je(e,n.geometry,a,r);const{screenSpaceObjects:c,boundingBox:l}=s.value;Vt(a.boundingBox,l),c&&c.forEach(u=>{a.screenSpaceObjects.push(u)}),isFinite(l[2])&&(a.hasZ=!0)}async function Ft(e,n,t,a,r){var i;if(Array.isArray(n)&&n.length===2){const o=n[0],s=n[1];if(typeof o=="number"&&typeof s=="number")return b.x=o,b.y=s,b.z=void 0,b.spatialReference=(i=e.spatialReference)!=null&&i.isGeographic?e.spatialReference:Oe.WGS84,void await je(e,b,a,r)}n&&"map"in n&&typeof n.map=="function"?await Promise.allSettled(n.map(o=>Ft(e,o,t,a,r))):n instanceof ha?await je(e,n,a,r):n instanceof zt&&await Vr(e,n,t,a,r)}async function Yr(e,n,t,a,r){if(n.camera)return It(e,n.camera,a,r);r.scale=n.scale,r.rotation=n.rotation,r.targetGeometry=n.targetGeometry!=null?n.targetGeometry.clone():null,r.camera=null,t.heading!=null?r.rotation=Ke(t.heading):t.rotation!=null&&(r.rotation=t.rotation);const i=wn(e,t);return i!=null&&(r.scale=i),r.camera=await St(e,r,t.tilt,a),r}async function It(e,n,t,a){const r=e.spatialReference,i=await ie(n.position,r,{signal:t}),o=n.clone();return o.position=i,Mn(e,null,o,a)}async function Qr(e,n,t,a,r,i,o){const s=e.renderSpatialReference;return await De(n,Un,s,0,{signal:o}),await De(t,tn,s,0,{signal:o}),i.targetGeometry=new R(n),r.position=new R(t),ue(ke,Un,tn),pe(e,tn,ke,a.up,r),i.scale=Je(e,r),i.rotation=Ke(r.heading),i.camera=r,i}async function fn(e,n,t,a,r,i){i.targetGeometry=t.clone();const o=he(e);if(n.position)return Qr(e,i.targetGeometry,n.position,o,a,i,r);if(n.zoomFactor){const c=o.distance/n.zoomFactor,l=I(g,o.viewForward,-c);o.eye=fe(g,o.center,l),i.scale=yn(e,o)}We(e,o,a);const s=Xe(a,n)?v.LOCKED:v.ADJUST;if(!n.zoomFactor){const c=wn(e,n);if(c==null){await De(i.targetGeometry,g,e.renderSpatialReference,0,{signal:r});const l=Vn(o.frustum,g)?ve(o.eye,g):o.distance;i.camera=await me(e,i.targetGeometry,l,a,s),i.scale=Je(e,i.camera)}else i.scale=c,i.camera=await Ir(e,i.targetGeometry,i.scale,a,s,r)}return i}async function ei(e,n,t,a,r){const i=he(e);C(ke,i.viewForward),pe(e,i.eye,ke,i.up,an);const o=e.spatialReference,{position:s}=n;if(s){const c=await ie(s,o,{signal:r});t.position=c}else t.position=new R;return t.heading=n.heading!=null?n.heading:an.heading,t.tilt=n.tilt!=null?n.tilt:an.tilt,Mn(e,null,t,a)}async function ni(e,n,t,a,r){if(n.heading!=null||n.rotation!=null||n.scale!=null||n.tilt!=null||n.zoom!=null||n.zoomFactor!=null){const i=he(e),{spatialReference:o,renderSpatialReference:s}=e,c=new R({spatialReference:o});return Ee(i.center,s,c)?fn(e,n,c,t,a,r):r}return r.scale=e.scale,r.camera=e.camera.clone(),Xe(r.camera,n),r}async function ti(e,n,t,a,r,i){i.targetGeometry=t.clone();const o=he(e);We(e,o,a);const s=Xe(a,n)?v.LOCKED:v.ADJUST;return i.camera=await xt(e,t,a.heading,a.tilt,s,r),i}function ai(e,n,t,a,r){let i=0;t.z!=null?i=t.z:e.basemapTerrain&&e.elevationProvider&&(i=Ze(e.elevationProvider,t)),x(g,t.x,t.y,i),Zt(e.spatialReference,g,Ln,e.renderSpatialReference),Pt(Ge,Ln),Dt(Ge,Ge),Kn($e);const o=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let d=0;d<o.length;d++){const T=o[d];let y=a[T[2]];isFinite(y)||(y=i),x(g,a[T[0]],a[T[1]],y),xe(g,e.spatialReference,g,e.renderSpatialReference),sn($e,qt(g,g,Ge))}const s=Yt($e),c=Qt($e),l=ea($e),u=1/Math.tan(n.fovX/2),p=1/Math.tan(n.fovY/2),f=.5*Math.sqrt(s*s+l*l)*Math.max(p,u)+.5*c,h=.5*c*p+.5*Math.max(s,l);return Math.max(f,h)/r}async function ri(e,n,t,a,r,i,o,s){s.targetGeometry=t.clone();const c=he(e),l=ai(e,c,t,a,r);We(e,c,i);const u=Xe(i,n)?v.LOCKED:v.ADJUST;return s.camera=await me(e,s.targetGeometry,l,i,u,o),s.scale=Je(e,s.camera),s}function ii(e,n){if(!n||!e.spatialReference)return null;const t={target:void 0};return"declaredClass"in n||Array.isArray(n)?t.target=n:(Object.assign(t,n),!t.target&&"center"in n&&n.center&&(t.target=n.center)),t}function ae(e){return(e==null?void 0:e.camera)!=null&&(e.rotation=Ke(e.camera.heading)),e}function oi(e,n){const t=Br;if(!n.length)return t;let a=Number.NEGATIVE_INFINITY;for(let r=0;r<n.length;r++){const i=n[r].screenSpaceBoundingRect;a=Math.max(a,Math.abs(i[0]),Math.abs(i[1]),Math.abs(i[2]),Math.abs(i[3]))}return t-a/Math.min(e.width,e.height)*2}class si{constructor(){this.hasZ=!1,this.boundingBox=Kn(),this.screenSpaceObjects=new Array}}const g=m(),Ln=pn(),Ge=Lt(),$e=Wt(),ci=ta(),ke=m(),tn=m(),Un=m(),an={heading:0,tilt:0},b=new R,li={point(e,n,t){t[0]=e.x,t[1]=e.y,e.z!=null&&(t[2]=e.z),n(t)},polygon(e,n,t){const a=e.hasZ;for(let r=0;r<e.rings.length;r++){const i=e.rings[r];for(let o=0;o<i.length;o++)t[0]=i[o][0],t[1]=i[o][1],a&&(t[2]=i[o][2]),n(t)}},polyline(e,n,t){const a=e.hasZ;for(let r=0;r<e.paths.length;r++){const i=e.paths[r];for(let o=0;o<i.length;o++)t[0]=i[o][0],t[1]=i[o][1],a&&(t[2]=i[o][2]),n(t)}},multipoint(e,n,t){const a=e.points,r=e.hasZ;for(let i=0;i<a.length;i++)t[0]=a[i][0],t[1]=a[i][1],r&&(t[2]=a[i][2]),n(t)},extent(e,n,t){e.zmin!=null&&e.zmax!=null?(n(x(t,e.xmin,e.ymin,e.zmin)),n(x(t,e.xmax,e.ymin,e.zmin)),n(x(t,e.xmin,e.ymax,e.zmin)),n(x(t,e.xmax,e.ymax,e.zmin)),n(x(t,e.xmin,e.ymin,e.zmax)),n(x(t,e.xmax,e.ymin,e.zmax)),n(x(t,e.xmin,e.ymax,e.zmax)),n(x(t,e.xmax,e.ymax,e.zmax))):(n(x(t,e.xmin,e.ymin,t[2])),n(x(t,e.xmax,e.ymin,t[2])),n(x(t,e.xmin,e.ymax,t[2])),n(x(t,e.xmax,e.ymax,t[2])))}},no=Object.freeze(Object.defineProperty({__proto__:null,create:Kr,fromCamera:Jr,toCameraAsync:St,toCameraSync:jr},Symbol.toStringTag,{value:"Module"}));export{Or as $,Qi as A,We as B,Gr as C,eo as G,Ur as I,Se as N,Cn as O,v as X,Vi as Y,Sr as _,Jr as a,Ue as b,rr as c,Kr as d,Tn as e,Ba as f,he as g,nt as h,jr as l,Ki as u,no as v,Yi as z};
