import{X as v,O as $}from"./subclass-BR3PhgZG.js";import{O as M}from"./quat-ChS85qAG.js";import{e as d}from"./quatf64-BrpT0VRp.js";import{K as g}from"./mathUtils-ClvKsMak.js";import{t as c,n as h}from"./vec3f32-Cw9Q6TO_.js";import{f as I}from"./Point-TlcsOcXV.js";import{n as y}from"./projectBuffer-iyGwL2dv.js";import{u as w,c as l,i as O,f as S}from"./PointCloudWorkerUtil-CVRnvUqm.js";import{I as x}from"./orientedBoundingBox-WyW1LZfF.js";import"./mat3f64-BBpwCtoL.js";import"./vec42-B1mBkh1w.js";import"./Evented-CXIxDjmW.js";import"./Accessor-D6mNnsWy.js";import"./jsonMap-DCC6W5ex.js";import"./writer-3zufXUNV.js";import"./assets-BNizZMOZ.js";import"./index-BVncS3aY.js";import"./geodesicConstants-kj1AtlGg.js";import"./PointCloudUniqueValueRenderer-CrJCBPy2.js";import"./enumeration--HlxOQ_N.js";import"./ColorStop-DEfc5Idt.js";import"./Color-DDUWtbqR.js";import"./colorUtils-CS9vdHXB.js";import"./I3SBinaryReader-CtwiVPE4.js";import"./VertexAttribute-BnAa5VW0.js";import"./mat3-DRqs2t5W.js";import"./mat4f64-Dk4dwAN8.js";import"./vec4f64-CBQL1T0x.js";import"./spatialReferenceEllipsoidUtils-DuE2W35w.js";import"./computeTranslationToOriginAndRotation-CFxYfzBj.js";import"./mat4-ybYUU6jq.js";import"./plane-Bz78OrLf.js";import"./vec2f64-Diu2Kaa8.js";import"./mathUtils-kvswLROa.js";import"./ViewingMode-Dodu7ZZk.js";class F{transform(t){const r=this._transform(t),o=[r.points.buffer,r.rgb.buffer];r.pointIdFilterMap!=null&&o.push(r.pointIdFilterMap.buffer);for(const f of r.attributes)"buffer"in f.values&&v(f.values.buffer)&&f.values.buffer!==r.rgb.buffer&&o.push(f.values.buffer);return Promise.resolve({result:r,transferList:o})}_transform(t){const r=w(t.schema,t.geometryBuffer);let o=r.length/3,f=null;const n=new Array,e=l(t.primaryAttributeData,r,o);t.primaryAttributeData!=null&&e&&n.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:e});const m=l(t.modulationAttributeData,r,o);t.modulationAttributeData!=null&&m&&n.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:m});let a=O(t.rendererInfo,e,m,o);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const s=t.filterAttributesData.filter($).map(i=>{const D=l(i,r,o),b={attributeInfo:i.attributeInfo,values:D};return n.push(b),b});f=new Uint32Array(o),o=S(r,a,f,t.filterInfo,s)}for(const s of t.userAttributesData){const i=l(s,r,o);n.push({attributeInfo:s.attributeInfo,values:i})}3*o<a.length&&(a=new Uint8Array(a.buffer.slice(0,3*o))),E(r,o,t.elevationOffset);const p=z(r,o,x.fromData(t.obbData),I.fromJSON(t.inSR),I.fromJSON(t.outSR));return{obbData:t.obbData,points:p,rgb:a,attributes:n,pointIdFilterMap:f}}}function z(u,t,r,o,f){if(!y(u,o,0,u,f,0,t))throw new Error("Can't reproject");const n=c(r.center),e=h(),m=h(),a=c(r.halfSize);M(A,r.quaternion);const p=new Float32Array(3*t);for(let s=0;s<t;s++){let i=3*s;e[0]=u[i]-n[0],e[1]=u[i+1]-n[1],e[2]=u[i+2]-n[2],g(m,e,A),a[0]=Math.max(a[0],Math.abs(m[0])),a[1]=Math.max(a[1],Math.abs(m[1])),a[2]=Math.max(a[2],Math.abs(m[2])),p[i++]=e[0],p[i++]=e[1],p[i]=e[2]}return r.halfSize=a,p}function E(u,t,r){if(r!==0)for(let o=0;o<t;o++)u[3*o+2]+=r}const A=d();function bt(){return new F}export{bt as default};
