import{i as F,l as G,j as A,k as L}from"./Accessor-BmwT4B0c.js";import{d as M}from"./reactiveUtils-XM7cS2OP.js";import{a as N}from"./dehydratedFeatureComparison-j4L0peJx.js";import{x as j}from"./hydratedFeatures-CNHxsqRS.js";import{j as D}from"./elevationInfoUtils-D26wVF2d.js";import{w as q}from"./dragEventPipeline-Dj33NxJd.js";import{e as B}from"./SnappingContext-lR2hMWGP.js";import{F as J,g as K}from"./Scheduler-i_u8qdlN.js";function rn({predicate:n=()=>!0,snappingManager:e,snappingContext:o,updatingHandles:l,useZ:t=!0}){const r=new q;if(e==null)return{snappingStep:[I,r],cancelSnapping:I};let p,u=null,a=null,c=null;const f=()=>{u=F(u),e.doneSnapping(),a==null||a.frameTask.remove(),a=null,p=G(p),c=null},g=Q(e,t,r);let d=null,s=null,Z=null;return{snappingStep:[i=>{if(!n(i))return i;const{action:P}=i;if(P==="start"){const{info:x}=i,S=R(e.view);if(a=V(o,i,S),a.context.selfSnappingZ=null,!t&&x!=null){const m=X(o.coordinateHelper,x.handle.component);m!=null&&(a.context.selfSnappingZ={value:m,elevationInfo:o.elevationInfo??D})}}if(a!=null){const{context:x,originalScenePos:S,originalPos:m}=a,{mapEnd:T,mapStart:k,scenePoints:E}=i,v=$(m,y(T,k)),w=y(k,m),H={...i,action:"update"},O=a.context,h=W(S,E),z=e.update({point:v,scenePoint:h,context:x});if(Z=z,C(T,z,w,t),d=v,s=h,P!=="end"){const{frameTask:U}=a;u==null&&(u=new AbortController),c=b=>{l.addPromise(A(g({frameTask:U,event:H,context:O,point:v,scenePoint:h,delta:w,getLastState:()=>({point:d,scenePoint:s,updatePoint:b.forceUpdate?null:Z})},u.signal)))},c({forceUpdate:!1}),p==null&&(p=M(()=>e.options.effectiveEnabled,()=>c==null?void 0:c({forceUpdate:!0})))}}return P==="end"&&f(),i},r],cancelSnapping:i=>(f(),i)}}function Q(n,e,o){return L(async({frameTask:l,point:t,scenePoint:r,context:p,event:u,delta:a,getLastState:c},f)=>{const g=await l.schedule(()=>n.snap({point:t,scenePoint:r,context:p,signal:f}),f);if(g.valid){let d=await l.schedule(()=>g.apply(),f);const s=c();s.point!=null&&t!==s.point&&(d=n.update({point:s.point,scenePoint:s.scenePoint,context:p})),s.updatePoint!=null&&N(d,s.updatePoint)||(C(u.mapEnd,d,a,e),o.execute(u))}})}function R(n){return n.type==="3d"?n.resourceController.scheduler.registerTask(K.SNAPPING):J}function V(n,e,o){return{context:new B({editGeometryOperations:n.editGeometryOperations,elevationInfo:n.elevationInfo,pointer:n.pointer,vertexHandle:e.info!=null?e.info.handle:null,excludeFeature:n.excludeFeature,feature:n.feature,visualizer:n.visualizer}),originalPos:e.snapOrigin!=null?n.coordinateHelper.vectorToDehydratedPoint(e.snapOrigin):e.mapStart,originalScenePos:e.scenePoints!=null?e.scenePoints.sceneStart:null,frameTask:o}}function $(n,[e,o,l]){const t=j(n);return t.x+=e,t.y+=o,t.hasZ&&(t.z+=l),t}function W(n,e){return n==null||e==null?null:$(n,y(e.sceneEnd,e.sceneStart))}function y(n,e){const o=n.hasZ&&e.hasZ?n.z-e.z:0;return[n.x-e.x,n.y-e.y,o]}function C(n,e,[o,l,t],r){n.x=e.x+o,n.y=e.y+l,r&&n.hasZ&&e.hasZ&&(n.z=e.z+t)}function X(n,e){if(!n.hasZ())return null;const o=e.vertices;let l=null;for(const t of o){const r=n.getZ(t.pos);if(l!=null&&r!=null&&Math.abs(r-l)>1e-6)return null;l==null&&(l=r)}return l}function I(n){return n}export{rn as f};
