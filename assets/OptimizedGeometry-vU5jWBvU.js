let l=class o{constructor(t=[],e=[],s=!1){this.lengths=t??[],this.coords=e??[],this.hasIndeterminateRingOrder=s}static fromJSON(t){return new o(t.lengths,t.coords,t.hasIndeterminateRingOrder)}static fromRect(t){const[e,s,r,n]=t,h=r-e,i=n-s;return new o([5],[e,s,h,0,0,i,-h,0,0,-i])}get isPoint(){return this.lengths.length===0}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((t,e)=>t+e)}forEachVertex(t){let e=0;this.lengths.length||t(this.coords[0],this.coords[1]);for(let s=0;s<this.lengths.length;s++){const r=this.lengths[s];for(let n=0;n<r;n++)t(this.coords[2*(n+e)],this.coords[2*(n+e)+1]);e+=r}}deltaDecode(){const t=this.clone(),{coords:e,lengths:s}=t;let r=0;for(const n of s){for(let h=1;h<n;h++)e[2*(r+h)]+=e[2*(r+h)-2],e[2*(r+h)+1]+=e[2*(r+h)-1];r+=n}return t}clone(t){if(this.lengths.length===0)return new o([],[this.coords[0],this.coords[1]]);const e=(this.lengths.length===0?1:this.lengths.reduce((r,n)=>r+n))*2,s=this.coords.slice(0,e);return t?(t.set(s),new o(this.lengths,t,this.hasIndeterminateRingOrder)):new o(Array.from(this.lengths),Array.from(s),this.hasIndeterminateRingOrder)}};export{l as e};
