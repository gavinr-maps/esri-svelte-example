import{u as m,m as y,i as F,T as g,c as w,h as $,l as b,a as E,p as v,b as A,x as M,y as T,o as z,d as x,g as B,j as C,V as L,q as U,A as k,L as H,B as I,O as G,w as S,E as j,F as q,I as J,U as K,M as N,S as P,k as Q,v as R,z as W,C as X,D as Y,G as Z,H as tt}from"./BufferView-0osDbyWD.js";import{e as p}from"./types-D0PSWh4d.js";import{n as et}from"./vec2f64-Dy6m9Nrb.js";import{z as _}from"./vec42-YcqnINSP.js";import{n as st}from"./vec4f64-o2zAXfmz.js";const u=st();class it{constructor(t){this.message=t}toString(){return`AssertException: ${this.message}`}}function O(s,t="Assertion"){if(!s){const e=new Error(t).stack;throw new it(`${t} at ${e}`)}}function at(s,t){s||(t=t||"",console.warn("Verify failed: "+t+`
`+new Error("verify").stack))}function lt(s,t,e,r){let i,n=(e[0]-s[0])/t[0],h=(r[0]-s[0])/t[0];n>h&&(i=n,n=h,h=i);let o=(e[1]-s[1])/t[1],f=(r[1]-s[1])/t[1];if(o>f&&(i=o,o=f,f=i),n>f||o>h)return!1;o>n&&(n=o),f<h&&(h=f);let a=(e[2]-s[2])/t[2],d=(r[2]-s[2])/t[2];return a>d&&(i=a,a=d,d=i),!(n>d||a>h)&&(d<h&&(h=d),!(h<0))}function ct(s,t,e,r,i,n=et()){const h=(r[i]-e[i])*(t[0]-s[0])-(r[0]-e[0])*(t[i]-s[i]),o=(r[0]-e[0])*(s[i]-e[i])-(r[i]-e[i])*(s[0]-e[0]);if(h===0)return!1;const f=o/h;return n[0]=s[0]+f*(t[0]-s[0]),n[1]=s[i]+f*(t[i]-s[i]),!0}function pt(s,t,e,r,i){u[0]=s[0],u[1]=s[1],u[2]=s[2],u[3]=1,_(u,u,t),i.length>2&&(i[2]=-u[2]),_(u,u,e),O(u[3]!==0),i[0]=u[0]/u[3],i[1]=u[1]/u[3],i[2]=u[2]/u[3],i[0]=(.5*i[0]+.5)*r[2]+r[0],i[1]=(.5*i[1]+.5)*r[3]+r[1]}function _t(s,t){return Math.log(s)/Math.log(t)}function mt(s){return s[0]===1&&s[1]===0&&s[2]===0&&s[3]===0&&s[4]===0&&s[5]===1&&s[6]===0&&s[7]===0&&s[8]===0&&s[9]===0&&s[10]===1&&s[11]===0&&s[15]===1}class l{constructor(t,e){this.layout=t,this.buffer=typeof e=="number"?new ArrayBuffer(e*t.stride):e;for(const r of t.fields.keys()){const i=t.fields.get(r);this[r]=new i.constructor(this.buffer,i.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(t,e){const r=this[t];return r&&r.elementCount===e.ElementCount&&r.elementType===e.ElementType?r:null}slice(t,e){return new l(this.layout,this.buffer.slice(t*this.stride,e*this.stride))}copyFrom(t,e=0,r=0,i=t.count){const n=this.stride;if(n%4==0){const h=new Uint32Array(t.buffer,e*n,i*n/4);new Uint32Array(this.buffer,r*n,i*n/4).set(h)}else{const h=new Uint8Array(t.buffer,e*n,i*n);new Uint8Array(this.buffer,r*n,i*n).set(h)}return this}get cachedMemory(){return this.byteLength}dispose(){}}class c{constructor(t){this._stride=0,this._lastAligned=0,this._fields=new Map,t&&(this._stride=t.stride,t.fields.forEach(e=>this._fields.set(e[0],{...e[1],constructor:nt(e[1].constructor)})))}freeze(){return this}vec2f(t,e){return this._appendField(t,m,e),this}vec2f64(t,e){return this._appendField(t,y,e),this}vec3f(t,e){return this._appendField(t,F,e),this}vec3f64(t,e){return this._appendField(t,g,e),this}vec4f(t,e){return this._appendField(t,w,e),this}vec4f64(t,e){return this._appendField(t,$,e),this}mat3f(t,e){return this._appendField(t,b,e),this}mat3f64(t,e){return this._appendField(t,E,e),this}mat4f(t,e){return this._appendField(t,v,e),this}mat4f64(t,e){return this._appendField(t,A,e),this}vec4u8(t,e){return this._appendField(t,M,e),this}f32(t,e){return this._appendField(t,T,e),this}f64(t,e){return this._appendField(t,z,e),this}u8(t,e){return this._appendField(t,x,e),this}u16(t,e){return this._appendField(t,B,e),this}i8(t,e){return this._appendField(t,C,e),this}vec2i8(t,e){return this._appendField(t,L,e),this}vec2i16(t,e){return this._appendField(t,U,e),this}vec2u8(t,e){return this._appendField(t,k,e),this}vec4u16(t,e){return this._appendField(t,H,e),this}u32(t,e){return this._appendField(t,I,e),this}_appendField(t,e,r){if(this._fields.has(t))return void O(!1,`${t} already added to vertex buffer layout`);const i=e.ElementCount*p(e.ElementType),n=this._stride;this._stride+=i,this._fields.set(t,{size:i,constructor:e,offset:n,optional:r})}createBuffer(t){return new l(this,t)}createView(t){return new l(this,t)}clone(){const t=new c;return t._stride=this._stride,t._fields=new Map,this._fields.forEach((e,r)=>t._fields.set(r,e)),t.BufferType=this.BufferType,t}get stride(){if(this._lastAligned!==this._fields.size){let t=1;this._fields.forEach(e=>t=Math.max(t,p(e.constructor.ElementType))),this._stride=Math.floor((this._stride+t-1)/t)*t,this._lastAligned=this._fields.size}return this._stride}get fields(){return this._fields}}function yt(){return new c}class Ft{constructor(t){this.fields=new Array,t.fields.forEach((e,r)=>{const i={...e,constructor:V(e.constructor)};this.fields.push([r,i])}),this.stride=t.stride}}const rt=[T,m,F,w,b,v,z,y,g,$,E,A,x,k,G,M,B,S,j,H,I,q,J,K,C,L,N,P,Q,U,R,W,X,Y,Z,tt];function V(s){return`${s.ElementType}_${s.ElementCount}`}function nt(s){return D.get(s)}const D=new Map;rt.forEach(s=>D.set(V(s),s));export{c as G,yt as H,Ft as I,pt as a,at as c,ct as f,lt as i,mt as m,O as s,_t as u};
