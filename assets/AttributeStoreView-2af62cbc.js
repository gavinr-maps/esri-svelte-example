import{hH as Oe,dv as ye,A as We,B as Qe,hI as Xe,hJ as Ze,s as oe,v as k,dD as ie,T as p,fv as me,ai as xe,R as et,gI as ge,de as L,aN as tt,gJ as st}from"./index-e8c6bcc0.js";import{c as _e,d as Me,S as be,E as Ee,F as Te,G as ve,H as Re,I as W,J as Q,K as Se,P as it,R as rt,Q as nt,U as at}from"./definitions-52704927.js";import{r as ot}from"./TiledDisplayObject-2f5891c6.js";import{n as lt}from"./LabelClass-669bcee9.js";import{a as ut}from"./diffUtils-f8f9fc73.js";import{c as Ve}from"./labelingInfo-98c89153.js";import{L as H,E as z,S as _,V as dt,W as Y,K as ct}from"./color-c94de968.js";import{b as ht}from"./WGLContainer-c34de5f8.js";import{d as ft,n as pt,l as yt,f as we}from"./visualVariablesUtils-6582dc8f.js";import{f as C,_ as De,A as mt}from"./GeometryUtils-cd9b347d.js";import"./ExpandedCIM-edf32ef2.js";import"./featureFlags-bf3d5654.js";import{f as xt,c as gt}from"./clusterUtils-a6986c79.js";import{e as Ie}from"./util-85ddbb8f.js";import{D as $e,L as Le,U as _t}from"./enums-b14466b3.js";import{x as bt}from"./VertexArrayObject-218fbe6a.js";import{e as Ne,T as Ae}from"./Texture-7faa3913.js";class v{constructor(e){if(this.next=null,!Array.isArray(e))return void(this.data=e);this.data=e[0];let t=this;for(let s=1;s<e.length;s++)t.next=new v([e[s]]),t=t.next}*values(){let e=this;for(;e;)yield e.data,e=e.next}forEach(e){let t=this;for(;t;)e(t.data),t=t.next}find(e){var t;return e(this.data)?this:(t=this.next)==null?void 0:t.find(e)}max(e,t=this){const s=e(this.data)>e(t.data)?this:t;return this.next?this.next.max(e,s):s}remove(e,t=null){var s;return this===e?t?(t.next=this.next,t):this.next:((s=this.next)==null?void 0:s.remove(e,this))??null}get last(){return this.next?this.next.last:this}}let fs=class{constructor(e){this._head=null,e!=null&&(this._head=new v(e))}get head(){return this._head}maxAvailableSpace(){if(this._head==null)return 0;const e=this._head.max(t=>t.end-t.start);return e.data.end-e.data.start}firstFit(e){if(this._head==null)return null;let t=null,s=this._head;for(;s;){const r=s.data.end-s.data.start;if(r===e)return t?t.next=s.next:this._head=s.next,s.data.start;if(r>e){const n=s.data.start;return s.data.start+=e,n}t=s,s=s.next}return null}free(e,t){const s=e+t;if(this._head==null){const o=new v({start:e,end:s});return void(this._head=o)}if(s<=this._head.data.start){if(s===this._head.data.start)return void(this._head.data.start-=t);const o=new v({start:e,end:s});return o.next=this._head,void(this._head=o)}let r=this._head,n=r.next;for(;n;){if(n.data.start>=s){if(r.data.end===e){if(r.data.end+=t,r.data.end===n.data.start){const l=n.data.end-n.data.start;return r.data.end+=l,void(r.next=n.next)}return}if(n.data.start===s)return void(n.data.start-=t);const o=new v({start:e,end:s});return o.next=r.next,void(r.next=o)}r=n,n=n.next}if(e===r.data.end)return void(r.data.end+=t);const a=new v({start:e,end:s});r.next=a}},Et=class{acquire(e){return{refCount:1,version:-1,labelMat2d:Oe(),tileMat3:ye(),dvs:ye()}}release(e){}},Tt=class re extends ot{constructor(e,t,s,r){super(e,t,s,r,_e,_e)}destroy(){super.destroy(),this._transforms&&re.TransformCache.release(this.key.hash)}setTransform(e){const t=this.resolution/e.resolution,s=this.transforms.tileMat3,[r,n]=e.toScreenNoRotation([0,0],[this.x,this.y]),a=this.width/this.rangeX*t,o=this.height/this.rangeY*t;We(s,a,0,0,0,o,0,r,n,1),Qe(this.transforms.dvs,e.displayViewMat3,s);const l=this.transforms.labelMat2d,u=window.devicePixelRatio,d=Xe(Oe(),a*u,0,0,o*u,r*u,n*u);Ze(l,e.viewMat2d,d)}_createTransforms(){return re.TransformCache.acquire(this.key.hash)}};Tt.TransformCache=new Et;let $=class{constructor(e,t,s,r,n){this.target=e,this.geometryType=t,this.materialKey=s,this.indexFrom=r,this.indexCount=n}get indexEnd(){return this.indexFrom+this.indexCount}extend(e){this.indexCount+=e}},xs=class Pe{constructor(e,t){this.geometryType=0,this._target=e,this.geometryType=t}static from(e,t,s,r){const n=new Pe(e,t);if(r!=null)for(const a of r)s.seekIndex(a),n.addRecord(s);else for(;s.next();)n.addRecord(s);return n}addRecord(e){const t=this._target,s=this.geometryType,r=e.materialKey;let n=e.indexFrom,a=e.indexCount;const o=e.vertexFrom,l=e.vertexCount;if(a||(n=o,a=l),this._head==null){const c=new $(t,s,r,n,a);return void(this._head=new v(c))}let u=null,d=this._head;for(;d;){if(n<d.data.indexFrom)return this._insert(r,n,a,u,d);u=d,d=d.next}this._insert(r,n,a,u,null)}forEach(e){this._head!=null&&this._head.forEach(e)}*infos(){if(this._head!=null)for(const e of this._head.values())yield e}_insert(e,t,s,r,n){if(r==null&&n==null){const a=new $(this._target,this.geometryType,e,t,s);this._head=new v(a)}return r==null&&n!=null?this._insertAtHead(e,t,s,n):r!=null&&n==null?this._insertAtEnd(e,t,s,r):r!=null&&n!=null?this._insertAtMiddle(e,t,s,r,n):void 0}_insertAtHead(e,t,s,r){const n=t+s;if(e===r.data.materialKey&&n===r.data.indexFrom)r.data.indexFrom=t,r.data.indexCount+=s;else{const a=new $(this._target,this.geometryType,e,t,s);this._head=new v(a),this._head.next=r}}_insertAtEnd(e,t,s,r){if(r.data.materialKey===e&&r.data.indexEnd===t)r.data.indexCount+=s;else{const n=new $(this._target,this.geometryType,e,t,s),a=new v(n);r.next=a}}_insertAtMiddle(e,t,s,r,n){const a=t+s;if(r.data.materialKey===e&&r.data.indexEnd===t)r.data.indexCount+=s,r.data.materialKey===n.data.materialKey&&r.data.indexEnd===n.data.indexFrom&&(r.data.indexCount+=n.data.indexCount,r.next=n.next);else if(e===n.data.materialKey&&a===n.data.indexFrom)n.data.indexFrom=t,n.data.indexCount+=s;else{const o=new $(this._target,this.geometryType,e,t,s),l=new v(o);r.next=l,l.next=n}}};const G=2147483647;class N{constructor(e){this._head=e,this._cursor=e}static from(e,t=0,s=e.byteLength/w.BYTES_PER_RECORD-t){const r=new w(new Int32Array(e,t*w.BYTES_PER_RECORD,s*w.ELEMENTS_PER_RECORD));return new N(r)}size(){let e=this._cursor,t=0;for(;e;)t+=e.size(),e=e._link;return t}get id(){return this._cursor.id}set id(e){this._cursor.id=e}get materialKey(){return this._cursor.materialKey}set materialKey(e){this._cursor.materialKey=e}get insertAfter(){return this._cursor.insertAfter}get indexFrom(){return this._cursor.indexFrom}set indexFrom(e){this._cursor.indexFrom=e}get indexCount(){return this._cursor.indexCount}set indexCount(e){this._cursor.indexCount=e}get vertexFrom(){return this._cursor.vertexFrom}set vertexFrom(e){this._cursor.vertexFrom=e}get vertexCount(){return this._cursor.vertexCount}set vertexCount(e){this._cursor.vertexCount=e}get sortKey(){return this._cursor.sortKey}set sortKey(e){this._cursor.sortKey=e}get index(){return this._cursor._indexStart+this._cursor._index}seekIndex(e){let t=e;for(this._cursor=this._head;this._cursor;){const s=this._cursor.size();if(t<s)return this._cursor._index=t,!0;t-=s,this._cursor=this._cursor._link}return!1}forEach(e){const t=this.getCursor();for(;t.next();)e(t)}link(e){if(!this._head)return void(this._head=e._head);let t=this._head;for(;t._link;)t=t._link;t._link=e._head,t._link._indexStart=t._indexStart+t.size()}getCursor(){return this.copy()}getDrawInfo(e,t){return new $(e,t,this.materialKey,this.indexFrom,this.indexCount)}lookup(e){for(this._cursor=this._head;this._cursor&&!this._cursor.lookup(e);){if(!this._cursor._link)return!1;this._cursor=this._cursor._link}return!!this._cursor}copy(){var r;const e=new N((r=this._head)==null?void 0:r.copy());if(!e._head)return e;let t=e._head,s=e._head._link;for(;s;)t._link=s.copy(),t=s,s=t._link;return e}next(){return!!this._cursor&&(!!this._cursor.next()||!!this._cursor._link&&(this._cursor=this._cursor._link,this.next()))}peekId(){return this._cursor.peekId()??this._cursor._link.peekId()}delete(e){let t=this._head,s=null;for(;t;){if(t.delete(e))return t.isEmpty()&&(s!=null&&(s._link=t._link),t===this._head&&(this._head=t._link),t===this._cursor&&(this._cursor=t._link)),!0;s=t,t=t._link}return!1}}N.ELEMENTS_PER_RECORD=Me,N.BYTES_PER_RECORD=N.ELEMENTS_PER_RECORD*Int32Array.BYTES_PER_ELEMENT;let w=class f{constructor(e){this._link=null,this._index=-1,this._indexStart=0,this._packedRecordsF32=null,this._deletedCount=0,this._offsets={instance:null},this._packedRecords=e}static from(e,t=0,s=e.byteLength/this.BYTES_PER_RECORD-t){return new f(new Int32Array(e,t*this.BYTES_PER_RECORD,s*this.ELEMENTS_PER_RECORD))}delete(e){const t=this._index,s=this.lookup(e);if(s)for(this.id=G,++this._deletedCount;this.next()&&this.id===e;)this.id=G,++this._deletedCount;return this._index=t,s}isEmpty(){return this._deletedCount===this.size()}link(e){this._link?this._link.link(e):this._link=e}lookup(e){if(this._offsets.instance==null){this._offsets.instance=new Map;const s=this.copy();s._index=-1;let r=0;for(;s.next();)s.id!==r&&(this._offsets.instance.set(s.id,s._index),r=s.id)}if(!this._offsets.instance.has(e))return!1;const t=this._index;return this._index=this._offsets.instance.get(e),this.id!==G||(this._index=t,!1)}get id(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD]}set id(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD]=e}get materialKey(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+1]}set materialKey(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+1]=e}get insertAfter(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+2]}get indexFrom(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+3]}set indexFrom(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+3]=e}get indexCount(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+4]}set indexCount(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+4]=e}get vertexFrom(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+5]}set vertexFrom(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+5]=e}get vertexCount(){return this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+6]}set vertexCount(e){this._packedRecords[this._index*f.ELEMENTS_PER_RECORD+6]=e}get sortKey(){return this._packedRecordsF32||(this._packedRecordsF32=new Float32Array(this._packedRecords.buffer)),this._packedRecordsF32[this._index*f.ELEMENTS_PER_RECORD+7]}set sortKey(e){this._packedRecordsF32||(this._packedRecordsF32=new Float32Array(this._packedRecords.buffer)),this._packedRecordsF32[this._index*f.ELEMENTS_PER_RECORD+7]=e}get index(){return this._index}size(){return this._packedRecords.length/f.ELEMENTS_PER_RECORD}next(){for(;++this._index<this.size()&&this.id===G;);return this._index<this.size()}peekId(){const e=(this._index+1)*f.ELEMENTS_PER_RECORD;return e>=this._packedRecords.length?0:this._packedRecords[e]}getCursor(){return this.copy()}copy(){const e=new f(this._packedRecords);return e._indexStart=this._indexStart,e._link=this._link,e._index=this._index,e._offsets=this._offsets,e._deletedCount=this._deletedCount,e}};w.ELEMENTS_PER_RECORD=Me,w.BYTES_PER_RECORD=w.ELEMENTS_PER_RECORD*Int32Array.BYTES_PER_ELEMENT;function Ue(i){if(!i)return H.NONE;let e=0;for(const t of i)if(t.type==="size"){const s=ft(t);e|=s,t.target==="outline"&&(e|=s<<4)}else t.type==="color"?e|=H.COLOR:t.type==="opacity"?e|=H.OPACITY:t.type==="rotation"&&(e|=H.ROTATION);return e}function O(i){var e;return i.type==="line-marker"?{type:"line-marker",color:(e=i.color)==null?void 0:e.toJSON(),placement:i.placement,style:i.style}:i.constructor.fromJSON(i.toJSON()).toJSON()}function M(i){return mt(i)}function b(i,e,t=!1){if(!i)return null;switch(i.type){case"simple-fill":case"picture-fill":return Rt(i,e,t);case"simple-marker":case"picture-marker":return wt(i,e,t);case"simple-line":return St(i,e,t);case"text":return Ft(i,e,t);case"label":return vt(i,e,t);case"cim":return{type:"cim",rendererKey:e.vvFlags,data:i.data,maxVVSize:e.maxVVSize};case"CIMSymbolReference":return{type:"cim",rendererKey:e.vvFlags,data:i,maxVVSize:e.maxVVSize};case"web-style":return{...O(i),type:"web-style",hash:i.hash(),rendererKey:e.vvFlags,maxVVSize:e.maxVVSize};default:throw new Error(`symbol not supported ${i.type}`)}}function vt(i,e,t){const s=i.toJSON(),r=C(z.LABEL,{...e,placement:s.labelPlacement});return{materialKey:t?M(r):r,hash:i.hash(),...s,labelPlacement:s.labelPlacement}}function Rt(i,e,t){const s=C(z.FILL,e),r=t?M(s):s,n=i.clone(),a=n.outline,o=De(e.symbologyType);o||(n.outline=null);const l={materialKey:r,hash:n.hash(),...O(n)};if(o)return l;const u=[];if(u.push(l),a){const d=C(z.LINE,{...e,isOutline:!0}),c={materialKey:t?M(d):d,hash:a.hash(),...O(a)};u.push(c)}return{type:"composite-symbol",layers:u,hash:u.reduce((d,c)=>c.hash+d,"")}}function St(i,e,t){const s=De(e.symbologyType)?_.DEFAULT:e.symbologyType,r=C(z.LINE,{...e,symbologyType:s}),n=t?M(r):r,a=i.clone(),o=a.marker;a.marker=null;const l=[];if(l.push({materialKey:n,hash:a.hash(),...O(a)}),o){const u=C(z.MARKER,e),d=t?M(u):u;o.color=o.color??a.color,l.push({materialKey:d,hash:o.hash(),lineWidth:a.width,...O(o)})}return{type:"composite-symbol",layers:l,hash:l.reduce((u,d)=>d.hash+u,"")}}function wt(i,e,t){const s=C(z.MARKER,e),r=t?M(s):s,n=O(i);return{materialKey:r,hash:i.hash(),...n,angle:i.angle,maxVVSize:e.maxVVSize}}function Ft(i,e,t){const s=C(z.TEXT,e),r=t?M(s):s,n=O(i);return{materialKey:r,hash:i.hash(),...n,angle:i.angle,maxVVSize:e.maxVVSize}}const gs=Object.freeze(Object.defineProperty({__proto__:null,createSymbolSchema:b},Symbol.toStringTag,{value:"Module"}));function kt(i,e){if(!("visualVariables"in i)||!i.hasVisualVariables("size"))return 0;const t=i.getVisualVariablesForType("size");if(!t[0])return 0;const s=t[0];if(e&&s.field==="cluster_count"&&e.type==="cluster")return e.clusterMaxSize;if(s.target==="outline")return 0;if(s.transformationType==="stops")return s.stops.map(r=>r.size).reduce(X,0);if(s.transformationType==="clamped-linear"){let r=-1/0,n=-1/0;return r=typeof s.maxSize=="number"?s.maxSize:s.maxSize.stops.map(a=>a.size).reduce(X,0),n=typeof s.minSize=="number"?s.minSize:s.minSize.stops.map(a=>a.size).reduce(X,0),Math.max(r,n)}return s.transformationType==="real-world-size"?30:void 0}function X(i,e){return Math.max(i,e)}const q=8,Ke=q-2,j=oe.getLogger("esri.views.2d.layers.features.support.rendererUtils"),_s=i=>{if(!("visualVariables"in i)||!i.visualVariables||!i.visualVariables.length)return i;const e=i.clone(),t=e.visualVariables.map(s=>Be(s)?Je(s):s);return e.visualVariables=t,e};function zt(i){return i.map(e=>Be(e)?Je(e.clone()):e)}function Be(i){return(i.type==="size"||i.type==="color"||i.type==="opacity")&&i.stops!=null}function Je(i){return i.stops=Mt(i.type,i.stops??[]),i}function I(i,e,t){return(1-t)*i+t*e}function Ct(i,e){const[t,...s]=e,r=s.pop(),n=s[0].value,a=s[s.length-1].value,o=(a-n)/Ke,l=[];for(let u=n;u<a;u+=o){let d=0;for(;u>=s[d].value;)d++;const c=s[d],h=e[d-1],R=u-h.value,E=c.value===h.value?1:R/(c.value-h.value);if(i==="color"){const m=s[d],T=e[d-1],y=m.color.clone();y.r=I(T.color.r,y.r,E),y.g=I(T.color.g,y.g,E),y.b=I(T.color.b,y.b,E),y.a=I(T.color.a,y.a,E),l.push({value:u,color:y,label:m.label})}else if(i==="size"){const m=s[d],T=e[d-1],y=me(m.size),g=I(me(T.size),y,E);l.push({value:u,size:g,label:m.label})}else{const m=s[d],T=I(e[d-1].opacity,m.opacity,E);l.push({value:u,opacity:T,label:m.label})}}return[t,...l,r]}function Ot(i){const[e,...t]=i,s=t.pop();for(;t.length>Ke;){let r=0,n=0;for(let a=1;a<t.length;a++){const o=t[a-1],l=t[a],u=Math.abs(l.value-o.value);u>n&&(n=u,r=a)}t.splice(r,1)}return[e,...t,s]}function Mt(i,e){return e.length<=q?e:(j.warn(`Found ${e.length} Visual Variable stops, but MapView only supports ${q}. Displayed stops will be simplified.`),e.length>2*q?Ct(i,e):Ot(e))}function le(){if(k("heatmap-force-raster"))return"raster";const{supportsTextureFloat:i,supportsTextureHalfFloat:e,supportsColorBufferFloat:t,supportsColorBufferFloatBlend:s,supportsColorBufferHalfFloat:r}=ie("2d");return i&&t&&s||e&&r?"symbol":k("heatmap-allow-raster-fallback")?"raster":"none"}function bs(i){if(!i)return!0;switch(i.type){case"dot-density":if(!ie("2d").supportsTextureFloat)return j.error(new p("webgl-missing-extension","Missing WebGL extension OES_Texture_Float which is required for DotDensity")),!1;break;case"heatmap":{const e=le();if(e==="none"||e==="raster"&&!k("heatmap-force-raster")){const t=ie("2d"),s=["supportsTextureFloat","supportsTextureHalfFloat","supportsColorBufferFloat","supportsColorBufferFloatBlend","supportsColorBufferHalfFloat"].filter(r=>!t[r]).join(", ");if(e==="none")return j.errorOnce(new p("webgl-missing-extension",`Missing WebGL${t.type} requirements for Heatmap: ${s}`)),!1;e==="raster"&&j.warnOnce(`Missing WebGL${t.type} requirements for accelerated Heatmap: ${s}. Feature support may be limited.`)}break}}return!0}const V=oe.getLogger("esri.views.2d.layers.features.schemaUtils"),x="ValidationError";function ne(i,e){let t=0,s=0,r=_.DEFAULT;if(i!=null){if(s=kt(i,e),"visualVariables"in i&&(t=Ue(i.visualVariables||[]),i.type==="dot-density"&&(r=_.DOT_DENSITY)),i.type==="heatmap"&&(r=_.HEATMAP),i.type==="dictionary")return{maxVVSize:s,vvFlags:t,symbologyType:_.DEFAULT};if(i.type==="pie-chart")return{maxVVSize:s,vvFlags:t,symbologyType:_.PIE_CHART};if(r!==_.DOT_DENSITY&&r!==_.HEATMAP){const n=i.getSymbols();"backgroundFillSymbol"in i&&i.backgroundFillSymbol&&n.push(i.backgroundFillSymbol);let a=!0,o=!0;for(const l of n)if(l.type!=="cim"&&l.type!=="web-style"||(o=!1),l.type==="simple-fill"||l.type==="picture-fill"){const u=l.outline,d=u&&u.style!=="none"&&u.style!=="solid",c=l.type==="simple-fill"&&l.style!=="none"&&l.style!=="solid";d&&(a=!1),(l.type==="picture-fill"||c||d)&&(o=!1)}a?r=o?_.OUTLINE_FILL_SIMPLE:_.OUTLINE_FILL:o&&(r=_.SIMPLE)}}return{vvFlags:t,maxVVSize:s,symbologyType:r}}let Fe=null;function Es(i){if(k("esri-2d-update-debug")){const e=ke(i,!0);console.debug("Created new schema",e),console.debug("Schema diff",ut(Fe,e)),Fe=e}return ke(i)}function ke(i,e=!1){var t,s;try{const r=$t(i,e),n=At(i),a={};r.map(u=>Vt(a,i,u));const o=i.subtypeCode!=null?`${i.subtypeField} = ${i.subtypeCode}`:null;return{source:{definitionExpression:lt(i.definitionExpression,o),fields:i.fields.map(u=>u.toJSON()),gdbVersion:i.gdbVersion,historicMoment:(t=i.historicMoment)==null?void 0:t.getTime(),outFields:i.availableFields,pixelBuffer:i.pixelBuffer,spatialReference:i.spatialReference.toJSON(),timeExtent:(s=i.timeExtent)==null?void 0:s.toJSON(),customParameters:i.customParameters},attributes:{fields:{},indexCount:0},processors:r,tileRenderer:n,targets:a}}catch(r){if(r.fieldName===x)return V.error(r),null;throw r}}function Vt(i,e,t){switch(t.target){case"feature":return void ee(i,Z(e),t);case"aggregate":{if(!("featureReduction"in e))return;const s=e.featureReduction;switch(s==null?void 0:s.type){case"selection":throw new p(x,"Mapview does not support `selection` reduction type",s);case"binning":return ee(i,Z(e),t),void Dt(i,s,e.fields.map(r=>r.toJSON()),t);case"cluster":return ee(i,Z(e),t),void It(i,s,e.fields.map(r=>r.toJSON()),t)}}}}function ue(i,e){var t,s;for(const r in e){const n=e[r];if(n.target!==i.name)continue;const a=i.attributes[r];if(a!=null&&a.context){const o=a.context;o.mesh=o.mesh||((t=n.context)==null?void 0:t.mesh),o.storage=o.storage||((s=n.context)==null?void 0:s.storage)}else i.attributes[r]=n}return i}function Z(i){var e,t,s;return[((e=i.filter)==null?void 0:e.toJSON())??null,((s=(t=i.featureEffect)==null?void 0:t.filter)==null?void 0:s.toJSON())??null]}function ee(i,e,t){return i.feature||(i.feature={name:"feature",input:"source",filters:e,attributes:{}}),ue(i.feature,t.attributes.fields),i}function He(i,e){const{onStatisticExpression:t,onStatisticField:s,statisticType:r}=i;switch(r){case"min":case"max":case"avg":case"avg_angle":case"sum":case"count":return"esriFieldTypeDouble";case"mode":{if(t){const{returnType:a}=t;return a?a==="string"?"esriFieldTypeString":"esriFieldTypeDouble":(V.error(new p(x,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",i)),"esriFieldTypeString")}const n=e.find(a=>a.name===s);return n?n.type:(V.error(new p(x,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",i)),"esriFieldTypeString")}}}function Dt(i,e,t,s){return i.aggregate||(i.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:e.fixedBinLevel,fields:(e.fields??[]).map(r=>({...r.toJSON(),type:He(r,t)}))},attributes:{}}),ue(i.aggregate,s.attributes.fields),i}function It(i,e,t,s){const r=s.aggregateFields??[],n=new Set;for(const a of r)n.add(a.name);for(const a of(e==null?void 0:e.fields)??[])n.has(a.name)||r.push(a);return i.aggregate||(i.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:xe(e.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(xe(e.clusterMaxSize)/64),fields:r.map(a=>({...a.toJSON(),type:He(a,t)}))}}),ue(i.aggregate,s.attributes.fields),i}function S(i,e){return e.field?F(i,{...e,type:"field",field:e.field}):e.valueExpression?F(i,{...e,type:"expression",valueExpression:e.valueExpression}):{field:void 0,fieldIndex:void 0}}function F(i,e){switch(e.type){case"expression":{const t=e.valueExpression;if(!i.fields[t]){const s=i.indexCount++;i.fields[t]={...e,name:t,fieldIndex:s}}return{fieldIndex:i.fields[t].fieldIndex}}case"label-expression":{const t=JSON.stringify(e.label);if(!i.fields[t]){const s=i.indexCount++;i.fields[t]={...e,name:t,fieldIndex:s}}return{fieldIndex:i.fields[t].fieldIndex}}case"field":{const t=e.field;return e.target==="aggregate"&&i.fields[t]||(i.fields[t]={...e,name:t}),{field:t}}case"statistic":return i.fields[e.name]={...e},{field:e.name}}}function $t(i,e=!1){const t=new Array;let s=0;return t.push(Nt(i,s++,e)),t}function te(i,e,t,s,r,n=!1){const a=F(i,{type:"label-expression",target:t,context:{mesh:!0},resultType:"string",label:{labelExpression:e.labelExpression,labelExpressionInfo:e.labelExpressionInfo?{expression:e.labelExpressionInfo.expression}:null,symbol:!!e.symbol,where:e.where}}),{fieldIndex:o}=a;return{...b(e,r,n),fieldIndex:o,target:t,index:s}}function Lt(i,e,t){var d;const s="featureReduction"in e&&e.featureReduction;if(!s)return{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};const r="aggregate",n=[];let a=null,o=Ie(e.geometryType),l=[],u=null;if(s)switch(s.type){case"selection":return V.error(new p(x,"Mapview does not support `selection` reduction type",s)),{fields:[],labels:[],matcher:void 0,rendererOverride:void 0};case"cluster":case"binning":if(n.push(...s.fields??[]),s.type==="cluster"?o="esriGeometryPoint":s.type==="binning"&&(o="esriGeometryPolygon"),s.renderer&&!((d=s.renderer.authoringInfo)!=null&&d.isAutoGenerated)){if(s.type==="cluster"){const{renderer:h}=xt(s.renderer,s,null);u=h}else u=s.renderer;const c=ne(s.renderer,s);a=ae(i,r,s.renderer,c,t),l=s&&s.labelsVisible&&s.labelingInfo||[]}else if(s.type==="cluster"){if(u=gt(n,e.renderer,s,null,!0),s.symbol){const c=ne(u,s);a={type:"simple",symbol:b(s.symbol,c,t),symbologyType:c.symbologyType}}l=s&&s.labelsVisible&&s.labelingInfo||[]}}return Ut(i,n),{labels:Ve(l,s.type==="binning"?"esriGeometryPolygon":o),matcher:a,fields:n,rendererOverride:u}}function Nt(i,e,t=!1){var y;const s={indexCount:0,fields:{}},r="featureReduction"in i?i.featureReduction??void 0:void 0,n=r?"aggregate":"feature";if("sublayers"in i){const g={type:"subtype",subtypeField:i.subtypeField,renderers:{},symbologyType:_.DEFAULT},B={type:"subtype",mapping:{},target:"feature",subtypeField:i.subtypeField},J={type:"subtype",classes:{}},Ye={type:"symbol",target:"feature",aggregateFields:[],attributes:s,storage:B,mesh:{matcher:g,aggregateMatcher:null,labels:J,sortKey:null}},ce=new Set;let Ge=0;for(const{renderer:D,subtypeCode:A,labelingInfo:qe,labelsVisible:je}of i.sublayers){let he=0;"visualVariables"in D&&D.visualVariables&&(D.visualVariables.some(K=>K.type!=="rotation")&&V.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."),he=Ue(D.visualVariables.filter(K=>K.type!=="size")));const fe={symbologyType:_.DEFAULT,vvFlags:he,maxVVSize:0},P=ae(s,n,D,fe,t),U=ze(s,n,D),pe=je&&qe;if(P.type==="dictionary")throw new p(x,"Dictionary renderer is not supported in subtype layers");if(P.type==="subtype")throw new p(x,"Nested subtype renderers is not supported");if(U!=null&&U.type==="subtype")throw new p(x,"Nested subtype storage is not supported");if(U!=null&&U.attributeMapping!=null)throw new p(x,"Non-visual-variable attributes are not supported in subtype layers");if(P.type==="heatmap")throw new p(x,"Heatmaps are not supported in subtype layers");if(P.type==="pie-chart")throw new p(x,"Pie-charts are not supported in subtype layers");if(ce.has(A))throw new p(x,"Subtype codes for sublayers must be unique");ce.add(A),g.renderers[A]=P,B.mapping[A]=U,pe&&(J.classes[A]=pe.map(K=>te(s,K,"feature",Ge++,fe,t)))}return Ye}if(((y=i.renderer)==null?void 0:y.type)==="heatmap"&&le()==="raster"){const{radius:g,fieldOffset:B,field:J}=i.renderer;return{type:"heatmap",aggregateFields:[],attributes:s,target:n,storage:null,mesh:{radius:g,fieldOffset:B,field:S(s,{target:n,field:J,resultType:"numeric"}).field}}}const a=Lt(s,i,t),o=Ie(i.geometryType),l=a.rendererOverride??i.renderer,u=ne(l,r),d=ae(s,n,l,u,t),c=ze(s,n,l),h=Pt(s,i.orderBy,i.renderer,r),R=i.labelsVisible&&i.labelingInfo||[],E=Ve(R,o);let m=0;const T=[...E.map(g=>te(s,g,"feature",m++,u,t)),...a.labels.map(g=>te(s,g,"aggregate",m++,u,t))];return{type:"symbol",target:n,attributes:s,aggregateFields:a.fields,storage:c,mesh:{matcher:d,labels:{type:"simple",classes:T},aggregateMatcher:a.matcher,sortKey:h}}}function At(i){var e;return((e=i.renderer)==null?void 0:e.type)==="heatmap"&&le()==="raster"?{type:"heatmap"}:{type:"symbol"}}function Pt(i,e,t,s){if(s!=null)return null;if(e!=null&&e.length){e.length>1&&V.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${e.length}. All but the first will be discarded`);const r=e[0],n=r.order==="ascending"?"asc":"desc";return r.field?{field:r.field,order:n}:r.valueExpression?{fieldIndex:F(i,{type:"expression",target:"feature",valueExpression:r.valueExpression,resultType:"numeric"}).fieldIndex,order:n}:(V.error(new p(x,"Expected to find a field or valueExpression for OrderByInfo",r)),null)}return t!=null&&t.type==="unique-value"&&t.orderByClassesEnabled?{byRenderer:!0,order:"asc"}:null}function Ut(i,e){const t={mesh:!0,storage:!0};for(const s of e){const{name:r,onStatisticField:n,onStatisticExpression:a,statisticType:o}=s;let l,u;const d="numeric",c="feature";a?u=F(i,{type:"expression",target:c,valueExpression:a.expression,resultType:d}).fieldIndex:l=F(i,{type:"field",target:c,field:n,resultType:d}).field,F(i,{type:"statistic",target:"aggregate",name:r,context:t,inField:l,inFieldIndex:u,statisticType:o})}}function ze(i,e,t){let s;switch(t.type){case"simple":case"class-breaks":case"unique-value":case"dictionary":s={visualVariables:!0,attributes:null};break;default:s=ht(t).getStorageSpec(t)}return Kt(i,e,s,t)}function Kt(i,e,t,s){if(t==null)return null;const{visualVariables:r,attributes:n}=t;let a=null;r&&"visualVariables"in s&&(a=Bt(i,e,s.visualVariables));const o=a!=null?4:0;let l=null;return n!=null&&(l=n.map((u,d)=>{const{field:c,fieldIndex:h}=S(i,{valueExpression:u.valueExpression,field:u.field,resultType:"numeric",target:e});return{binding:d+o,field:c,fieldIndex:h}})),{type:"simple",target:e,attributeMapping:l,vvMapping:a}}function Bt(i,e,t){if(!t||!t.length)return[];const s={storage:!0},r="numeric";return zt(t).map(n=>{const a=dt(n.type),{field:o,fieldIndex:l}=S(i,{target:e,valueExpression:n.valueExpression,field:n.field,context:s,resultType:r});switch(n.type){case"size":return n.valueExpression==="$view.scale"?null:{type:"size",binding:a,field:o,fieldIndex:l,normalizationField:S(i,{target:e,field:n.normalizationField,context:s,resultType:r}).field,valueRepresentation:n.valueRepresentation??null};case"color":return{type:"color",binding:a,field:o,fieldIndex:l,normalizationField:S(i,{target:e,field:n.normalizationField,context:s,resultType:r}).field};case"opacity":return{type:"opacity",binding:a,field:o,fieldIndex:l,normalizationField:S(i,{target:e,field:n.normalizationField,context:s,resultType:r}).field};case"rotation":return{type:"rotation",binding:a,field:o,fieldIndex:l}}}).filter(et)}function ae(i,e,t,s,r=!1){const n=i??{indexCount:0,fields:{}};switch(t.type){case"simple":case"dot-density":return Jt(n,t,s,r);case"class-breaks":return Yt(n,e,t,s,r);case"unique-value":return Gt(n,e,t,s,r);case"dictionary":return qt(n,t,s,r);case"heatmap":return jt(n,t,s,r);case"pie-chart":return Ht(n,t,s,r)}}function Jt(i,e,t,s=!1){const r=e.getSymbols(),n=r.length?r[0]:null;return{type:"simple",symbol:b(n,t,s),symbologyType:t.symbologyType}}function Ht(i,e,t,s=!1){const r=e.getSymbols(),n=r[0],a=r.length>1?r[1]:null;return{type:"pie-chart",markerSymbol:b(n,t,s),fillSymbol:b(a,t,s),symbologyType:t.symbologyType}}function Yt(i,e,t,s,r=!1){const n={mesh:!0,use:"renderer.field"},a=t.backgroundFillSymbol,{field:o,fieldIndex:l}=S(i,{target:e,field:t.field,valueExpression:t.valueExpression,resultType:"numeric",context:n}),u=t.normalizationType,d=u==="log"?"esriNormalizeByLog":u==="percent-of-total"?"esriNormalizeByPercentOfTotal":u==="field"?"esriNormalizeByField":null,c=t.classBreakInfos.map(h=>({symbol:b(h.symbol,s,r),min:h.minValue,max:h.maxValue})).sort((h,R)=>h.min-R.min);return{type:"interval",attributes:i.fields,field:o,fieldIndex:l,backgroundFillSymbol:b(a,s,r),defaultSymbol:b(t.defaultSymbol,s,r),intervals:c,normalizationField:t.normalizationField,normalizationTotal:t.normalizationTotal,normalizationType:d,isMaxInclusive:t.isMaxInclusive,symbologyType:s.symbologyType}}function Gt(i,e,t,s,r=!1){const n=[],a=t.backgroundFillSymbol,o={target:e,context:{mesh:!0},resultType:"string"};if(t.field&&typeof t.field!="string")throw new p(x,"Expected renderer.field to be a string",t);const{field:l,fieldIndex:u}=S(i,{...o,field:t.field,valueExpression:t.valueExpression});for(const d of t.uniqueValueInfos??[])n.push({value:""+d.value,symbol:b(d.symbol,s,r)});return{type:"map",attributes:i.fields,field:l,fieldIndex:u,field2:S(i,{...o,field:t.field2}).field,field3:S(i,{...o,field:t.field3}).field,fieldDelimiter:t.fieldDelimiter??void 0,backgroundFillSymbol:b(a,s),defaultSymbol:b(t.defaultSymbol,s),map:n,symbologyType:s.symbologyType}}function qt(i,e,t,s=!1){return{type:"dictionary",config:e.config,fieldMap:e.fieldMap,scaleExpression:e.scaleExpression,url:e.url,symbolOptions:t,symbologyType:t.symbologyType}}function jt(i,e,t,s=!1){const r=e.getSymbols(),n=r.length?r[0]:null;return{type:"heatmap",symbol:b(n,t,s),symbologyType:t.symbologyType}}const de=oe.getLogger("esri.views.2d.engine.webgl.AttributeStoreView"),se=pt(yt,de);class Ce{constructor(e,t,s){this._texture=null,this._lastTexture=null,this._fbos={},this.texelSize=4;const{buffer:r,pixelType:n,textureOnly:a}=e,o=Y(n);this.shared=s,this.pixelType=n,this.size=t,this.textureOnly=a,a||(this.data=new o(r)),this._resetRange()}destroy(){L(this._texture,e=>e.dispose());for(const e in this._fbos)L(this._fbos[e],t=>{e==="0"&&t.detachColorTexture(),t.dispose()}),this._fbos[e]=null;this._texture=null}get _textureDesc(){const e=new Ne;return e.wrapMode=$e.CLAMP_TO_EDGE,e.samplingMode=Le.NEAREST,e.dataType=this.pixelType,e.width=this.size,e.height=this.size,e}setData(e,t,s){const r=we(e),n=this.data,a=r*this.texelSize+t;!n||a>=n.length||(n[a]=s,this.dirtyStart=Math.min(this.dirtyStart,r),this.dirtyEnd=Math.max(this.dirtyEnd,r))}getData(e,t){if(this.data==null)return null;const s=we(e)*this.texelSize+t;return!this.data||s>=this.data.length?null:this.data[s]}getTexture(e){return this._texture??this._initTexture(e)}getFBO(e,t=0){if(!this._fbos[t]){const s=t===0?this.getTexture(e):this._textureDesc;this._fbos[t]=new bt(e,s)}return this._fbos[t]}get locked(){return!(this.pixelType!==_t.UNSIGNED_BYTE||!this.shared||this.textureOnly||!k("esri-atomics")||!this.data)&&Atomics.load(this.data,0)===1}get hasDirty(){const e=this.dirtyStart;return this.dirtyEnd>=e}updateTexture(e,t){if(!this.locked){try{const s=this.dirtyStart,r=this.dirtyEnd;if(!this.hasDirty)return;this._resetRange();const n=this.data.buffer,a=this.getTexture(e),o=4,l=(s-s%this.size)/this.size,u=(r-r%this.size)/this.size,d=l,c=this.size,h=u,R=l*this.size*o,E=(c+h*this.size)*o-R,m=Y(this.pixelType),T=new m(n,R*m.BYTES_PER_ELEMENT,E),y=this.size,g=h-d+1;if(g>this.size)return void de.error(new p("mapview-webgl","Out-of-bounds index when updating AttributeData"));a.updateData(0,0,d,y,g,T)}catch{}t()}}update(e){const{data:t,start:s,end:r}=e;if(t!=null&&this.data!=null){const n=this.data,a=s*this.texelSize;for(let o=0;o<t.length;o++){const l=1<<o%this.texelSize;e.layout&l&&(n[a+o]=t[o])}}this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,r)}resize(e,t){const s=this.size;if(this.size=t,this.textureOnly)return void(s!==this.size&&(this._lastTexture=this._texture,this._texture=null));const r=Y(this.pixelType);this.destroy(),this.data=new r(e.buffer)}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}_initTexture(e){const t=new Ae(e,this._textureDesc,this.data??void 0);if(this._lastTexture!=null&&this._fbos[0]){const s=this._lastTexture.descriptor.width,r=this._lastTexture.descriptor.height,n=this._lastTexture.descriptor.dataType,a=this._lastTexture.descriptor.pixelFormat,o=this.getFBO(e),l=ct(n),u=new(Y(n))(new ArrayBuffer(s*r*l*this.texelSize)),d=e.getBoundFramebufferObject(),{x:c,y:h,width:R,height:E}=e.getViewport();e.bindFramebuffer(o),o.readPixels(0,0,s,r,a,n,u),t.updateData(0,0,0,2*s,r/2,u),e.setViewport(c,h,R,E),e.bindFramebuffer(d)}return this.destroy(),this._texture=t,this._texture}}class Ts{constructor(e){this._onUpdate=e,this._initialized=!1,this._forceNextUpload=!1,this._locked=!1}initialize(e){const{blocks:t,shared:s,size:r}=e;if(this.shared=s,this.size=r,se("Initializing AttributeStoreView",e),this._data==null)this._data=ge(t,n=>new Ce(n,r,s));else for(let n=0;n<this._data.length;n++){const a=this._data[n],o=t[n];o!=null&&(a==null?this._data[n]=new Ce(o,r,s):a.resize(o,r))}this._initialized=!0}destroy(){L(this._data,e=>ge(e,t=>t.destroy())),L(this._defaultTexture,e=>e.dispose())}isEmpty(){return this._data==null}isUpdating(){const e=this._pendingAttributeUpdate!=null,t=e;return k("esri-2d-log-updating")&&console.log(`Updating AttributeStoreView ${t}
  -> hasPendingUpdate ${e}`),t}getBlock(e){return this._data==null?null:this._data[e]}setLabelMinZoom(e,t){this.setData(e,0,1,t)}getLabelMinZoom(e){return this.getData(e,0,1,255)}getFilterFlags(e){return this.getData(e,0,0,0)}getVVSize(e){return this.getData(e,be,0,0)}getData(e,t,s,r){if(!this._data)return 0;const n=this._data[t];if(n==null)return 0;const a=n.getData(e,s);return a??r}setData(e,t,s,r){this._data[t].setData(e,s,r)}lockTextureUpload(){this._locked=!0}unlockTextureUpload(){this._locked=!1}forceTextureUpload(){this._forceNextUpload=!0}async requestUpdate(e){if(this._pendingAttributeUpdate)return void de.error(new p("mapview-webgl","Tried to update attribute data with a pending update"));const t=tt();return se("AttributeStoreView Update Requested",e),this._pendingAttributeUpdate={data:e,resolver:t},this._onUpdate(),t.promise}update(){if(this._initialized&&this._pendingAttributeUpdate!=null){k("esri-2d-update-debug")&&console.debug("AttributeStoreView::update");const{data:e,resolver:t}=this._pendingAttributeUpdate,s=this._data;for(let r=0;r<e.blocks.length;r++){const n=e.blocks[r],a=s[r];L(a,o=>L(n,l=>{se(`Updating block ${r}`,l),o.update(l)}))}this._pendingAttributeUpdate=null,t(),this._onUpdate()}}bindTextures(e,t=!0){var n,a,o,l,u,d,c;const s=this._getDefaultTexture(e);if(!this._initialized)return e.bindTexture(s,Ee),void(t&&(e.bindTexture(s,Te),e.bindTexture(s,ve),e.bindTexture(s,Re),e.bindTexture(s,W),e.bindTexture(s,Q),e.bindTexture(s,Se)));const r=this._data;this._locked&&!this._forceNextUpload||(st(r,h=>h.updateTexture(e,()=>this._onUpdate())),this._forceNextUpload=!1),e.bindTexture(((n=r[it])==null?void 0:n.getTexture(e))??s,Ee),t&&(e.bindTexture(((a=r[rt])==null?void 0:a.getTexture(e))??s,Se),e.bindTexture(((o=r[nt])==null?void 0:o.getTexture(e))??s,Te),e.bindTexture(((l=r[be])==null?void 0:l.getTexture(e))??s,ve),e.bindTexture(((u=r[at])==null?void 0:u.getTexture(e))??s,Re),e.bindTexture(((d=r[W])==null?void 0:d.getTexture(e))??s,W),e.bindTexture(((c=r[Q])==null?void 0:c.getTexture(e))??s,Q))}_getDefaultTexture(e){if(this._defaultTexture==null){const t=new Ne;t.wrapMode=$e.CLAMP_TO_EDGE,t.samplingMode=Le.NEAREST,t.width=1,t.height=1,this._defaultTexture=new Ae(e,t,new Uint8Array(4))}return this._defaultTexture}}export{Ts as O,ne as T,ae as _,fs as a,_s as b,gs as c,bs as h,Tt as m,xs as n,b as o,N as r,Es as w};
