import{d as E}from"./Graphic-Dc7F67nR.js";import{r as l,n as h}from"./subclass-BR3PhgZG.js";import{w as y}from"./Extent-DHjqVB-p.js";import{$ as d}from"./Mesh-DBjiOEHo.js";import{f as S,_ as N}from"./Point-DB4Hp4hH.js";import{N as w}from"./MeshTransform-DLV7aKpV.js";import{o as D,i as M}from"./External-w9Liy2RE.js";import{s as F}from"./infoFor3D-CxOdoily.js";import{d as T}from"./FeatureSet-DyOnd9Rj.js";import"./Evented-CXIxDjmW.js";import"./Accessor-D6mNnsWy.js";import"./geometry-DpwwkAX1.js";import"./Polyline-D97hl-6E.js";import"./writer-3zufXUNV.js";import"./mathUtils-ClvKsMak.js";import"./jsonMap-DCC6W5ex.js";import"./PopupTemplate-ByHks6sq.js";import"./Clonable-cKbRam6-.js";import"./reactiveUtils-BFQ0BtrB.js";import"./shared-B3wH2qpO.js";import"./assets-C2mb-ea2.js";import"./index-CeCSsEgo.js";import"./fieldUtils-CNduWQU9.js";import"./intl-Dpfm8vPB.js";import"./Promise-CZrWwByK.js";import"./enumeration--HlxOQ_N.js";import"./Color-DDUWtbqR.js";import"./colorUtils-CS9vdHXB.js";import"./ActionToggle-C0Z1k2jc.js";import"./Identifiable-BLvpQbOc.js";import"./symbols-CsUQ5BxR.js";import"./TextSymbol-gKE-H_J6.js";import"./screenUtils-PfxkaaMN.js";import"./materialUtils-CQ3JLQ1x.js";import"./opacityUtils-BT7mQkwC.js";import"./aaBoundingBox-rJEWaOSN.js";import"./persistableUrlUtils-BcifXQ1Z.js";import"./collectionUtils-Dm1icNvk.js";import"./Portal-liet8xHC.js";import"./jsonUtils-Cma_7A64.js";import"./axisAngleDegrees-CHCWDIqP.js";import"./mat4-ybYUU6jq.js";import"./quat-ChS85qAG.js";import"./mat3f64-BBpwCtoL.js";import"./quatf64-BrpT0VRp.js";import"./vec42-B1mBkh1w.js";import"./vec4f64-CBQL1T0x.js";import"./MeshComponent-D1ps11B9.js";import"./imageUtils-9KeT6Jbh.js";import"./MeshVertexAttributes-DVEL_Tlm.js";import"./MeshLocalVertexSpace-Xt9zU6DE.js";import"./meshVertexSpaceUtils-CtidK-ZY.js";import"./triangulationUtils-D8OjVISe.js";import"./earcut-BqgeR2O3.js";import"./_commonjsHelpers-DCkdB7M8.js";import"./DoubleArray-CF_CpVBS.js";import"./Indices-B6BGScAS.js";import"./plane-Bz78OrLf.js";import"./mat4f64-Dk4dwAN8.js";import"./vec2f64-Diu2Kaa8.js";import"./mathUtils-kvswLROa.js";import"./deduplicate-DxTSMkFY.js";import"./projection-CJ-ESJIf.js";import"./mat3-DRqs2t5W.js";import"./projection-A9yUaaTs.js";import"./projectBuffer-vsa0P_cF.js";import"./geodesicConstants-XRAvAZCD.js";import"./spatialReferenceEllipsoidUtils-BL8s_3ls.js";import"./computeTranslationToOriginAndRotation-CLzktXYu.js";import"./BufferView-B7Z-dzh4.js";import"./vec2-B_ymkwGp.js";import"./vec3-C3Q-RF_i.js";import"./vec4-L9zJLV3y.js";import"./projectPointToVector-D3506wm2.js";import"./vertexSpaceConversion-DhlFeppE.js";import"./Field-C8SaaeoI.js";import"./fieldType-CIG5ey7e.js";const I=()=>h.getLogger("esri.rest.support.meshFeatureSet");function er(t,r,o){const e=o.features;o.features=[],delete o.geometryType;const i=T.fromJSON(o);if(i.geometryType="mesh",!o.assetMaps)return i;const n=A(r,o.assetMaps),m=t.sourceSpatialReference??S.WGS84,u=o.globalIdFieldName,{outFields:s}=t,f=s!=null&&s.length>0?L(s.includes("*")?null:new Set(s)):()=>({});for(const p of e){const a=O(p,u,m,r,n);i.features.push(new E({geometry:a,attributes:f(p)}))}return i}function L(t){return({attributes:r})=>{if(!r)return{};if(!t)return r;for(const o in r)t.has(o)||delete r[o];return r}}function O(t,r,o,e,i){const n=t.attributes[r],m=i.get(n);if(m==null||!t.geometry)return null;const u=$(t,o,e),s=y.fromJSON(t.geometry);s.spatialReference=o;const f=x(t.attributes,e),p=o.isGeographic?"local":"georeferenced",a=P(m);return a?d.createWithExternalSource(u,a,{extent:s,transform:f,vertexSpace:p}):d.createIncomplete(u,{extent:s,transform:f,vertexSpace:p})}function $({attributes:t},r,{transformFieldRoles:o}){const e=t[o.originX],i=t[o.originY],n=t[o.originZ];return new N({x:e,y:i,z:n,spatialReference:r})}function x(t,{transformFieldRoles:r}){return new w({translation:[t[r.translationX],-t[r.translationZ],t[r.translationY]],rotationAxis:[t[r.rotationX],-t[r.rotationZ],t[r.rotationY]],rotationAngle:t[r.rotationDeg],scale:[t[r.scaleX],t[r.scaleZ],t[r.scaleY]]})}var c;function A(t,r){const o=new Map;for(const e of r){const i=e.parentGlobalId;if(i==null)continue;const n=e.assetName,m=e.assetType,u=e.assetHash,s=e.assetURL,f=e.conversionStatus,p=e.seqNo,a=F(m,t.supportedFormats);if(!a){I().error("mesh-feature-set:unknown-format",`Service returned an asset of type ${m}, but it does not list it as a supported type`);continue}const g=l(o,i,()=>({files:new Map}));l(g.files,n,()=>({name:n,type:m,mimeType:a,status:b(f),parts:[]})).parts[p]={hash:u,url:s}}return o}function P(t){const r=Array.from(t.files.values()),o=new Array;for(const e of r){if(e.status!==c.COMPLETED)return null;const i=new Array;for(const n of e.parts){if(!n)return null;i.push(new D(n.url,n.hash))}o.push(new M(e.name,e.mimeType,i))}return o}function b(t){switch(t){case"COMPLETED":case"SUBMITTED":return c.COMPLETED;case"INPROGRESS":return c.PENDING;default:return c.FAILED}}(function(t){t[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"})(c||(c={}));export{A as assetMapFromAssetMapsJSON,O as extractMesh,er as meshFeatureSetFromJSON};
