import{P as J}from"./cast-BA_-jlhc.js";import{_ as N}from"./reactiveUtils-BR0C1Kq4.js";import{V as G,s as K,B as Q}from"./Accessor-BHnuXKD2.js";import{u as W}from"./memoryEstimations-5gFNwkKK.js";import{t as X}from"./NestedMap-GuqgquCN.js";import{r as S}from"./Version-9k2AOv05.js";import{u as C}from"./vec3f64-BLpZdpfb.js";import{q as Y,l as j}from"./aaBoundingBox-CeBivBRq.js";import{o as Z}from"./Indices-Db9lERgy.js";import{t as ee}from"./requestImageUtils-Brn0e8z8.js";import{t as re}from"./Attribute-B-NAci_J.js";import{e as te,i as g}from"./basicInterfaces-CZwQPxTp.js";import{N as ne,f as ae}from"./FloatArray-BCfeX8wo.js";import{e as B}from"./VertexAttribute-Cq4MnHjR.js";import{z as se}from"./DefaultMaterial-B5sYRDQR.js";import{D}from"./enums-D9v74xTE.js";const m=()=>Q.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class oe{constructor(e,n,r){this.resource=e,this.textures=n,this.cachedMemory=r}}async function ke(t,e){const n=await ie(t,e),r=await pe(n.textureDefinitions??{},e);let u=0;for(const o in r)if(r.hasOwnProperty(o)){const a=r[o];u+=a!=null&&a.image?a.image.width*a.image.height*4:0}return new oe(n,r,u+W(n))}async function ie(t,e){const n=e==null?void 0:e.streamDataRequester;if(n)return ue(t,n,e);const r=await N(J(t,e));if(r.ok===!0)return r.value.data;G(r.error),F(r.error)}async function ue(t,e,n){const r=await N(e.request(t,"json",n));if(r.ok===!0)return r.value;G(r.error),F(r.error.details.url)}function F(t){throw new K("",`Request for object resource failed: ${t}`)}function le(t){const e=t.params,n=e.topology;let r=!0;switch(e.vertexAttributes||(m().warn("Geometry must specify vertex attributes"),r=!1),e.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const o=e.faces;if(o){if(e.vertexAttributes)for(const a in e.vertexAttributes){const i=o[a];i!=null&&i.values?(i.valueType!=null&&i.valueType!=="UInt32"&&(m().warn(`Unsupported indexed geometry indices type '${i.valueType}', only UInt32 is currently supported`),r=!1),i.valuesPerElement!=null&&i.valuesPerElement!==1&&(m().warn(`Unsupported indexed geometry values per element '${i.valuesPerElement}', only 1 is currently supported`),r=!1)):(m().warn(`Indexed geometry does not specify face indices for '${a}' attribute`),r=!1)}}else m().warn("Indexed geometries must specify faces"),r=!1;break}default:m().warn(`Unsupported topology '${n}'`),r=!1}t.params.material||(m().warn("Geometry requires material"),r=!1);const u=t.params.vertexAttributes;for(const o in u)u[o].values||(m().warn("Geometries with externally defined attributes are not yet supported"),r=!1);return r}function Ee(t,e){var U,$;const n=new Array,r=new Array,u=new Array,o=new X,a=t.resource,i=S.parse(a.version||"1.0","wosr");fe.validate(i);const P=a.model.name,w=a.model.geometries,x=a.materialDefinitions??{},v=t.textures;let b=0;const d=new Map;for(let I=0;I<w.length;I++){const y=w[I];if(!le(y))continue;const k=me(y),M=y.params.vertexAttributes,O=[],_=s=>{if(y.params.topology==="PerAttributeArray")return null;const l=y.params.faces;for(const p in l)if(p===s)return l[p].values;return null},E=M[B.POSITION],z=E.values.length/E.valuesPerElement;for(const s in M){const l=M[s],p=l.values,T=_(s)??Z(z);O.push([s,new re(p,T,l.valuesPerElement,!0)])}const f=k.texture,c=v&&v[f];if(c&&!d.has(f)){const{image:s,parameters:l}=c,p=new ne(s,l);r.push(p),d.set(f,p)}const q=d.get(f),L=q?q.id:void 0,A=k.material;let h=o.get(A,f);if(h==null){const s=x[A.slice(A.lastIndexOf("/")+1)].params;s.transparency===1&&(s.transparency=0);const l=c&&c.alphaChannelUsage,p=s.transparency>0||l==="transparency"||l==="maskAndTransparency",T=c?V(c.alphaChannelUsage):void 0,R={ambient:C(s.diffuse),diffuse:C(s.diffuse),opacity:1-(s.transparency||0),transparent:p,textureAlphaMode:T,textureAlphaCutoff:.33,textureId:L,doubleSided:!0,cullFace:te.None,colorMixMode:s.externalColorMixMode||"tint",textureAlphaPremultiplied:(c==null?void 0:c.parameters.preMultiplyAlpha)??!1};e!=null&&e.materialParameters&&Object.assign(R,e.materialParameters),h=new se(R,e),o.set(A,f,h)}u.push(h);const H=new ae(h,O);b+=(($=(U=O.find(s=>s[0]===B.POSITION))==null?void 0:U[1])==null?void 0:$.indices.length)??0,n.push(H)}return{engineResources:[{name:P,stageResources:{textures:r,materials:u,geometries:n},pivotOffset:a.model.pivotOffset,numberOfVertices:b,lodThreshold:null}],referenceBoundingBox:ce(n)}}function ce(t){const e=Y();return t.forEach(n=>{const r=n.boundingInfo;r!=null&&(j(e,r.bbMin),j(e,r.bbMax))}),e}async function pe(t,e){const n=new Array;for(const o in t){const a=t[o],i=a.images[0].data;if(!i){m().warn("Externally referenced texture data is not yet supported");continue}const P=a.encoding+";base64,"+i,w="/textureDefinitions/"+o,x=a.channels==="rgba"?a.alphaChannelUsage||"transparency":"none",v={noUnpackFlip:!0,wrap:{s:D.REPEAT,t:D.REPEAT},preMultiplyAlpha:V(x)!==g.Opaque},b=e!=null&&e.disableTextures?Promise.resolve(null):ee(P,e);n.push(b.then(d=>({refId:w,image:d,parameters:v,alphaChannelUsage:x})))}const r=await Promise.all(n),u={};for(const o of r)u[o.refId]=o;return u}function V(t){switch(t){case"mask":return g.Mask;case"maskAndTransparency":return g.MaskBlend;case"none":return g.Opaque;default:return g.Blend}}function me(t){const e=t.params;return{id:1,material:e.material,texture:e.texture,region:e.texture}}const fe=new S(1,2,"wosr");export{Ee as E,ke as j};
