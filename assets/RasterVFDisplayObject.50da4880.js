import{m as T,r as u,w as D,du as b,dv as W,bi as V,bg as v,bj as F,a1 as C,af as h,ag as c,ah as L,ad as E,I as j,ap as q,cL as B,O as R,L as N,dr as U,cP as y,cV as J,be as G,bh as f,ce as H,bf as K}from"./vendor.85f7dae5.js";import{y as A,F as O,D as $}from"./dataUtils.913cc7bb.js";import{b as Q,i as X}from"./WGLContainer.58232395.js";import{I as Y,d as Z}from"./Utils.c81af201.js";import{a as I}from"./Container.710b0eab.js";import{c as S,f as P}from"./VertexArrayObject.37b5010e.js";import{C as m,F as w}from"./enums.457e23f9.js";import{t as x}from"./VertexElementDescriptor.0406f2d4.js";class ee extends Q{constructor(){super(...arguments),this.flowStyle=null}get requiresDedicatedFBO(){return!1}doRender(e){super.doRender(e)}prepareRenderPasses(e){const t=e.registerRenderPass({name:"flow",brushes:[X],target:()=>this.children,drawPhase:Y.MAP});return[...super.prepareRenderPasses(e),t]}}const te=T.getLogger("esri.views.2d.engine.flow.FlowDisplayData");class ie{constructor(e,t,s,a){this.state={name:"created"},this.flowStyle=e,this.extent=t,this.size=s,this.pixelRatio=a}async load(){const e=new AbortController;this.state={name:"loading",abortController:e};const t=await this.flowStyle.loadResources({extent:this.extent,size:this.size,pixelRatio:this.pixelRatio},e.signal);this.state={name:"loaded",resources:t}}prepareForRendering(e){if(this.state.name!=="loaded")return void te.error("Only loaded resources can be attached.");const t=this.state.resources;t.prepareForRendering(e),this.state={name:"attached",resources:t}}destroy(){if(this.state.name==="loading")return this.state.abortController.abort(),void(this.state={name:"detached"});this.state.name==="attached"&&(this.state.resources.detach(),this.state={name:"detached"})}update(e){return this.flowStyle.areResourcesCompatible(e.flowStyle)?!(!this.extent.equals(e.extent)||this.size[0]!==e.size[0]||this.size[1]!==e.size[1]||this.pixelRatio!==e.pixelRatio)&&(this.flowStyle=e.flowStyle,!0):!1}}class se extends I{constructor(){super(...arguments),this._displayData=null}get displayData(){return this._displayData}set displayData(e){this._displayData=e,this.requestRender()}clear(){u(this._displayData)&&(this._displayData.destroy(),this._displayData=null,this.requestRender())}setTransform(e){const{displayData:t}=this;if(D(t))return;const s=t.extent.xmin,a=t.extent.ymax,n=[0,0];e.toScreen(n,[s,a]);const r=(t.extent.xmax-t.extent.xmin)/t.size[0]/e.resolution,l=b(e.rotation),{dvs:o}=this.transforms;W(o,[-1,1,0]),V(o,o,[2/(e.size[0]*e.pixelRatio),-2/(e.size[1]*e.pixelRatio),1]),v(o,o,[n[0],n[1],0]),F(o,o,l),V(o,o,[r*e.pixelRatio,r*e.pixelRatio,1])}_createTransforms(){return{dvs:C()}}}const ae=1.15,re=T.getLogger("esri.views.2d.engine.flow.FlowStrategy");let g=class extends E{constructor(i){super(i),this._flowDisplayObject=new se,this._loading=null}initialize(){this.flowContainer.addChild(this._flowDisplayObject)}destroy(){this._clear(),this.flowContainer.removeAllChildren()}get updating(){return this._loading!=null}update(i){const{flowStyle:e}=this.flowContainer;if(D(e))return void this._clear();const{extent:t,rotation:s,resolution:a,pixelRatio:n}=i.state,r=oe(t,s);r.expand(ae);const l=[Math.round((r.xmax-r.xmin)/a),Math.round((r.ymax-r.ymin)/a)],o=new ie(e,r,l,n);if(u(this._loading)){if(this._loading.update(o))return;this._loading.destroy(),this._loading=null}!D(this._flowDisplayObject.displayData)&&this._flowDisplayObject.displayData.update(o)||(o.load().then(()=>{this._flowDisplayObject.clear(),this._flowDisplayObject.displayData=this._loading,this._loading=null},p=>{j(p)||(re.error("A resource failed to load.",p),this._loading=null)}),this._loading=o)}_clear(){this._flowDisplayObject.clear(),u(this._loading)&&(this._loading.destroy(),this._loading=null)}};h([c()],g.prototype,"_loading",void 0),h([c()],g.prototype,"flowContainer",void 0),h([c()],g.prototype,"updating",null),g=h([L("esri.views.2d.engine.flow.FlowStrategy")],g);const ne=g;function oe(i,e){const t=new q({x:(i.xmax+i.xmin)/2,y:(i.ymax+i.ymin)/2,spatialReference:i.spatialReference}),s=i.xmax-i.xmin,a=i.ymax-i.ymin,n=Math.abs(Math.cos(b(e))),r=Math.abs(Math.sin(b(e))),l=n*s+r*a,o=r*s+n*a,p=new B({xmin:t.x-l/2,ymin:t.y-o/2,xmax:t.x+l/2,ymax:t.y+o/2,spatialReference:i.spatialReference});return p.centerAt(t),p}const _=new Map;_.set("a_positionAndSide",0),_.set("a_timeInfo",1),_.set("a_extrude",2),_.set("a_speed",3);const le={geometry:[new x("a_positionAndSide",3,m.FLOAT,0,36),new x("a_timeInfo",3,m.FLOAT,12,36),new x("a_extrude",2,m.FLOAT,24,36),new x("a_speed",1,m.FLOAT,32,36)]};class he{constructor(e,t,s){this.values=s,this._vertexData=e,this._indexData=t}prepareForRendering(e){const t=S.createVertex(e,w.STATIC_DRAW,this._vertexData),s=S.createIndex(e,w.STATIC_DRAW,this._indexData),a=new P(e,_,le,{geometry:t},s);this.vertexBuffer=t,this.indexBuffer=s,this.vertexArray=a,this._vertexData=null,this._indexData=null}detach(){this.vertexArray.dispose(),this.vertexBuffer.dispose(),this.indexBuffer.dispose()}get locations(){return _}}function de(i){const e=ue(i),t=ce(e),s=2*t,a=Math.round(R(i.maxPathLength)/s)+1,n=t,r=10,l=pe(i),o=me(i),{flowSpeed:p,trailLength:M,density:k}=i;return{lineRenderWidth:e,segmentLength:s,verticesPerLine:a,lineCollisionWidth:n,lineSpacing:r,lineColor:l,lineOpacity:o,lineSpeed:p,fadeDuration:M,density:k,smoothing:R(i.smoothing),velocityScale:i.flowRepresentation==="flow-from"?1:-1,minWeightThreshold:.001,minSpeedThreshold:.001,maxTurnAngle:1,mergeLines:!0,interpolate:!0,profile:!1}}function ce(i){return i.kind==="constant"?i.value[0]:i.values[i.values.length-1]}function z(i){const e=i.toRgba();return[e[0]/255,e[1]/255,e[2]/255,e[3]]}function ue(i){if(!i.hasVisualVariables("size"))return{kind:"constant",value:[R(i.trailWidth)]};const e=i.getVisualVariablesForType("size")[0],t=[],s=[];let a;if(e.stops){for(const n of e.stops)t.push(n.value),s.push(n.size);a=e.stops.length}else t.push(e.minDataValue,e.maxDataValue),s.push(e.minSize,e.maxSize),a=2;return{kind:"ramp",stops:t,values:s,count:a}}function pe(i){if(!i.hasVisualVariables("color"))return{kind:"constant",value:z(i.color)};const e=i.getVisualVariablesForType("color")[0],t=[],s=[];for(const a of e.stops)t.push(a.value),Array.prototype.push.apply(s,z(a.color));return{kind:"ramp",stops:t,values:s,count:e.stops.length}}function me(i){if(!i.hasVisualVariables("opacity"))return{kind:"constant",value:[1]};const e=i.getVisualVariablesForType("opacity")[0],t=[],s=[];for(const a of e.stops)t.push(a.value),s.push(a.opacity);return{kind:"ramp",stops:t,values:s,count:e.stops.length}}class ge{constructor(e,t,s,a){this._loadImagery=e,this._createStreamlinesMesh=t,this._timeExtent=a,this._rendererSettings=de(s)}get animated(){return this._rendererSettings.lineSpeed>0}get renderSettings(){return this._rendererSettings}areResourcesCompatible(e){let t=!0;return t=t&&e._loadImagery===this._loadImagery,t=t&&e._createStreamlinesMesh===this._createStreamlinesMesh,t=t&&e._rendererSettings.verticesPerLine===this._rendererSettings.verticesPerLine,t=t&&e._rendererSettings.segmentLength===this._rendererSettings.segmentLength,t=t&&e._rendererSettings.lineSpacing===this._rendererSettings.lineSpacing,t=t&&e._rendererSettings.density===this._rendererSettings.density,t=t&&e._rendererSettings.smoothing===this._rendererSettings.smoothing,t=t&&e._rendererSettings.velocityScale===this._rendererSettings.velocityScale,t=t&&e._rendererSettings.minWeightThreshold===this._rendererSettings.minWeightThreshold,t=t&&e._rendererSettings.minSpeedThreshold===this._rendererSettings.minSpeedThreshold,t=t&&e._rendererSettings.mergeLines===this._rendererSettings.mergeLines,t=t&&e._rendererSettings.velocityScale===this._rendererSettings.velocityScale,t=t&&e._rendererSettings.interpolate===this._rendererSettings.interpolate,t=t&&e._rendererSettings.lineColor.kind===this._rendererSettings.lineColor.kind,t=t&&e._rendererSettings.lineOpacity.kind===this._rendererSettings.lineOpacity.kind,t=t&&e._rendererSettings.lineRenderWidth.kind===this._rendererSettings.lineRenderWidth.kind,t&&this._rendererSettings.mergeLines&&(t=e._rendererSettings.lineCollisionWidth===this._rendererSettings.lineCollisionWidth),t&&e._timeExtent!==this._timeExtent&&(t=!(!u(e._timeExtent)||!u(this._timeExtent))&&e._timeExtent.equals(this._timeExtent)),t}async loadResources(e,t){const{extent:s,size:a}=e;N(t);const n=await this._loadImagery(s,a[0],a[1],this._timeExtent,t),{vertexData:r,indexData:l}=await this._createStreamlinesMesh(this._rendererSettings,n,t);return new he(r,l,{lineColor:this._rendererSettings.lineColor,lineOpacity:this._rendererSettings.lineOpacity,lineRenderWidth:this._rendererSettings.lineRenderWidth})}}let d=class extends U{constructor(){super(...arguments),this._loadImagery=(i,e,t,s,a)=>A(this.layer,i,e,t,s,a),this._createStreamlinesMesh=(i,e,t)=>this.layer.createStreamlinesMesh({flowData:e,rendererSettings:i},{signal:t}),this.attached=!1,this.container=null,this.layer=null,this.type="flow",this.timeExtent=null,this.redrawOrRefetch=async()=>{this._updateVisualization()}}get updating(){return!this._strategy||this._strategy.updating}attach(){const{layer:i}=this,e=()=>{this._loadImagery=(t,s,a,n,r)=>A(i,t,s,a,n,r),this._updateVisualization()};"multidimensionalDefinition"in i?this.handles.add(y(()=>i.multidimensionalDefinition,e)):this.handles.add([y(()=>i.mosaicRule,e),y(()=>i.renderingRule,e),y(()=>i.definitionExpression,e)]),this.container=new ee,this._strategy=new ne({flowContainer:this.container}),this._updateVisualization()}detach(){this._strategy.destroy(),this.container.removeAllChildren(),this.container=null,this.handles.removeAll()}update(i){i.stationary?this._strategy.update(i):this.layerView.requestUpdate()}hitTest(i){return new J({attributes:{},geometry:i.clone(),layer:this.layer})}moveEnd(){}async doRefresh(){}_updateVisualization(){if(this.layer.renderer.type!=="flow")return;const i=new ge(this._loadImagery,this._createStreamlinesMesh,this.layer.renderer,this.timeExtent);this.container.flowStyle=i,this.layerView.requestUpdate()}};h([c()],d.prototype,"_strategy",void 0),h([c()],d.prototype,"attached",void 0),h([c()],d.prototype,"container",void 0),h([c()],d.prototype,"layer",void 0),h([c()],d.prototype,"layerView",void 0),h([c()],d.prototype,"type",void 0),h([c()],d.prototype,"updating",null),h([c()],d.prototype,"timeExtent",void 0),d=h([L("esri.views.2d.engine.flow.FlowView2D")],d);const be=d;class Re extends I{constructor(e=null){super(),this._source=null,this._symbolizerParameters=null,this._vaoInvalidated=!0,this.coordScale=[1,1],this.height=null,this.stencilRef=0,this.resolution=null,this.pixelRatio=1,this.x=0,this.y=0,this.rotation=0,this.rawPixelData=null,this.width=null,this.source=e}destroy(){var e,t;u(this.vaoData)&&((e=this.vaoData.magdir)==null||e.vao.dispose(),(t=this.vaoData.scalar)==null||t.vao.dispose(),this.vaoData=null)}get symbolizerParameters(){return this._symbolizerParameters}set symbolizerParameters(e){JSON.stringify(this._symbolizerParameters)!==JSON.stringify(e)&&(this._symbolizerParameters=e,this.invalidateVAO())}get source(){return this._source}set source(e){this._source=e,this.invalidateVAO()}invalidateVAO(){var e,t;!this._vaoInvalidated&&u(this.vaoData)&&((e=this.vaoData.magdir)==null||e.vao.dispose(),(t=this.vaoData.scalar)==null||t.vao.dispose(),this.vaoData=null,this._vaoInvalidated=!0,this.requestRender())}updateVectorFieldVAO(e){if(this._vaoInvalidated){if(this._vaoInvalidated=!1,u(this.source)&&!u(this.vaoData)){const{style:t}=this.symbolizerParameters;switch(t){case"beaufort_ft":case"beaufort_km":case"beaufort_kn":case"beaufort_m":case"beaufort_mi":case"classified_arrow":case"ocean_current_kn":case"ocean_current_m":case"single_arrow":{const s=O(this.source,this.symbolizerParameters),a=this._createVectorFieldVAO(e.context,s);this.vaoData={magdir:a}}break;case"simple_scalar":{const s=$(this.source,this.symbolizerParameters),a=this._createVectorFieldVAO(e.context,s);this.vaoData={scalar:a}}break;case"wind_speed":{const s=O(this.source,this.symbolizerParameters),a=this._createVectorFieldVAO(e.context,s),n=$(this.source,this.symbolizerParameters),r=this._createVectorFieldVAO(e.context,n);this.vaoData={magdir:a,scalar:r}}}}this.ready(),this.requestRender()}}_createTransforms(){return{dvs:C()}}setTransform(e){const t=G(this.transforms.dvs),[s,a]=e.toScreenNoRotation([0,0],[this.x,this.y]),n=this.resolution/this.pixelRatio/e.resolution,r=n*this.width,l=n*this.height,o=Math.PI*this.rotation/180;v(t,t,f(s,a)),v(t,t,f(r/2,l/2)),F(t,t,-o),v(t,t,f(-r/2,-l/2)),H(t,t,f(r,l)),K(this.transforms.dvs,e.displayViewMat3,t)}onAttach(){this.invalidateVAO()}onDetach(){this.invalidateVAO()}_createVectorFieldVAO(e,t){const{vertexData:s,indexData:a}=t,n=S.createVertex(e,w.STATIC_DRAW,new Float32Array(s)),r=S.createIndex(e,w.STATIC_DRAW,new Uint32Array(a)),l=Z("vector-field",{geometry:[{location:0,name:"a_pos",count:2,type:m.FLOAT,normalized:!1},{location:1,name:"a_offset",count:2,type:m.FLOAT,normalized:!1},{location:2,name:"a_vv",count:2,type:m.FLOAT,normalized:!1}]});return{vao:new P(e,l.attributes,l.bufferLayouts,{geometry:n},r),elementCount:a.length}}}export{Re as _,be as d};
