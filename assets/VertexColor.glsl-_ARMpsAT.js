import{s as je}from"./vec42-YcqnINSP.js";import{n as He}from"./vec4f64-o2zAXfmz.js";import{o as ee,R as oe,s as me,_ as Re,A as Ae}from"./vec32-Dvg_eL9J.js";import{n as W}from"./vec3f64-BLpZdpfb.js";import{h as Ne,n as ae}from"./Matrix3DrawUniform-CiBFaSz6.js";import{o as A,t as Ge}from"./interfaces-DDtDqZYj.js";import{f as We,e as Je,m as Ye,v as Ke,c as Xe}from"./Texture-Fac_8AOC.js";import{F as ie,S as Qe}from"./Accessor-BLX9ikPh.js";import{O as _e}from"./renderState-DQLu6AJX.js";import{u as Ze,S as et,Z as tt}from"./aaBoundingBox-BE7cC1jD.js";import{e as rt}from"./Material-_xx7OZxD.js";import{s as E}from"./Util-BIfApRF5.js";import{e as V}from"./VertexAttribute-Cq4MnHjR.js";import{H as Ce,G as Le}from"./mat4-GpOFENPA.js";import{x as Be,c as Me,y as st,u as it,q as nt,i as Pe}from"./BufferView-_QDXRCew.js";function ot(t){t.vertex.code.add(A`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`),t.vertex.code.add(A`vec3 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec3 params) {
return vec3(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z
);
}`),t.vertex.code.add(A`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`),t.vertex.code.add(A`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`),t.vertex.code.add(A`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`),t.vertex.code.add(A`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`)}function Yt(t){t.uniforms.add(new Ne("screenSizePerspective",e=>Ee(e.screenSizePerspective)))}function ct(t){t.uniforms.add(new Ne("screenSizePerspectiveAlignment",e=>Ee(e.screenSizePerspectiveAlignment||e.screenSizePerspective)))}function Ee(t){return ee(at,t.parameters.divisor,t.parameters.offset,t.minScaleFactor)}const at=W();function Kt(t,e){const i=t.vertex;e.hasVerticalOffset?(ut(i),e.hasScreenSizePerspective&&(t.include(ot),ct(i),We(t.vertex,e)),i.code.add(A`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${e.spherical?A`vec3 worldNormal = normalize(worldPos + localOrigin);`:A`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${e.hasScreenSizePerspective?A`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);`:A`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)):i.code.add(A`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`)}const lt=He();function ut(t){t.uniforms.add(new Je("verticalOffset",(e,i)=>{const{minWorldLength:r,maxWorldLength:c,screenLength:s}=e.verticalOffset,n=Math.tan(.5*i.camera.fovY)/(.5*i.camera.fullViewport[3]),o=i.camera.pixelRatio||1;return je(lt,s*o,n,r,c)}))}let Xt=class extends Ye{constructor(e){super(e),this._numLoading=0,this._disposed=!1,this._textures=e.textures,this._textureId=e.textureId,this._acquire(e.textureId,i=>this._texture=i),this._acquire(e.normalTextureId,i=>this._textureNormal=i),this._acquire(e.emissiveTextureId,i=>this._textureEmissive=i),this._acquire(e.occlusionTextureId,i=>this._textureOcclusion=i),this._acquire(e.metallicRoughnessTextureId,i=>this._textureMetallicRoughness=i)}dispose(){super.dispose(),this._texture=ie(this._texture),this._textureNormal=ie(this._textureNormal),this._textureEmissive=ie(this._textureEmissive),this._textureOcclusion=ie(this._textureOcclusion),this._textureMetallicRoughness=ie(this._textureMetallicRoughness),this._disposed=!0}ensureResources(e){return this._numLoading===0?_e.LOADED:_e.LOADING}get textureBindParameters(){return new dt(this._texture!=null?this._texture.glTexture:null,this._textureNormal!=null?this._textureNormal.glTexture:null,this._textureEmissive!=null?this._textureEmissive.glTexture:null,this._textureOcclusion!=null?this._textureOcclusion.glTexture:null,this._textureMetallicRoughness!=null?this._textureMetallicRoughness.glTexture:null)}updateTexture(e){this._texture!=null&&e===this._texture.id||(this._texture=ie(this._texture),this._textureId=e,this._acquire(this._textureId,i=>this._texture=i))}_acquire(e,i){if(e==null)return void i(null);const r=this._textures.acquire(e);if(Qe(r))return++this._numLoading,void r.then(c=>{if(this._disposed)return ie(c),void i(null);i(c)}).finally(()=>--this._numLoading);i(r)}};class ft extends Ge{constructor(e=null){super(),this.textureEmissive=e}}let dt=class extends ft{constructor(e=null,i=null,r=null,c=null,s=null,n,o){super(r),this.texture=e,this.textureNormal=i,this.textureOcclusion=c,this.textureMetallicRoughness=s,this.scale=n,this.normalTextureTransformMatrix=o}};function er(t,e,i,r=1){const{data:c,indices:s}=t,n=e.typedBuffer,o=e.typedBufferStride,a=s.length;if(i*=o,r===1)for(let l=0;l<a;++l)n[i]=c[s[l]],i+=o;else for(let l=0;l<a;++l){const u=c[s[l]];for(let f=0;f<r;f++)n[i]=u,i+=o}}function Fe(t,e,i){const{data:r,indices:c}=t,s=e.typedBuffer,n=e.typedBufferStride,o=c.length;i*=n;for(let a=0;a<o;++a){const l=2*c[a];s[i]=r[l],s[i+1]=r[l+1],i+=n}}function Ve(t,e,i,r){const{data:c,indices:s}=t,n=e.typedBuffer,o=e.typedBufferStride,a=s.length;if(i*=o,r==null||r===1)for(let l=0;l<a;++l){const u=3*s[l];n[i]=c[u],n[i+1]=c[u+1],n[i+2]=c[u+2],i+=o}else for(let l=0;l<a;++l){const u=3*s[l];for(let f=0;f<r;++f)n[i]=c[u],n[i+1]=c[u+1],n[i+2]=c[u+2],i+=o}}function Ie(t,e,i,r=1){const{data:c,indices:s}=t,n=e.typedBuffer,o=e.typedBufferStride,a=s.length;if(i*=o,r===1)for(let l=0;l<a;++l){const u=4*s[l];n[i]=c[u],n[i+1]=c[u+1],n[i+2]=c[u+2],n[i+3]=c[u+3],i+=o}else for(let l=0;l<a;++l){const u=4*s[l];for(let f=0;f<r;++f)n[i]=c[u],n[i+1]=c[u+1],n[i+2]=c[u+2],n[i+3]=c[u+3],i+=o}}function tr(t,e,i){const r=t.typedBuffer,c=t.typedBufferStride;e*=c;for(let s=0;s<i;++s)r[e]=0,r[e+1]=0,r[e+2]=0,r[e+3]=0,e+=c}function ht(t,e,i,r,c=1){if(!e)return void Ve(t,i,r,c);const{data:s,indices:n}=t,o=i.typedBuffer,a=i.typedBufferStride,l=n.length,u=e[0],f=e[1],O=e[2],B=e[4],T=e[5],N=e[6],S=e[8],C=e[9],_=e[10],M=e[12],P=e[13],y=e[14];r*=a;let z=0,p=0,h=0;const g=Ce(e)?m=>{z=s[m]+M,p=s[m+1]+P,h=s[m+2]+y}:m=>{const d=s[m],x=s[m+1],v=s[m+2];z=u*d+B*x+S*v+M,p=f*d+T*x+C*v+P,h=O*d+N*x+_*v+y};if(c===1)for(let m=0;m<l;++m)g(3*n[m]),o[r]=z,o[r+1]=p,o[r+2]=h,r+=a;else for(let m=0;m<l;++m){g(3*n[m]);for(let d=0;d<c;++d)o[r]=z,o[r+1]=p,o[r+2]=h,r+=a}}function pt(t,e,i,r,c=1){if(!e)return void Ve(t,i,r,c);const{data:s,indices:n}=t,o=e,a=i.typedBuffer,l=i.typedBufferStride,u=n.length,f=o[0],O=o[1],B=o[2],T=o[4],N=o[5],S=o[6],C=o[8],_=o[9],M=o[10],P=!Le(o),y=1e-6,z=1-y;r*=l;let p=0,h=0,g=0;const m=Ce(o)?d=>{p=s[d],h=s[d+1],g=s[d+2]}:d=>{const x=s[d],v=s[d+1],w=s[d+2];p=f*x+T*v+C*w,h=O*x+N*v+_*w,g=B*x+S*v+M*w};if(c===1)if(P)for(let d=0;d<u;++d){m(3*n[d]);const x=p*p+h*h+g*g;if(x<z&&x>y){const v=1/Math.sqrt(x);a[r]=p*v,a[r+1]=h*v,a[r+2]=g*v}else a[r]=p,a[r+1]=h,a[r+2]=g;r+=l}else for(let d=0;d<u;++d)m(3*n[d]),a[r]=p,a[r+1]=h,a[r+2]=g,r+=l;else for(let d=0;d<u;++d){if(m(3*n[d]),P){const x=p*p+h*h+g*g;if(x<z&&x>y){const v=1/Math.sqrt(x);p*=v,h*=v,g*=v}}for(let x=0;x<c;++x)a[r]=p,a[r+1]=h,a[r+2]=g,r+=l}}function vt(t,e,i,r,c=1){if(!e)return void Ie(t,i,r,c);const{data:s,indices:n}=t,o=e,a=i.typedBuffer,l=i.typedBufferStride,u=n.length,f=o[0],O=o[1],B=o[2],T=o[4],N=o[5],S=o[6],C=o[8],_=o[9],M=o[10],P=!Le(o),y=1e-6,z=1-y;if(r*=l,c===1)for(let p=0;p<u;++p){const h=4*n[p],g=s[h],m=s[h+1],d=s[h+2],x=s[h+3];let v=f*g+T*m+C*d,w=O*g+N*m+_*d,$=B*g+S*m+M*d;if(P){const b=v*v+w*w+$*$;if(b<z&&b>y){const F=1/Math.sqrt(b);v*=F,w*=F,$*=F}}a[r]=v,a[r+1]=w,a[r+2]=$,a[r+3]=x,r+=l}else for(let p=0;p<u;++p){const h=4*n[p],g=s[h],m=s[h+1],d=s[h+2],x=s[h+3];let v=f*g+T*m+C*d,w=O*g+N*m+_*d,$=B*g+S*m+M*d;if(P){const b=v*v+w*w+$*$;if(b<z&&b>y){const F=1/Math.sqrt(b);v*=F,w*=F,$*=F}}for(let b=0;b<c;++b)a[r]=v,a[r+1]=w,a[r+2]=$,a[r+3]=x,r+=l}}function mt(t,e,i,r,c=1){const{data:s,indices:n}=t,o=i.typedBuffer,a=i.typedBufferStride,l=n.length;if(r*=a,e!==s.length||e!==4)if(c!==1)if(e!==4)for(let u=0;u<l;++u){const f=3*n[u];for(let O=0;O<c;++O)o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=255,r+=a}else for(let u=0;u<l;++u){const f=4*n[u];for(let O=0;O<c;++O)o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=s[f+3],r+=a}else{if(e===4){for(let u=0;u<l;++u){const f=4*n[u];o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=s[f+3],r+=a}return}for(let u=0;u<l;++u){const f=3*n[u];o[r]=s[f],o[r+1]=s[f+1],o[r+2]=s[f+2],o[r+3]=255,r+=a}}else{o[r]=s[0],o[r+1]=s[1],o[r+2]=s[2],o[r+3]=s[3];const u=new Uint32Array(i.typedBuffer.buffer,i.start),f=a/4,O=u[r/=4];r+=f;const B=l*c;for(let T=1;T<B;++T)u[r]=O,r+=f}}function xt(t,e,i){const{data:r,indices:c}=t,s=e.typedBuffer,n=e.typedBufferStride,o=c.length,a=r[0];i*=n;for(let l=0;l<o;++l)s[i]=a,i+=n}function gt(t,e,i,r,c=1){const s=e.typedBuffer,n=e.typedBufferStride;if(r*=n,c===1)for(let o=0;o<i;++o)s[r]=t[0],s[r+1]=t[1],s[r+2]=t[2],s[r+3]=t[3],r+=n;else for(let o=0;o<i;++o)for(let a=0;a<c;++a)s[r]=t[0],s[r+1]=t[1],s[r+2]=t[2],s[r+3]=t[3],r+=n}function St(t,e,i,r,c,s,n){var o;for(const a of i.fields.keys()){const l=t.get(a),u=l==null?void 0:l.indices;if(l&&u)Ot(a,l,r,c,s,n);else if(a===V.OBJECTANDLAYERIDCOLOR&&e!=null){const f=(o=t.get(V.POSITION))==null?void 0:o.indices;if(f){const O=f.length;gt(e,s.getField(a,Be),O,n)}}}}function Ot(t,e,i,r,c,s){switch(t){case V.POSITION:{E(e.size===3);const n=c.getField(t,Pe);E(!!n,`No buffer view for ${t}`),n&&ht(e,i,n,s);break}case V.NORMAL:{E(e.size===3);const n=c.getField(t,Pe);E(!!n,`No buffer view for ${t}`),n&&pt(e,r,n,s);break}case V.NORMALCOMPRESSED:{E(e.size===2);const n=c.getField(t,nt);E(!!n,`No buffer view for ${t}`),n&&Fe(e,n,s);break}case V.UV0:{E(e.size===2);const n=c.getField(t,it);E(!!n,`No buffer view for ${t}`),n&&Fe(e,n,s);break}case V.COLOR:case V.SYMBOLCOLOR:{const n=c.getField(t,Be);E(!!n,`No buffer view for ${t}`),E(e.size===3||e.size===4),!n||e.size!==3&&e.size!==4||mt(e,e.size,n,s);break}case V.COLORFEATUREATTRIBUTE:{const n=c.getField(t,st);E(!!n,`No buffer view for ${t}`),E(e.size===1),n&&e.size===1&&xt(e,n,s);break}case V.TANGENT:{E(e.size===4);const n=c.getField(t,Me);E(!!n,`No buffer view for ${t}`),n&&vt(e,i,n,s);break}case V.PROFILERIGHT:case V.PROFILEUP:case V.PROFILEVERTEXANDNORMAL:case V.FEATUREVALUE:{E(e.size===4);const n=c.getField(t,Me);E(!!n,`No buffer view for ${t}`),n&&Ie(e,n,s)}}}class wt{constructor(e=!1,i=!0){this.isVerticalRay=e,this.normalRequired=i}}const ue=Ze();function rr(t,e,i,r,c,s){if(!t.visible)return;const n=oe(ke,r,i),o=(l,u,f)=>{s(l,f,u,!1)},a=new wt(!1,e.options.normalRequired);if(t.boundingInfo){E(t.type===rt.Mesh);const l=e.tolerance;qe(t.boundingInfo,i,n,l,c,a,o)}else{const l=t.attributes.get(V.POSITION),u=l.indices;De(i,n,0,u.length/3,u,l.data,l.stride,c,a,o)}}const zt=W();function qe(t,e,i,r,c,s,n){if(t==null)return;const o=Pt(i,zt);if(et(ue,t.bbMin),tt(ue,t.bbMax),c!=null&&c.applyToAabb(ue),Ft(ue,e,o,r)){const{primitiveIndices:a,position:l}=t,u=a?a.length:l.indices.length/3;if(u>Rt){const f=t.getChildren();if(f!==void 0){for(const O of f)qe(O,e,i,r,c,s,n);return}}$t(e,i,0,u,l.indices,l.data,l.stride,a,c,s,n)}}const ne=W();function sr(t,e,i,r,c,s,n,o,a){const{data:l,stride:u}=s;De(t,oe(ke,e,t),i,r,c,l,u,n,o,a)}function ir(t,e,i,r,c,s,n,o,a,l=null,u=0){const f=t[0],O=t[1],B=t[2],T=e[0],N=e[1],S=e[2];for(let C=i;C<r;++C){const _=u+(l?l[C]:C),M=3*_,P=n*c[M],y=s[P],z=s[P+1],p=s[P+2],h=n*c[M+1],g=s[h],m=s[h+1],d=s[h+2],x=n*c[M+2],v=g-y,w=m-z,$=d-p,b=s[x]-y,F=s[x+1]-z,I=s[x+2]-p,U=N*I-F*S,j=S*b-I*T,H=T*F-b*N,R=v*U+w*j+$*H;if(Math.abs(R)<=ge)continue;const D=f-y,k=O-z,G=B-p,L=D*U+k*j+G*H;if(R>0){if(L<0||L>R)continue}else if(L>0||L<R)continue;const J=k*$-w*G,Y=G*v-$*D,K=D*w-v*k,q=T*J+N*Y+S*K;if(R>0){if(q<0||L+q>R)continue}else if(q>0||L+q<R)continue;const X=(b*J+F*Y+I*K)/R;X>=0&&a(X,_,o?xe(v,w,$,b,F,I,ne):null)}}function nr(t,e,i,r,c,s,n,o,a,l,u,f=null,O=0){const B=t[0],T=t[1],N=t[2],S=e[0],C=e[1],_=e[2];for(let M=i;M<r;++M){const P=O+(f?f[M]:M),y=3*P,z=n*c[y],p=s[z],h=s[z+1],g=s[z+2],m=n*c[y+1],d=s[m],x=s[m+1],v=s[m+2],w=n*c[y+2],$=s[w],b=s[w+1],F=s[w+2],I=g-a,U=o/Math.sqrt(p*p+h*h+I*I),j=p+p*U,H=h+h*U,R=g+I*U,D=v-a,k=o/Math.sqrt(d*d+x*x+D*D),G=d+d*k,L=x+x*k,J=v+D*k,Y=F-a,K=o/Math.sqrt($*$+b*b+Y*Y),q=G-j,X=L-H,te=J-R,re=$+$*K-j,Q=b+b*K-H,se=F+Y*K-R,Se=C*se-Q*_,Oe=_*re-se*S,we=S*Q-re*C,Z=q*Se+X*Oe+te*we;if(Math.abs(Z)<=ge)continue;const he=B-j,pe=T-H,ve=N-R,ce=he*Se+pe*Oe+ve*we;if(Z>0){if(ce<0||ce>Z)continue}else if(ce>0||ce<Z)continue;const ze=pe*te-X*ve,$e=ve*q-te*he,be=he*X-q*pe,le=S*ze+C*$e+_*be;if(Z>0){if(le<0||ce+le>Z)continue}else if(le>0||ce+le<Z)continue;const ye=(re*ze+Q*$e+se*be)/Z;ye>=0&&u(ye,P,l?xe(q,X,te,re,Q,se,ne):null)}}function $t(t,e,i,r,c,s,n,o,a,l,u){const f=t[0],O=t[1],B=t[2],T=e[0],N=e[1],S=e[2],{normalRequired:C}=l;for(let _=i;_<r;++_){const M=o[_],P=3*M,y=n*c[P];let z=s[y],p=s[y+1],h=s[y+2];const g=n*c[P+1];let m=s[g],d=s[g+1],x=s[g+2];const v=n*c[P+2];let w=s[v],$=s[v+1],b=s[v+2];a!=null&&([z,p,h]=a.applyToVertex(z,p,h,_),[m,d,x]=a.applyToVertex(m,d,x,_),[w,$,b]=a.applyToVertex(w,$,b,_));const F=m-z,I=d-p,U=x-h,j=w-z,H=$-p,R=b-h,D=N*R-H*S,k=S*j-R*T,G=T*H-j*N,L=F*D+I*k+U*G;if(Math.abs(L)<=ge)continue;const J=f-z,Y=O-p,K=B-h,q=J*D+Y*k+K*G;if(L>0){if(q<0||q>L)continue}else if(q>0||q<L)continue;const X=Y*U-I*K,te=K*F-U*J,re=J*I-F*Y,Q=T*X+N*te+S*re;if(L>0){if(Q<0||q+Q>L)continue}else if(Q>0||q+Q<L)continue;const se=(j*X+H*te+R*re)/L;se>=0&&u(se,M,C?xe(F,I,U,j,H,R,ne):null)}}function De(t,e,i,r,c,s,n,o,a,l){const u=e,f=At,O=Math.abs(u[0]),B=Math.abs(u[1]),T=Math.abs(u[2]),N=O>=B?O>=T?0:2:B>=T?1:2,S=N,C=u[S]<0?2:1,_=(N+C)%3,M=(N+(3-C))%3,P=u[_]/u[S],y=u[M]/u[S],z=1/u[S],p=bt,h=yt,g=_t,{normalRequired:m}=a;for(let d=i;d<r;++d){const x=3*d,v=n*c[x];ee(f[0],s[v+0],s[v+1],s[v+2]);const w=n*c[x+1];ee(f[1],s[w+0],s[w+1],s[w+2]);const $=n*c[x+2];ee(f[2],s[$+0],s[$+1],s[$+2]),o&&(me(f[0],o.applyToVertex(f[0][0],f[0][1],f[0][2],d)),me(f[1],o.applyToVertex(f[1][0],f[1][1],f[1][2],d)),me(f[2],o.applyToVertex(f[2][0],f[2][1],f[2][2],d))),oe(p,f[0],t),oe(h,f[1],t),oe(g,f[2],t);const b=p[_]-P*p[S],F=p[M]-y*p[S],I=h[_]-P*h[S],U=h[M]-y*h[S],j=g[_]-P*g[S],H=g[M]-y*g[S],R=j*U-H*I,D=b*H-F*j,k=I*F-U*b;if((R<0||D<0||k<0)&&(R>0||D>0||k>0))continue;const G=R+D+k;if(G===0)continue;const L=R*(z*p[S])+D*(z*h[S])+k*(z*g[S]);if(L*Math.sign(G)<0)continue;const J=L/G;J>=0&&l(J,d,m?Mt(f):null)}}const bt=W(),yt=W(),_t=W();function xe(t,e,i,r,c,s,n){return ee(fe,t,e,i),ee(de,r,c,s),Re(n,fe,de),Ae(n,n),n}function Mt(t){return oe(fe,t[1],t[0]),oe(de,t[2],t[0]),Re(ne,fe,de),Ae(ne,ne),ne}const fe=W(),de=W();function or(t,e,i){return ee(i,1/(e[0]-t[0]),1/(e[1]-t[1]),1/(e[2]-t[2]))}function Pt(t,e){return ee(e,1/t[0],1/t[1],1/t[2])}function Ft(t,e,i,r){return Tt(t,e,i,r,1/0)}function Tt(t,e,i,r,c){const s=(t[0]-r-e[0])*i[0],n=(t[3]+r-e[0])*i[0];let o=Math.min(s,n),a=Math.max(s,n);const l=(t[1]-r-e[1])*i[1],u=(t[4]+r-e[1])*i[1];if(a=Math.min(a,Math.max(l,u)),a<0||(o=Math.max(o,Math.min(l,u)),o>a))return!1;const f=(t[2]-r-e[2])*i[2],O=(t[5]+r-e[2])*i[2];return a=Math.min(a,Math.max(f,O)),!(a<0)&&(o=Math.max(o,Math.min(f,O)),!(o>a)&&o<c)}const Rt=1e3,ge=1e-7,ke=W(),At=[W(),W(),W()];class cr{constructor(e){this.vertexBufferLayout=e}elementCount(e){return e.get(V.POSITION).indices.length}write(e,i,r,c,s,n){St(r,c,this.vertexBufferLayout,e,i,s,n)}}function Te(t){t.varyings.add("linearDepth","float")}function Nt(t){t.vertex.uniforms.add(new Xe("nearFar",(e,i)=>i.camera.nearFar))}function Ue(t){t.vertex.code.add(A`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`)}function ar(t,e){const{vertex:i}=t;switch(e.output){case ae.Color:case ae.ColorEmission:if(e.receiveShadows)return Te(t),void i.code.add(A`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);break;case ae.Shadow:case ae.ShadowHighlight:case ae.ShadowExcludeHighlight:case ae.ViewshedShadow:return t.include(Ke,e),Te(t),Nt(t),Ue(t),void i.code.add(A`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`)}i.code.add(A`void forwardLinearDepth() {}`)}function lr(t){Ue(t),t.vertex.code.add(A`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`),t.vertex.code.add(A`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function ur(t,e){e.hasVertexColors?(t.attributes.add(V.COLOR,"vec4"),t.varyings.add("vColor","vec4"),t.vertex.code.add(A`void forwardVertexColor() { vColor = color; }`),t.vertex.code.add(A`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)):t.vertex.code.add(A`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`)}export{tr as B,St as E,Ot as F,pt as O,gt as R,mt as S,lr as a,ht as b,Kt as c,er as d,ur as e,ut as f,Ie as g,dt as h,Nt as i,Te as j,Ft as k,ir as l,wt as m,ar as n,ct as o,rr as p,or as q,cr as r,ot as s,Yt as t,Xt as u,Tt as w,sr as x,nr as y};
