const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngine-DGiYLHJy.js","./geometry-D964gYQX.js","./subclass-BZA_h8Db.js","./Extent-Bf3YTe7m.js","./tslib.es6-B3Jf3DVX.js","./Point-Cg0-ChZE.js","./Accessor-BLX9ikPh.js","./cast-Bjksrh93.js","./writer-DNAwXnhG.js","./assets-C43MgM-v.js","./index-Bh2oEzTI.js","./index-2kwcjS9-.css","./jsonMap-0cxwUWs2.js","./Polyline-D9YkgmM_.js","./mathUtils-C4_ghTv4.js","./geometryEngineBase-yFIvKOkM.js","./_commonjsHelpers-DCkdB7M8.js","./hydrated-C9rxSL4a.js"])))=>i.map(i=>d[i]);
import{b as k}from"./asyncUtils-CWX51uTe.js";import{g as q,a as N,m as y,n as O,O as V}from"./subclass-BZA_h8Db.js";import{r as z}from"./featureQueryAll-DnVoEjkM.js";import{I as j,t as G,J as K,M as B}from"./fieldUtils-tmQlKvWo.js";import{r as p}from"./tslib.es6-B3Jf3DVX.js";import{b as C,C as J,p as T,U as M,e as H}from"./Accessor-BLX9ikPh.js";import{watch as Q,initial as W,whenOnce as D}from"./reactiveUtils-C5zUhJQJ.js";import{_ as X}from"./index-Bh2oEzTI.js";import{a as Y,n as Z,b as ee}from"./TemporalSceneLayerView-D_Uh4zcF.js";import{K as te,J as re,_ as ne,W as ie}from"./projection-B971H0Re.js";import{y as oe}from"./LayerView-CGYm21KA.js";const se={setAttribute(){},rollback(){},commit(){}};var E;function ve(e,t){const r=t.attributes[e.objectIdField];if(r==null)return se;const n=e.sessions.get(r);if(n)return n;const o=q(t.attributes),i=new Set,d=e.i3sOverrides.createInteractiveEditSession(r),u=new Map,s=(c,f)=>{const g=u.get(c);if(g==null){const h=f.indexOf(r);return u.set(c,h),h}return g};let a=E.EDITING;const l={setAttribute(c,f){if(a!==E.EDITING)return;const g=e.fieldsIndex.get(c);if(!g)return;const h=e.attributeStorageInfo.findIndex(F=>F.name===g.name);if(h<0)return;if(!(c in o))throw new Error(`Attribute "${c}" is not an attribute of the edited feature.`);d.setAttribute(h,f);const I=e.attributeStorageInfo[h];let b=!1;i.add(c),e.forEachNode((F,x)=>{const _=s(F,x);if(_===-1)return;const v=e.getAttributeData(F.index);if(v){const A=v[I.name];A&&(A[_]=f,e.setAttributeData(F.index,v,t),b=!0)}}),b&&e.clearMemCache()},rollback(){if(a===E.EDITING){for(const c of i)this.setAttribute(c,o[c]);d.remove(),a=E.ROLLED_BACK,e.sessions.delete(r)}},commit(){a===E.EDITING&&(d.remove(),a=E.COMMITTED,e.sessions.delete(r))}};return e.sessions.set(r,l),l}function le(e,t,r){const{gidToFeatureInfo:n,oidToFeatureInfo:o,fieldsIndex:i,objectIdField:d,globalIdField:u,featureOrIdentifierList:s}=r;if(!r.featuresResolved&&s!=null){for(const a of s){const l={feature:null,oid:-1,gid:null};if("attributes"in a){l.feature=a;const c=a.attributes;if(c!=null)for(const f in c){if(l.oid!==-1&&l.gid!=null)break;const g=i.normalizeFieldName(f);g===d&&(l.oid=c[f]??-1),g===u&&(l.gid=c[f])}}else l.oid=a.objectId??-1,l.gid=a.globalId;l.gid!=null&&n.set(l.gid,l),l.oid!==-1&&o.set(l.oid,l)}r.featuresResolved=!0}return(e!==-1?o.get(e):null)??(t!=null?n.get(t):null)}function $(e,t,r,n,o=null,i=!0){const d=[],u={gidToFeatureInfo:new Map,oidToFeatureInfo:new Map,featuresResolved:r==null,fieldsIndex:e.fieldsIndex,objectIdField:e.objectIdField,globalIdField:e.globalIdField,featureOrIdentifierList:r};for(const s of t){if(s.error!=null)continue;const a=s.objectId??-1,l=s.globalId,c=(a===-1||i?le(a,l,u):null)??{feature:null,oid:a,gid:l},f={oid:a===-1?c.oid:a,gid:l??c.gid,feature:c.feature,result:s};if(d.push(f),f.oid===-1&&f.gid!=null&&o!=null&&(f.oid=o.get(f.gid)??-1),f.oid===-1&&f.gid!=null){let g=n.get(f.gid);g==null&&(g=[],n.set(f.gid,g)),g.push(f)}}return d}async function Oe(e,t){var d,u,s;const r=new Map,n=$(e,t.addedFeatures,(d=t.edits)==null?void 0:d.addFeatures,r),o=$(e,t.updatedFeatures,(u=t.edits)==null?void 0:u.updateFeatures,r),i=$(e,t.deletedFeatures,(s=t.edits)==null?void 0:s.deleteFeatures,r,t.globalIdToObjectId,!1);return r.size>0&&await ae(e,r),{adds:n.filter(a=>a.oid!==-1),updates:o.filter(a=>a.oid!==-1),deletes:i.filter(a=>a.oid!==-1)}}async function ae(e,t){const r=e.i3sOverrides.layer.associatedLayer;if((r==null?void 0:r.globalIdField)==null)return;const n=r.createQuery(),{objectIdField:o,globalIdField:i}=r;n.where=Array.from(t.keys()).map(s=>`${i}='${s}'`).join(" OR "),n.returnGeometry=!1,n.outFields=[o,i],n.cacheHint=!1;const d=await k(z(r,n));if(!d.ok)return;const u=d.value.features;for(const s of u){const a=s.attributes[i],l=s.attributes[o];if(a==null||l==null||l===-1)continue;const c=t.get(a);if(c!=null)for(const f of c)f.oid=l}}function Ae(e,t){const r=new Map,n=o=>{for(const{oid:i,feature:d}of o){const u=d==null?void 0:d.geometry;(u==null?void 0:u.type)==="mesh"&&r.set(i,u)}};n(t.adds),n(t.updates);for(const o of t.deletes)r.set(o.oid,null);for(const[o,i]of r)e.i3sOverrides.updateGeometry(o,i)}function Ne(e,t){var f;const r=ue(e,t),n=de(e,t);if(r.size===0&&n.size===0)return;const o=new Map;for(let g=0;g<e.attributeStorageInfo.length;g++)o.set(e.attributeStorageInfo[g].name,g);let i=!1;r.forEach((g,h)=>{const I=e.getAttributeData(h);let b=!1;g.forEach((F,x)=>{const _=I!=null?I[x]:null,v=o.get(x);for(const{featureIndex:A,value:L,featureId:P}of F)_&&(_[A]=L,b=!0,i=!0),e.i3sOverrides.updateAttributeValue(P,v,L)}),b&&e.setAttributeData(h,I,null)}),i&&e.clearMemCache();const{fieldsIndex:d,i3sOverrides:u,objectIdField:s,globalIdField:a}=e,l=(f=u.layer.associatedLayer)==null?void 0:f.infoFor3D,c=new Set(l?[...Object.values(l.assetMapFieldRoles),...Object.values(l.transformFieldRoles)]:[]);for(const[g,h]of n){u.featureAdded(g);const{attributes:I}=h;for(const b in I){if(b!==s&&b!==a&&c.has(b))continue;const F=d.normalizeFieldName(b),x=F!=null?o.get(F):null;if(x==null)continue;const _=I[b];u.updateAttributeValue(g,x,_)}}}function de(e,t){var o;const r=new Map,n=t.adds;if(!n||n.length===0||e.globalIdField==null)return r;for(const i of n){const d=i.oid,u=i.feature;((o=u==null?void 0:u.geometry)==null?void 0:o.type)==="mesh"&&r.set(d,u)}return r}function ue(e,t){const r=t.updates;if(!r||r.length===0)return new R;const n=new R,o=new Map;for(let i=0;i<e.attributeStorageInfo.length;i++)o.set(e.attributeStorageInfo[i].name,i);return e.forEachNode((i,d)=>{for(const u of r){if(u.feature==null)continue;const s=u.feature,a=u.oid,l=d.indexOf(a);for(const c in s.attributes){const f=e.fieldsIndex.normalizeFieldName(c),g=ce(n,i.index,f),h=s.attributes[c];g.push({featureIndex:l,featureId:a,value:h})}}}),n}function ce(e,t,r){const n=fe(e,t),o=r!=null&&n.get(r);if(o)return o;const i=new Array;return n.set(r,i),i}function fe(e,t){const r=e.get(t);if(r)return r;const n=new ge;return e.set(t,n),n}(function(e){e[e.EDITING=0]="EDITING",e[e.ROLLED_BACK=1]="ROLLED_BACK",e[e.COMMITTED=2]="COMMITTED"})(E||(E={}));const ge=Map,R=Map;function $e(){return{requiredFields:{type:[String],readOnly:!0},availableFields:{type:[String],readOnly:!0,get:function(){const{layer:e,layer:{fieldsIndex:t},requiredFields:r}=this;return e.outFields?j(t,[...G(t,e.outFields),...r]):j(t,r)}}}}const U=e=>{let t=class extends e{constructor(){super(...arguments),this._numUpdating=0}get updating(){return this._numUpdating>0}autoUpdateAsync(r,n){const o=J(async i=>{++this._numUpdating;try{const d=await i;this.destroyed||this._set(r,d)}catch{O.getLogger(this).warn(`Async update of "${String(r)}" failed. Async update functions should not throw exceptions.`)}--this._numUpdating});return Q(n,o,W)}};return p([y({readOnly:!0})],t.prototype,"updating",null),p([y()],t.prototype,"_numUpdating",void 0),t=p([N("esri.core.AsyncUpdate")],t),t};let S=class extends U(C){};S=p([N("esri.core.AsyncUpdate")],S);let w=class extends U(C){get layer(){return this.layerView.layer}get requiredFields(){const{layerView:{layer:{fieldsIndex:e},definitionExpressionFields:t},rendererFields:r,labelingFields:n,viewFilterFields:o}=this;return j(e,[...t??[],...r??[],...n??[],...o??[]])}constructor(e){super(e)}initialize(){this.addHandles([this.autoUpdateAsync("rendererFields",async()=>{const{fieldsIndex:e,renderer:t}=this.layer;return t?this._getFieldsAsync(r=>t.collectRequiredFields(r,e)):null}),this.autoUpdateAsync("labelingFields",async()=>{const{layer:e}=this;return e.labelsVisible?this._getFieldsAsync(t=>K(t,e)):null}),this.autoUpdateAsync("viewFilterFields",()=>{const{layer:e,mergedFilter:t}=this.layerView;return this._getFieldsAsync(r=>B(r,e,t))})])}async _getFieldsAsync(e){const t=new Set;try{return await e(t),Array.from(t).sort()}catch(r){return O.getLogger(this).error(r),null}}};p([y()],w.prototype,"layerView",void 0),p([y()],w.prototype,"layer",null),p([y()],w.prototype,"requiredFields",null),p([y()],w.prototype,"rendererFields",void 0),p([y()],w.prototype,"labelingFields",void 0),p([y()],w.prototype,"viewFilterFields",void 0),w=p([N("esri.views.3d.layers.support.SceneLayerViewRequiredFields")],w);let m=class extends oe{constructor(){super(...arguments),this.layer=null,this.filter=null,this._geometryEngine=null,this._projectionEngineLoaded=!1,this._abortController=new AbortController}get availableFields(){return[]}get maximumNumberOfFeatures(){return 0}set maximumNumberOfFeatures(e){throw new Error("Not implemented")}get maximumNumberOfFeaturesExceeded(){return!1}get layerFilter(){return Y(this._layerFilter)}get _layerFilter(){var u;const e=(u=this.layer)==null?void 0:u.filter;if(e==null||e.geometries.length<1)return null;const t=this._geometryEngine;if(t==null||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine)return Z;const r=e.geometries.at(0).spatialReference,n=e.geometries.toArray().map(s=>{try{s=t.simplify(s)}catch{return O.getLogger(this).warnOncePerTick("Failed to simplify scene filter mask polygon. Polygon will be ignored."),null}if(s==null)return null;if(s.spatialReference.equals(r))return s;try{return te(s,r)}catch{return O.getLogger(this).warnOncePerTick("Failed to project scene filter mask polygon. Polygon will be ignored."),null}}).filter(V).sort((s,a)=>s.extent.xmin-a.extent.xmin),o=new Set,i=new Array,d=new Array;for(let s of n){const a=s.extent.xmin;if(i.length=0,o.forEach(l=>{if(a>=l.extent.xmax)return d.push(l),void o.delete(l);s.extent.ymin<=l.extent.ymax&&s.extent.ymax>=l.extent.ymin&&t.intersects(s,l)&&i.push(l)}),i.length>0){i.push(s);try{s=t.union(i)}catch{O.getLogger(this).warnOncePerTick("Failed to unify filter mask polygons. Polygon will be ignored.");continue}i.pop(),i.forEach(l=>o.delete(l))}o.add(s)}return o.forEach(s=>d.push(s)),d.length>0?{spatialRelationship:e.spatialRelationship,geometries:d}:null}get _filterNeedsProjectionEngine(){const e=this.layer.filter;if(e==null||e.geometries.length<=1)return!1;const t=e.geometries.at(0).spatialReference;return e.geometries.some(({spatialReference:r})=>!r.equals(t)&&!re(r,t))}get layerFilterUpdating(){return ee(this._layerFilter)}initialize(){const{signal:e}=this._abortController;D(()=>{var t,r,n;return this.destroyed||!this._geometryEngine&&((n=(r=(t=this.layer)==null?void 0:t.filter)==null?void 0:r.geometries)==null?void 0:n.length)},e).then(async()=>{T(e),this._geometryEngine=await X(()=>import("./geometryEngine-DGiYLHJy.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]),import.meta.url)}).catch(M),this._projectionEngineLoaded=ne(),D(()=>this.destroyed||!this._projectionEngineLoaded&&this._filterNeedsProjectionEngine,e).then(async()=>{T(e),await ie(),this._projectionEngineLoaded=!0}).catch(M)}destroy(){this._abortController=H(this._abortController)}highlight(e){throw new Error("Not implemented")}queryFeatures(e,t){throw new Error("Not implemented")}queryObjectIds(e,t){throw new Error("Not implemented")}queryFeatureCount(e,t){throw new Error("Not implemented")}createQuery(){throw new Error("Not implemented")}queryExtent(e,t){throw new Error("Not implemented")}};p([y()],m.prototype,"layer",void 0),p([y()],m.prototype,"availableFields",null),p([y()],m.prototype,"maximumNumberOfFeatures",null),p([y({readOnly:!0})],m.prototype,"maximumNumberOfFeaturesExceeded",null),p([y()],m.prototype,"filter",void 0),p([y({readOnly:!0})],m.prototype,"layerFilter",null),p([y({readOnly:!0})],m.prototype,"_layerFilter",null),p([y()],m.prototype,"_geometryEngine",void 0),p([y()],m.prototype,"_projectionEngineLoaded",void 0),p([y()],m.prototype,"_filterNeedsProjectionEngine",null),p([y()],m.prototype,"layerFilterUpdating",null),m=p([N("esri.views.layers.SceneLayerView")],m);const Le=m;export{w as a,$e as b,Ae as d,Ne as f,ve as i,Oe as u,Le as w};
