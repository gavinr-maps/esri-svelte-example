import{R as tt,o as st,s as bt,_ as xt,A as It}from"./vec32-Dvg_eL9J.js";import{n as J}from"./vec3f64-BLpZdpfb.js";import{x as At,c as St,y as Vt,u as Pt,q as Ct,i as yt}from"./BufferView-_QDXRCew.js";import{u as $t,S as kt,Z as Ut}from"./aaBoundingBox-CeBivBRq.js";import{e as Dt}from"./Material-Ba8x5bbY.js";import{s as j}from"./InterleavedLayout-Dvj-Snan.js";import{e as G}from"./VertexAttribute-Cq4MnHjR.js";import{H as Et,G as vt}from"./mat4-Fi6iAz29.js";function Me(s,n,f,e=1){const{data:c,indices:t}=s,i=n.typedBuffer,o=n.typedBufferStride,r=t.length;if(f*=o,e===1)for(let l=0;l<r;++l)i[f]=c[t[l]],f+=o;else for(let l=0;l<r;++l){const u=c[t[l]];for(let a=0;a<e;a++)i[f]=u,f+=o}}function Tt(s,n,f){const{data:e,indices:c}=s,t=n.typedBuffer,i=n.typedBufferStride,o=c.length;f*=i;for(let r=0;r<o;++r){const l=2*c[r];t[f]=e[l],t[f+1]=e[l+1],f+=i}}function Ft(s,n,f,e){const{data:c,indices:t}=s,i=n.typedBuffer,o=n.typedBufferStride,r=t.length;if(f*=o,e==null||e===1)for(let l=0;l<r;++l){const u=3*t[l];i[f]=c[u],i[f+1]=c[u+1],i[f+2]=c[u+2],f+=o}else for(let l=0;l<r;++l){const u=3*t[l];for(let a=0;a<e;++a)i[f]=c[u],i[f+1]=c[u+1],i[f+2]=c[u+2],f+=o}}function zt(s,n,f,e=1){const{data:c,indices:t}=s,i=n.typedBuffer,o=n.typedBufferStride,r=t.length;if(f*=o,e===1)for(let l=0;l<r;++l){const u=4*t[l];i[f]=c[u],i[f+1]=c[u+1],i[f+2]=c[u+2],i[f+3]=c[u+3],f+=o}else for(let l=0;l<r;++l){const u=4*t[l];for(let a=0;a<e;++a)i[f]=c[u],i[f+1]=c[u+1],i[f+2]=c[u+2],i[f+3]=c[u+3],f+=o}}function Oe(s,n,f){const e=s.typedBuffer,c=s.typedBufferStride;n*=c;for(let t=0;t<f;++t)e[n]=0,e[n+1]=0,e[n+2]=0,e[n+3]=0,n+=c}function jt(s,n,f,e,c=1){if(!n)return void Ft(s,f,e,c);const{data:t,indices:i}=s,o=f.typedBuffer,r=f.typedBufferStride,l=i.length,u=n[0],a=n[1],M=n[2],L=n[4],I=n[5],z=n[6],O=n[8],w=n[9],A=n[10],E=n[12],v=n[13],S=n[14];e*=r;let R=0,h=0,p=0;const g=Et(n)?y=>{R=t[y]+E,h=t[y+1]+v,p=t[y+2]+S}:y=>{const d=t[y],m=t[y+1],b=t[y+2];R=u*d+L*m+O*b+E,h=a*d+I*m+w*b+v,p=M*d+z*m+A*b+S};if(c===1)for(let y=0;y<l;++y)g(3*i[y]),o[e]=R,o[e+1]=h,o[e+2]=p,e+=r;else for(let y=0;y<l;++y){g(3*i[y]);for(let d=0;d<c;++d)o[e]=R,o[e+1]=h,o[e+2]=p,e+=r}}function Gt(s,n,f,e,c=1){if(!n)return void Ft(s,f,e,c);const{data:t,indices:i}=s,o=n,r=f.typedBuffer,l=f.typedBufferStride,u=i.length,a=o[0],M=o[1],L=o[2],I=o[4],z=o[5],O=o[6],w=o[8],A=o[9],E=o[10],v=!vt(o),S=1e-6,R=1-S;e*=l;let h=0,p=0,g=0;const y=Et(o)?d=>{h=t[d],p=t[d+1],g=t[d+2]}:d=>{const m=t[d],b=t[d+1],B=t[d+2];h=a*m+I*b+w*B,p=M*m+z*b+A*B,g=L*m+O*b+E*B};if(c===1)if(v)for(let d=0;d<u;++d){y(3*i[d]);const m=h*h+p*p+g*g;if(m<R&&m>S){const b=1/Math.sqrt(m);r[e]=h*b,r[e+1]=p*b,r[e+2]=g*b}else r[e]=h,r[e+1]=p,r[e+2]=g;e+=l}else for(let d=0;d<u;++d)y(3*i[d]),r[e]=h,r[e+1]=p,r[e+2]=g,e+=l;else for(let d=0;d<u;++d){if(y(3*i[d]),v){const m=h*h+p*p+g*g;if(m<R&&m>S){const b=1/Math.sqrt(m);h*=b,p*=b,g*=b}}for(let m=0;m<c;++m)r[e]=h,r[e+1]=p,r[e+2]=g,e+=l}}function Ht(s,n,f,e,c=1){if(!n)return void zt(s,f,e,c);const{data:t,indices:i}=s,o=n,r=f.typedBuffer,l=f.typedBufferStride,u=i.length,a=o[0],M=o[1],L=o[2],I=o[4],z=o[5],O=o[6],w=o[8],A=o[9],E=o[10],v=!vt(o),S=1e-6,R=1-S;if(e*=l,c===1)for(let h=0;h<u;++h){const p=4*i[h],g=t[p],y=t[p+1],d=t[p+2],m=t[p+3];let b=a*g+I*y+w*d,B=M*g+z*y+A*d,T=L*g+O*y+E*d;if(v){const x=b*b+B*B+T*T;if(x<R&&x>S){const N=1/Math.sqrt(x);b*=N,B*=N,T*=N}}r[e]=b,r[e+1]=B,r[e+2]=T,r[e+3]=m,e+=l}else for(let h=0;h<u;++h){const p=4*i[h],g=t[p],y=t[p+1],d=t[p+2],m=t[p+3];let b=a*g+I*y+w*d,B=M*g+z*y+A*d,T=L*g+O*y+E*d;if(v){const x=b*b+B*B+T*T;if(x<R&&x>S){const N=1/Math.sqrt(x);b*=N,B*=N,T*=N}}for(let x=0;x<c;++x)r[e]=b,r[e+1]=B,r[e+2]=T,r[e+3]=m,e+=l}}function Jt(s,n,f,e,c=1){const{data:t,indices:i}=s,o=f.typedBuffer,r=f.typedBufferStride,l=i.length;if(e*=r,n!==t.length||n!==4)if(c!==1)if(n!==4)for(let u=0;u<l;++u){const a=3*i[u];for(let M=0;M<c;++M)o[e]=t[a],o[e+1]=t[a+1],o[e+2]=t[a+2],o[e+3]=255,e+=r}else for(let u=0;u<l;++u){const a=4*i[u];for(let M=0;M<c;++M)o[e]=t[a],o[e+1]=t[a+1],o[e+2]=t[a+2],o[e+3]=t[a+3],e+=r}else{if(n===4){for(let u=0;u<l;++u){const a=4*i[u];o[e]=t[a],o[e+1]=t[a+1],o[e+2]=t[a+2],o[e+3]=t[a+3],e+=r}return}for(let u=0;u<l;++u){const a=3*i[u];o[e]=t[a],o[e+1]=t[a+1],o[e+2]=t[a+2],o[e+3]=255,e+=r}}else{o[e]=t[0],o[e+1]=t[1],o[e+2]=t[2],o[e+3]=t[3];const u=new Uint32Array(f.typedBuffer.buffer,f.start),a=r/4,M=u[e/=4];e+=a;const L=l*c;for(let I=1;I<L;++I)u[e]=M,e+=a}}function Kt(s,n,f){const{data:e,indices:c}=s,t=n.typedBuffer,i=n.typedBufferStride,o=c.length,r=e[0];f*=i;for(let l=0;l<o;++l)t[f]=r,f+=i}function Xt(s,n,f,e,c=1){const t=n.typedBuffer,i=n.typedBufferStride;if(e*=i,c===1)for(let o=0;o<f;++o)t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],e+=i;else for(let o=0;o<f;++o)for(let r=0;r<c;++r)t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],e+=i}function Yt(s,n,f,e,c,t,i){var o;for(const r of f.fields.keys()){const l=s.get(r),u=l==null?void 0:l.indices;if(l&&u)Qt(r,l,e,c,t,i);else if(r===G.OBJECTANDLAYERIDCOLOR&&n!=null){const a=(o=s.get(G.POSITION))==null?void 0:o.indices;if(a){const M=a.length;Xt(n,t.getField(r,At),M,i)}}}}function Qt(s,n,f,e,c,t){switch(s){case G.POSITION:{j(n.size===3);const i=c.getField(s,yt);j(!!i,`No buffer view for ${s}`),i&&jt(n,f,i,t);break}case G.NORMAL:{j(n.size===3);const i=c.getField(s,yt);j(!!i,`No buffer view for ${s}`),i&&Gt(n,e,i,t);break}case G.NORMALCOMPRESSED:{j(n.size===2);const i=c.getField(s,Ct);j(!!i,`No buffer view for ${s}`),i&&Tt(n,i,t);break}case G.UV0:{j(n.size===2);const i=c.getField(s,Pt);j(!!i,`No buffer view for ${s}`),i&&Tt(n,i,t);break}case G.COLOR:case G.SYMBOLCOLOR:{const i=c.getField(s,At);j(!!i,`No buffer view for ${s}`),j(n.size===3||n.size===4),!i||n.size!==3&&n.size!==4||Jt(n,n.size,i,t);break}case G.COLORFEATUREATTRIBUTE:{const i=c.getField(s,Vt);j(!!i,`No buffer view for ${s}`),j(n.size===1),i&&n.size===1&&Kt(n,i,t);break}case G.TANGENT:{j(n.size===4);const i=c.getField(s,St);j(!!i,`No buffer view for ${s}`),i&&Ht(n,f,i,t);break}case G.PROFILERIGHT:case G.PROFILEUP:case G.PROFILEVERTEXANDNORMAL:case G.FEATUREVALUE:{j(n.size===4);const i=c.getField(s,St);j(!!i,`No buffer view for ${s}`),i&&zt(n,i,t)}}}class Wt{constructor(n=!1,f=!0){this.isVerticalRay=n,this.normalRequired=f}}const ct=$t();function Be(s,n,f,e,c,t){if(!s.visible)return;const i=tt(wt,e,f),o=(l,u,a)=>{t(l,a,u,!1)},r=new Wt(!1,n.options.normalRequired);if(s.boundingInfo){j(s.type===Dt.Mesh);const l=n.tolerance;Lt(s.boundingInfo,f,i,l,c,r,o)}else{const l=s.attributes.get(G.POSITION),u=l.indices;qt(f,i,0,u.length/3,u,l.data,l.stride,c,r,o)}}const Zt=J();function Lt(s,n,f,e,c,t,i){if(s==null)return;const o=oe(f,Zt);if(kt(ct,s.bbMin),Ut(ct,s.bbMax),c!=null&&c.applyToAabb(ct),fe(ct,n,o,e)){const{primitiveIndices:r,position:l}=s,u=r?r.length:l.indices.length/3;if(u>re){const a=s.getChildren();if(a!==void 0){for(const M of a)Lt(M,n,f,e,c,t,i);return}}te(n,f,0,u,l.indices,l.data,l.stride,r,c,t,i)}}const _=J();function Re(s,n,f,e,c,t,i,o,r){const{data:l,stride:u}=t;qt(s,tt(wt,n,s),f,e,c,l,u,i,o,r)}function Ne(s,n,f,e,c,t,i,o,r,l=null,u=0){const a=s[0],M=s[1],L=s[2],I=n[0],z=n[1],O=n[2];for(let w=f;w<e;++w){const A=u+(l?l[w]:w),E=3*A,v=i*c[E],S=t[v],R=t[v+1],h=t[v+2],p=i*c[E+1],g=t[p],y=t[p+1],d=t[p+2],m=i*c[E+2],b=g-S,B=y-R,T=d-h,x=t[m]-S,N=t[m+1]-R,P=t[m+2]-h,C=z*P-N*O,$=O*x-P*I,V=I*N-x*z,F=b*C+B*$+T*V;if(Math.abs(F)<=at)continue;const k=a-S,U=M-R,D=L-h,q=k*C+U*$+D*V;if(F>0){if(q<0||q>F)continue}else if(q>0||q<F)continue;const K=U*T-B*D,X=D*b-T*k,Y=k*B-b*U,H=I*K+z*X+O*Y;if(F>0){if(H<0||q+H>F)continue}else if(H>0||q+H<F)continue;const Q=(x*K+N*X+P*Y)/F;Q>=0&&r(Q,A,o?ut(b,B,T,x,N,P,_):null)}}function _t(s,n,f,e,c,t,i,o){const r=s[0],l=s[1],u=s[2],a=n[0],M=n[1],L=n[2];for(let I=f;I<e;++I){const z=3*I,O=z+1,w=z+2,A=t*z,E=c[A],v=c[A+1],S=c[A+2],R=t*O,h=t*w,p=c[R]-E,g=c[R+1]-v,y=c[R+2]-S,d=c[h]-E,m=c[h+1]-v,b=c[h+2]-S,B=M*b-m*L,T=L*d-b*a,x=a*m-d*M,N=p*B+g*T+y*x;if(Math.abs(N)<=at)continue;const P=r-E,C=l-v,$=u-S,V=P*B+C*T+$*x;if(N>0){if(V<0||V>N)continue}else if(V>0||V<N)continue;const F=C*y-g*$,k=$*p-y*P,U=P*g-p*C,D=a*F+M*k+L*U;if(N>0){if(D<0||V+D>N)continue}else if(D>0||V+D<N)continue;const q=(d*F+m*k+b*U)/N;q>=0&&o(q,I,i?ut(p,g,y,d,m,b,_):null)}}function Se(s,n,f,e,c,t,i,o,r,l,u,a=null,M=0){const L=s[0],I=s[1],z=s[2],O=n[0],w=n[1],A=n[2];for(let E=f;E<e;++E){const v=M+(a?a[E]:E),S=3*v,R=i*c[S],h=t[R],p=t[R+1],g=t[R+2],y=i*c[S+1],d=t[y],m=t[y+1],b=t[y+2],B=i*c[S+2],T=t[B],x=t[B+1],N=t[B+2],P=g-r,C=o/Math.sqrt(h*h+p*p+P*P),$=h+h*C,V=p+p*C,F=g+P*C,k=b-r,U=o/Math.sqrt(d*d+m*m+k*k),D=d+d*U,q=m+m*U,K=b+k*U,X=N-r,Y=o/Math.sqrt(T*T+x*x+X*X),H=D-$,Q=q-V,et=K-F,nt=T+T*Y-$,W=x+x*Y-V,it=N+X*Y-F,mt=w*it-W*A,gt=A*nt-it*O,Mt=O*W-nt*w,Z=H*mt+Q*gt+et*Mt;if(Math.abs(Z)<=at)continue;const dt=L-$,pt=I-V,ht=z-F,ot=dt*mt+pt*gt+ht*Mt;if(Z>0){if(ot<0||ot>Z)continue}else if(ot>0||ot<Z)continue;const Ot=pt*et-Q*ht,Bt=ht*H-et*dt,Rt=dt*Q-H*pt,ft=O*Ot+w*Bt+A*Rt;if(Z>0){if(ft<0||ot+ft>Z)continue}else if(ft>0||ot+ft<Z)continue;const Nt=(nt*Ot+W*Bt+it*Rt)/Z;Nt>=0&&u(Nt,v,l?ut(H,Q,et,nt,W,it,_):null)}}function te(s,n,f,e,c,t,i,o,r,l,u){const a=s[0],M=s[1],L=s[2],I=n[0],z=n[1],O=n[2],{normalRequired:w}=l;for(let A=f;A<e;++A){const E=o[A],v=3*E,S=i*c[v];let R=t[S],h=t[S+1],p=t[S+2];const g=i*c[v+1];let y=t[g],d=t[g+1],m=t[g+2];const b=i*c[v+2];let B=t[b],T=t[b+1],x=t[b+2];r!=null&&([R,h,p]=r.applyToVertex(R,h,p,A),[y,d,m]=r.applyToVertex(y,d,m,A),[B,T,x]=r.applyToVertex(B,T,x,A));const N=y-R,P=d-h,C=m-p,$=B-R,V=T-h,F=x-p,k=z*F-V*O,U=O*$-F*I,D=I*V-$*z,q=N*k+P*U+C*D;if(Math.abs(q)<=at)continue;const K=a-R,X=M-h,Y=L-p,H=K*k+X*U+Y*D;if(q>0){if(H<0||H>q)continue}else if(H>0||H<q)continue;const Q=X*C-P*Y,et=Y*N-C*K,nt=K*P-N*X,W=I*Q+z*et+O*nt;if(q>0){if(W<0||H+W>q)continue}else if(W>0||H+W<q)continue;const it=($*Q+V*et+F*nt)/q;it>=0&&u(it,E,w?ut(N,P,C,$,V,F,_):null)}}function qt(s,n,f,e,c,t,i,o,r,l){const u=n,a=le,M=Math.abs(u[0]),L=Math.abs(u[1]),I=Math.abs(u[2]),z=M>=L?M>=I?0:2:L>=I?1:2,O=z,w=u[O]<0?2:1,A=(z+w)%3,E=(z+(3-w))%3,v=u[A]/u[O],S=u[E]/u[O],R=1/u[O],h=ee,p=ne,g=ie,{normalRequired:y}=r;for(let d=f;d<e;++d){const m=3*d,b=i*c[m];st(a[0],t[b+0],t[b+1],t[b+2]);const B=i*c[m+1];st(a[1],t[B+0],t[B+1],t[B+2]);const T=i*c[m+2];st(a[2],t[T+0],t[T+1],t[T+2]),o&&(bt(a[0],o.applyToVertex(a[0][0],a[0][1],a[0][2],d)),bt(a[1],o.applyToVertex(a[1][0],a[1][1],a[1][2],d)),bt(a[2],o.applyToVertex(a[2][0],a[2][1],a[2][2],d))),tt(h,a[0],s),tt(p,a[1],s),tt(g,a[2],s);const x=h[A]-v*h[O],N=h[E]-S*h[O],P=p[A]-v*p[O],C=p[E]-S*p[O],$=g[A]-v*g[O],V=g[E]-S*g[O],F=$*C-V*P,k=x*V-N*$,U=P*N-C*x;if((F<0||k<0||U<0)&&(F>0||k>0||U>0))continue;const D=F+k+U;if(D===0)continue;const q=F*(R*h[O])+k*(R*p[O])+U*(R*g[O]);if(q*Math.sign(D)<0)continue;const K=q/D;K>=0&&l(K,d,y?se(a):null)}}const ee=J(),ne=J(),ie=J();function ut(s,n,f,e,c,t,i){return st(rt,s,n,f),st(lt,e,c,t),xt(i,rt,lt),It(i,i),i}function se(s){return tt(rt,s[1],s[0]),tt(lt,s[2],s[0]),xt(_,rt,lt),It(_,_),_}const rt=J(),lt=J();function Te(s,n,f){return st(f,1/(n[0]-s[0]),1/(n[1]-s[1]),1/(n[2]-s[2]))}function oe(s,n){return st(n,1/s[0],1/s[1],1/s[2])}function fe(s,n,f,e){return ce(s,n,f,e,1/0)}function ce(s,n,f,e,c){const t=(s[0]-e-n[0])*f[0],i=(s[3]+e-n[0])*f[0];let o=Math.min(t,i),r=Math.max(t,i);const l=(s[1]-e-n[1])*f[1],u=(s[4]+e-n[1])*f[1];if(r=Math.min(r,Math.max(l,u)),r<0||(o=Math.max(o,Math.min(l,u)),o>r))return!1;const a=(s[2]-e-n[2])*f[2],M=(s[5]+e-n[2])*f[2];return r=Math.min(r,Math.max(a,M)),!(r<0)&&(o=Math.max(o,Math.min(a,M)),!(o>r)&&o<c)}const re=1e3,at=1e-7,wt=J(),le=[J(),J(),J()];class xe{constructor(n){this.vertexBufferLayout=n}elementCount(n){return n.get(G.POSITION).indices.length}write(n,f,e,c,t,i){Yt(e,c,this.vertexBufferLayout,n,f,t,i)}intersect(n,f,e,c,t){const i=this.vertexBufferLayout.createView(n).getField(G.POSITION,yt);if(i==null)return;const o=tt(ue,c,e),r=0,l=i.elementCount/3,u=f.options.normalRequired,a=(M,L,I)=>{t(M,I,L,!1)};_t(e,o,r,l,i.typedBuffer,i.typedBufferStride,u,a)}}const ue=J();export{Oe as B,Te as C,Yt as E,Qt as F,ce as N,Gt as O,Xt as R,Jt as S,Se as T,zt as a,jt as b,Me as d,xe as f,Ne as g,Wt as h,Be as p,fe as w,Re as x};
