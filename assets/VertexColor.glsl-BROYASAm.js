import{B as se,h as Ue}from"./Accessor-D6mNnsWy.js";import{n as Ge,o as M}from"./interfaces-B8ge7Jg9.js";import{a as _e}from"./basicInterfaces-wONHx_SN.js";import{n as We,q as Je,v as Ke,f as Ye,b as Xe,u as Qe}from"./Texture-DjTh7HwY.js";import{o as ce,h as Ce}from"./NormalAttribute.glsl-Dqf1UPF9.js";import{s as Ze}from"./vec42-B1mBkh1w.js";import{n as et,r as Me}from"./vec4f64-CBQL1T0x.js";import{d as ee,n as W,T as oe,r as me,_ as Re,z as Le}from"./mathUtils-ClvKsMak.js";import{i as tt,A as rt,G as it}from"./aaBoundingBox-BGxkJAW0.js";import{e as st}from"./Material-BN_i9QRJ.js";import{s as I}from"./Util-BMqL_pkg.js";import{e as V}from"./VertexAttribute-BnAa5VW0.js";import{H as Ne,G as Be}from"./mat4-ybYUU6jq.js";import{x as Ie,c as Fe,y as nt,u as ot,q as at,i as Pe}from"./BufferView-B7Z-dzh4.js";let Xt=class extends We{constructor(t){super(t),this._numLoading=0,this._disposed=!1,this._textures=t.textures,this._textureId=t.textureId,this._acquire(t.textureId,s=>this._texture=s),this._acquire(t.normalTextureId,s=>this._textureNormal=s),this._acquire(t.emissiveTextureId,s=>this._textureEmissive=s),this._acquire(t.occlusionTextureId,s=>this._textureOcclusion=s),this._acquire(t.metallicRoughnessTextureId,s=>this._textureMetallicRoughness=s)}dispose(){this._texture=se(this._texture),this._textureNormal=se(this._textureNormal),this._textureEmissive=se(this._textureEmissive),this._textureOcclusion=se(this._textureOcclusion),this._textureMetallicRoughness=se(this._textureMetallicRoughness),this._disposed=!0}ensureResources(t){return this._numLoading===0?_e.LOADED:_e.LOADING}get textureBindParameters(){return new ct(this._texture!=null?this._texture.glTexture:null,this._textureNormal!=null?this._textureNormal.glTexture:null,this._textureEmissive!=null?this._textureEmissive.glTexture:null,this._textureOcclusion!=null?this._textureOcclusion.glTexture:null,this._textureMetallicRoughness!=null?this._textureMetallicRoughness.glTexture:null)}updateTexture(t){this._texture!=null&&t===this._texture.id||(this._texture=se(this._texture),this._textureId=t,this._acquire(this._textureId,s=>this._texture=s))}_acquire(t,s){if(t==null)return void s(null);const r=this._textures.acquire(t);if(Ue(r))return++this._numLoading,void r.then(a=>{if(this._disposed)return se(a),void s(null);s(a)}).finally(()=>--this._numLoading);s(r)}};class ct extends Ge{constructor(t=null,s=null,r=null,a=null,i=null,n,o){super(),this.texture=t,this.textureNormal=s,this.textureEmissive=r,this.textureOcclusion=a,this.textureMetallicRoughness=i,this.scale=n,this.normalTextureTransformMatrix=o}}function Te(e){e.varyings.add("linearDepth","float")}function lt(e){e.vertex.uniforms.add(new Je("nearFar",(t,s)=>s.camera.nearFar))}function Ve(e){e.vertex.code.add(M`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`)}function Zt(e,t){const{vertex:s}=e;switch(t.output){case ce.Color:if(t.receiveShadows)return Te(e),void s.code.add(M`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);break;case ce.Shadow:case ce.ShadowHighlight:case ce.ShadowExcludeHighlight:case ce.ViewshedShadow:return e.include(Ke,t),Te(e),lt(e),Ve(e),void s.code.add(M`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`)}s.code.add(M`void forwardLinearDepth() {}`)}function er(e){Ve(e),e.vertex.code.add(M`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`),e.vertex.code.add(M`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function ut(e){e.vertex.code.add(M`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`),e.vertex.code.add(M`vec3 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec3 params) {
return vec3(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z
);
}`),e.vertex.code.add(M`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`),e.vertex.code.add(M`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`),e.vertex.code.add(M`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`),e.vertex.code.add(M`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`)}function tr(e){e.uniforms.add(new Ce("screenSizePerspective",t=>Ee(t.screenSizePerspective)))}function ft(e){e.uniforms.add(new Ce("screenSizePerspectiveAlignment",t=>Ee(t.screenSizePerspectiveAlignment||t.screenSizePerspective)))}function Ee(e){return ee(dt,e.parameters.divisor,e.parameters.offset,e.minScaleFactor)}const dt=W();function rr(e,t){const s=e.vertex;t.hasVerticalOffset?(pt(s),t.hasScreenSizePerspective&&(e.include(ut),ft(s),Ye(e.vertex,t)),s.code.add(M`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${t.spherical?M`vec3 worldNormal = normalize(worldPos + localOrigin);`:M`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${t.hasScreenSizePerspective?M`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);`:M`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)):s.code.add(M`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`)}const ht=et();function pt(e){e.uniforms.add(new Xe("verticalOffset",(t,s)=>{const{minWorldLength:r,maxWorldLength:a,screenLength:i}=t.verticalOffset,n=Math.tan(.5*s.camera.fovY)/(.5*s.camera.fullViewport[3]),o=s.camera.pixelRatio||1;return Ze(ht,i*o,n,r,a)}))}function ir(e,t,s,r=1){const{data:a,indices:i}=e,n=t.typedBuffer,o=t.typedBufferStride,c=i.length;if(s*=o,r===1)for(let u=0;u<c;++u)n[s]=a[i[u]],s+=o;else for(let u=0;u<c;++u){const l=a[i[u]];for(let f=0;f<r;f++)n[s]=l,s+=o}}function Ae(e,t,s){const{data:r,indices:a}=e,i=t.typedBuffer,n=t.typedBufferStride,o=a.length;s*=n;for(let c=0;c<o;++c){const u=2*a[c];i[s]=r[u],i[s+1]=r[u+1],s+=n}}function qe(e,t,s,r){const{data:a,indices:i}=e,n=t.typedBuffer,o=t.typedBufferStride,c=i.length;if(s*=o,r==null||r===1)for(let u=0;u<c;++u){const l=3*i[u];n[s]=a[l],n[s+1]=a[l+1],n[s+2]=a[l+2],s+=o}else for(let u=0;u<c;++u){const l=3*i[u];for(let f=0;f<r;++f)n[s]=a[l],n[s+1]=a[l+1],n[s+2]=a[l+2],s+=o}}function De(e,t,s,r=1){const{data:a,indices:i}=e,n=t.typedBuffer,o=t.typedBufferStride,c=i.length;if(s*=o,r===1)for(let u=0;u<c;++u){const l=4*i[u];n[s]=a[l],n[s+1]=a[l+1],n[s+2]=a[l+2],n[s+3]=a[l+3],s+=o}else for(let u=0;u<c;++u){const l=4*i[u];for(let f=0;f<r;++f)n[s]=a[l],n[s+1]=a[l+1],n[s+2]=a[l+2],n[s+3]=a[l+3],s+=o}}function sr(e,t,s){const r=e.typedBuffer,a=e.typedBufferStride;t*=a;for(let i=0;i<s;++i)r[t]=0,r[t+1]=0,r[t+2]=0,r[t+3]=0,t+=a}function vt(e,t,s,r,a=1){if(!t)return void qe(e,s,r,a);const{data:i,indices:n}=e,o=s.typedBuffer,c=s.typedBufferStride,u=n.length,l=t[0],f=t[1],z=t[2],B=t[4],A=t[5],R=t[6],S=t[8],L=t[9],_=t[10],F=t[12],P=t[13],y=t[14];r*=c;let O=0,p=0,h=0;const g=Ne(t)?m=>{O=i[m]+F,p=i[m+1]+P,h=i[m+2]+y}:m=>{const d=i[m],x=i[m+1],v=i[m+2];O=l*d+B*x+S*v+F,p=f*d+A*x+L*v+P,h=z*d+R*x+_*v+y};if(a===1)for(let m=0;m<u;++m)g(3*n[m]),o[r]=O,o[r+1]=p,o[r+2]=h,r+=c;else for(let m=0;m<u;++m){g(3*n[m]);for(let d=0;d<a;++d)o[r]=O,o[r+1]=p,o[r+2]=h,r+=c}}function mt(e,t,s,r,a=1){if(!t)return void qe(e,s,r,a);const{data:i,indices:n}=e,o=t,c=s.typedBuffer,u=s.typedBufferStride,l=n.length,f=o[0],z=o[1],B=o[2],A=o[4],R=o[5],S=o[6],L=o[8],_=o[9],F=o[10],P=!Be(o),y=1e-6,O=1-y;r*=u;let p=0,h=0,g=0;const m=Ne(o)?d=>{p=i[d],h=i[d+1],g=i[d+2]}:d=>{const x=i[d],v=i[d+1],w=i[d+2];p=f*x+A*v+L*w,h=z*x+R*v+_*w,g=B*x+S*v+F*w};if(a===1)if(P)for(let d=0;d<l;++d){m(3*n[d]);const x=p*p+h*h+g*g;if(x<O&&x>y){const v=1/Math.sqrt(x);c[r]=p*v,c[r+1]=h*v,c[r+2]=g*v}else c[r]=p,c[r+1]=h,c[r+2]=g;r+=u}else for(let d=0;d<l;++d)m(3*n[d]),c[r]=p,c[r+1]=h,c[r+2]=g,r+=u;else for(let d=0;d<l;++d){if(m(3*n[d]),P){const x=p*p+h*h+g*g;if(x<O&&x>y){const v=1/Math.sqrt(x);p*=v,h*=v,g*=v}}for(let x=0;x<a;++x)c[r]=p,c[r+1]=h,c[r+2]=g,r+=u}}function xt(e,t,s,r,a=1){if(!t)return void De(e,s,r,a);const{data:i,indices:n}=e,o=t,c=s.typedBuffer,u=s.typedBufferStride,l=n.length,f=o[0],z=o[1],B=o[2],A=o[4],R=o[5],S=o[6],L=o[8],_=o[9],F=o[10],P=!Be(o),y=1e-6,O=1-y;if(r*=u,a===1)for(let p=0;p<l;++p){const h=4*n[p],g=i[h],m=i[h+1],d=i[h+2],x=i[h+3];let v=f*g+A*m+L*d,w=z*g+R*m+_*d,$=B*g+S*m+F*d;if(P){const b=v*v+w*w+$*$;if(b<O&&b>y){const T=1/Math.sqrt(b);v*=T,w*=T,$*=T}}c[r]=v,c[r+1]=w,c[r+2]=$,c[r+3]=x,r+=u}else for(let p=0;p<l;++p){const h=4*n[p],g=i[h],m=i[h+1],d=i[h+2],x=i[h+3];let v=f*g+A*m+L*d,w=z*g+R*m+_*d,$=B*g+S*m+F*d;if(P){const b=v*v+w*w+$*$;if(b<O&&b>y){const T=1/Math.sqrt(b);v*=T,w*=T,$*=T}}for(let b=0;b<a;++b)c[r]=v,c[r+1]=w,c[r+2]=$,c[r+3]=x,r+=u}}function gt(e,t,s,r,a=1){const{data:i,indices:n}=e,o=s.typedBuffer,c=s.typedBufferStride,u=n.length;if(r*=c,t!==i.length||t!==4)if(a!==1)if(t!==4)for(let l=0;l<u;++l){const f=3*n[l];for(let z=0;z<a;++z)o[r]=i[f],o[r+1]=i[f+1],o[r+2]=i[f+2],o[r+3]=255,r+=c}else for(let l=0;l<u;++l){const f=4*n[l];for(let z=0;z<a;++z)o[r]=i[f],o[r+1]=i[f+1],o[r+2]=i[f+2],o[r+3]=i[f+3],r+=c}else{if(t===4){for(let l=0;l<u;++l){const f=4*n[l];o[r]=i[f],o[r+1]=i[f+1],o[r+2]=i[f+2],o[r+3]=i[f+3],r+=c}return}for(let l=0;l<u;++l){const f=3*n[l];o[r]=i[f],o[r+1]=i[f+1],o[r+2]=i[f+2],o[r+3]=255,r+=c}}else{o[r]=i[0],o[r+1]=i[1],o[r+2]=i[2],o[r+3]=i[3];const l=new Uint32Array(s.typedBuffer.buffer,s.start),f=c/4,z=l[r/=4];r+=f;const B=u*a;for(let A=1;A<B;++A)l[r]=z,r+=f}}function St(e,t,s){const{data:r,indices:a}=e,i=t.typedBuffer,n=t.typedBufferStride,o=a.length,c=r[0];s*=n;for(let u=0;u<o;++u)i[s]=c,s+=n}function zt(e,t,s,r,a=1){const i=t.typedBuffer,n=t.typedBufferStride;if(r*=n,a===1)for(let o=0;o<s;++o)i[r]=e[0],i[r+1]=e[1],i[r+2]=e[2],i[r+3]=e[3],r+=n;else for(let o=0;o<s;++o)for(let c=0;c<a;++c)i[r]=e[0],i[r+1]=e[1],i[r+2]=e[2],i[r+3]=e[3],r+=n}function wt(e,t,s,r,a,i){var n;for(const o of t.fields.keys()){const c=e.attributes.get(o),u=c==null?void 0:c.indices;if(c&&u)Ot(o,c,s,r,a,i);else if(o===V.OBJECTANDLAYERIDCOLOR&&e.objectAndLayerIdColor!=null){const l=(n=e.attributes.get(V.POSITION))==null?void 0:n.indices;if(l){const f=l.length,z=a.getField(o,Ie);zt(e.objectAndLayerIdColor,z,f,i)}}}}function Ot(e,t,s,r,a,i){switch(e){case V.POSITION:{I(t.size===3);const n=a.getField(e,Pe);I(!!n,`No buffer view for ${e}`),n&&vt(t,s,n,i);break}case V.NORMAL:{I(t.size===3);const n=a.getField(e,Pe);I(!!n,`No buffer view for ${e}`),n&&mt(t,r,n,i);break}case V.NORMALCOMPRESSED:{I(t.size===2);const n=a.getField(e,at);I(!!n,`No buffer view for ${e}`),n&&Ae(t,n,i);break}case V.UV0:{I(t.size===2);const n=a.getField(e,ot);I(!!n,`No buffer view for ${e}`),n&&Ae(t,n,i);break}case V.COLOR:case V.SYMBOLCOLOR:{const n=a.getField(e,Ie);I(!!n,`No buffer view for ${e}`),I(t.size===3||t.size===4),!n||t.size!==3&&t.size!==4||gt(t,t.size,n,i);break}case V.COLORFEATUREATTRIBUTE:{const n=a.getField(e,nt);I(!!n,`No buffer view for ${e}`),I(t.size===1),n&&t.size===1&&St(t,n,i);break}case V.TANGENT:{I(t.size===4);const n=a.getField(e,Fe);I(!!n,`No buffer view for ${e}`),n&&xt(t,s,n,i);break}case V.PROFILERIGHT:case V.PROFILEUP:case V.PROFILEVERTEXANDNORMAL:case V.FEATUREVALUE:{I(t.size===4);const n=a.getField(e,Fe);I(!!n,`No buffer view for ${e}`),n&&De(t,n,i)}}}const $t=Me(1,1,0,1),bt=Me(1,0,1,1);function nr(e){e.fragment.uniforms.add(new Qe("depthTexture",(t,s)=>s.mainDepth)),e.fragment.constants.add("occludedHighlightFlag","vec4",$t).add("unoccludedHighlightFlag","vec4",bt),e.fragment.code.add(M`void outputHighlight() {
float sceneDepth = float(texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x);
if (gl_FragCoord.z > sceneDepth + 5e-7) {
fragColor = occludedHighlightFlag;
} else {
fragColor = unoccludedHighlightFlag;
}
}`)}class yt{constructor(t=!1,s=!0){this.isVerticalRay=t,this.normalRequired=s}}const ue=tt();function or(e,t,s,r,a,i){if(!e.visible)return;const n=oe(je,r,s),o=(u,l,f)=>{i(u,f,l,!1)},c=new yt(!1,t.options.normalRequired);if(e.boundingInfo){I(e.type===st.Mesh);const u=t.tolerance;ke(e.boundingInfo,s,n,u,a,c,o)}else{const u=e.attributes.get(V.POSITION),l=u.indices;He(s,n,0,l.length/3,l,u.data,u.stride,a,c,o)}}const _t=W();function ke(e,t,s,r,a,i,n){if(e==null)return;const o=Mt(s,_t);if(rt(ue,e.bbMin),it(ue,e.bbMax),a!=null&&a.applyToAabb(ue),Rt(ue,t,o,r)){const{primitiveIndices:c,position:u}=e,l=c?c.length:u.indices.length/3;if(l>Nt){const f=e.getChildren();if(f!==void 0){for(const z of f)ke(z,t,s,r,a,i,n);return}}Ft(t,s,0,l,u.indices,u.data,u.stride,c,a,i,n)}}const ne=W();function ar(e,t,s,r,a,i,n,o,c){const{data:u,stride:l}=i;He(e,oe(je,t,e),s,r,a,u,l,n,o,c)}function cr(e,t,s,r,a,i,n,o,c,u=null,l=0){const f=e[0],z=e[1],B=e[2],A=t[0],R=t[1],S=t[2];for(let L=s;L<r;++L){const _=l+(u?u[L]:L),F=3*_,P=n*a[F],y=i[P],O=i[P+1],p=i[P+2],h=n*a[F+1],g=i[h],m=i[h+1],d=i[h+2],x=n*a[F+2],v=g-y,w=m-O,$=d-p,b=i[x]-y,T=i[x+1]-O,E=i[x+2]-p,H=R*E-T*S,j=S*b-E*A,U=A*T-b*R,C=v*H+w*j+$*U;if(Math.abs(C)<=ge)continue;const D=f-y,k=z-O,G=B-p,N=D*H+k*j+G*U;if(C>0){if(N<0||N>C)continue}else if(N>0||N<C)continue;const J=k*$-w*G,K=G*v-$*D,Y=D*w-v*k,q=A*J+R*K+S*Y;if(C>0){if(q<0||N+q>C)continue}else if(q>0||N+q<C)continue;const X=(b*J+T*K+E*Y)/C;X>=0&&c(X,_,o?xe(v,w,$,b,T,E,ne):null)}}function lr(e,t,s,r,a,i,n,o,c,u,l,f=null,z=0){const B=e[0],A=e[1],R=e[2],S=t[0],L=t[1],_=t[2];for(let F=s;F<r;++F){const P=z+(f?f[F]:F),y=3*P,O=n*a[y],p=i[O],h=i[O+1],g=i[O+2],m=n*a[y+1],d=i[m],x=i[m+1],v=i[m+2],w=n*a[y+2],$=i[w],b=i[w+1],T=i[w+2],E=g-c,H=o/Math.sqrt(p*p+h*h+E*E),j=p+p*H,U=h+h*H,C=g+E*H,D=v-c,k=o/Math.sqrt(d*d+x*x+D*D),G=d+d*k,N=x+x*k,J=v+D*k,K=T-c,Y=o/Math.sqrt($*$+b*b+K*K),q=G-j,X=N-U,te=J-C,re=$+$*Y-j,Q=b+b*Y-U,ie=T+K*Y-C,Se=L*ie-Q*_,ze=_*re-ie*S,we=S*Q-re*L,Z=q*Se+X*ze+te*we;if(Math.abs(Z)<=ge)continue;const he=B-j,pe=A-U,ve=R-C,ae=he*Se+pe*ze+ve*we;if(Z>0){if(ae<0||ae>Z)continue}else if(ae>0||ae<Z)continue;const Oe=pe*te-X*ve,$e=ve*q-te*he,be=he*X-q*pe,le=S*Oe+L*$e+_*be;if(Z>0){if(le<0||ae+le>Z)continue}else if(le>0||ae+le<Z)continue;const ye=(re*Oe+Q*$e+ie*be)/Z;ye>=0&&l(ye,P,u?xe(q,X,te,re,Q,ie,ne):null)}}function Ft(e,t,s,r,a,i,n,o,c,u,l){const f=e[0],z=e[1],B=e[2],A=t[0],R=t[1],S=t[2],{normalRequired:L}=u;for(let _=s;_<r;++_){const F=o[_],P=3*F,y=n*a[P];let O=i[y],p=i[y+1],h=i[y+2];const g=n*a[P+1];let m=i[g],d=i[g+1],x=i[g+2];const v=n*a[P+2];let w=i[v],$=i[v+1],b=i[v+2];c!=null&&([O,p,h]=c.applyToVertex(O,p,h,_),[m,d,x]=c.applyToVertex(m,d,x,_),[w,$,b]=c.applyToVertex(w,$,b,_));const T=m-O,E=d-p,H=x-h,j=w-O,U=$-p,C=b-h,D=R*C-U*S,k=S*j-C*A,G=A*U-j*R,N=T*D+E*k+H*G;if(Math.abs(N)<=ge)continue;const J=f-O,K=z-p,Y=B-h,q=J*D+K*k+Y*G;if(N>0){if(q<0||q>N)continue}else if(q>0||q<N)continue;const X=K*H-E*Y,te=Y*T-H*J,re=J*E-T*K,Q=A*X+R*te+S*re;if(N>0){if(Q<0||q+Q>N)continue}else if(Q>0||q+Q<N)continue;const ie=(j*X+U*te+C*re)/N;ie>=0&&l(ie,F,L?xe(T,E,H,j,U,C,ne):null)}}function He(e,t,s,r,a,i,n,o,c,u){const l=t,f=Bt,z=Math.abs(l[0]),B=Math.abs(l[1]),A=Math.abs(l[2]),R=z>=B?z>=A?0:2:B>=A?1:2,S=R,L=l[S]<0?2:1,_=(R+L)%3,F=(R+(3-L))%3,P=l[_]/l[S],y=l[F]/l[S],O=1/l[S],p=Pt,h=Tt,g=At,{normalRequired:m}=c;for(let d=s;d<r;++d){const x=3*d,v=n*a[x];ee(f[0],i[v+0],i[v+1],i[v+2]);const w=n*a[x+1];ee(f[1],i[w+0],i[w+1],i[w+2]);const $=n*a[x+2];ee(f[2],i[$+0],i[$+1],i[$+2]),o&&(me(f[0],o.applyToVertex(f[0][0],f[0][1],f[0][2],d)),me(f[1],o.applyToVertex(f[1][0],f[1][1],f[1][2],d)),me(f[2],o.applyToVertex(f[2][0],f[2][1],f[2][2],d))),oe(p,f[0],e),oe(h,f[1],e),oe(g,f[2],e);const b=p[_]-P*p[S],T=p[F]-y*p[S],E=h[_]-P*h[S],H=h[F]-y*h[S],j=g[_]-P*g[S],U=g[F]-y*g[S],C=j*H-U*E,D=b*U-T*j,k=E*T-H*b;if((C<0||D<0||k<0)&&(C>0||D>0||k>0))continue;const G=C+D+k;if(G===0)continue;const N=C*(O*p[S])+D*(O*h[S])+k*(O*g[S]);if(N*Math.sign(G)<0)continue;const J=N/G;J>=0&&u(J,d,m?Ct(f):null)}}const Pt=W(),Tt=W(),At=W();function xe(e,t,s,r,a,i,n){return ee(fe,e,t,s),ee(de,r,a,i),Re(n,fe,de),Le(n,n),n}function Ct(e){return oe(fe,e[1],e[0]),oe(de,e[2],e[0]),Re(ne,fe,de),Le(ne,ne),ne}const fe=W(),de=W();function ur(e,t,s){return ee(s,1/(t[0]-e[0]),1/(t[1]-e[1]),1/(t[2]-e[2]))}function Mt(e,t){return ee(t,1/e[0],1/e[1],1/e[2])}function Rt(e,t,s,r){return Lt(e,t,s,r,1/0)}function Lt(e,t,s,r,a){const i=(e[0]-r-t[0])*s[0],n=(e[3]+r-t[0])*s[0];let o=Math.min(i,n),c=Math.max(i,n);const u=(e[1]-r-t[1])*s[1],l=(e[4]+r-t[1])*s[1];if(c=Math.min(c,Math.max(u,l)),c<0||(o=Math.max(o,Math.min(u,l)),o>c))return!1;const f=(e[2]-r-t[2])*s[2],z=(e[5]+r-t[2])*s[2];return c=Math.min(c,Math.max(f,z)),!(c<0)&&(o=Math.max(o,Math.min(f,z)),!(o>c)&&o<a)}const Nt=1e3,ge=1e-7,je=W(),Bt=[W(),W(),W()];class fr{constructor(t){this.vertexBufferLayout=t}elementCount(t){return t.attributes.get(V.POSITION).indices.length}write(t,s,r,a,i){wt(r,this.vertexBufferLayout,t,s,a,i)}}function dr(e,t){t.hasVertexColors?(e.attributes.add(V.COLOR,"vec4"),e.varyings.add("vColor","vec4"),e.vertex.code.add(M`void forwardVertexColor() { vColor = color; }`),e.vertex.code.add(M`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)):e.vertex.code.add(M`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`)}export{Ot as A,lr as B,ur as C,wt as E,mt as O,zt as R,gt as S,nr as a,vt as b,rr as c,ir as d,dr as e,pt as f,ft as g,$t as h,lt as i,bt as j,De as k,ct as l,yt as m,Zt as n,er as o,or as p,Rt as q,fr as r,ut as s,tr as t,Xt as u,Te as v,Lt as w,ar as x,sr as y,cr as z};
