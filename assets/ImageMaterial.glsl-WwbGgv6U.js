import{y as E}from"./BufferView-0osDbyWD.js";import{n as y,u as D,j as g,m as h}from"./Matrix3PassUniform-uCCQMnlP.js";import{e as v}from"./basicInterfaces-CZwQPxTp.js";import{r as O}from"./GLTextureMaterial-96UpbkjC.js";import{b as A}from"./Material-C_-mgXN8.js";import{g as w,u as x,G as S,y as C,H as N,z as R,s as F,k as M,m as V,t as j,C as _,_ as L,$ as B,a0 as z,a1 as U,D as W,J as H,a2 as k,T as q,E as G,q as J,F as Q,A as m,a3 as K}from"./FloatArray-BQXWSSJh.js";import{s as X}from"./InterleavedLayout-_dYEAUNK.js";import{e as n}from"./VertexAttribute-Cq4MnHjR.js";import{f as Y,d as Z,F as ee}from"./DefaultBufferWriter-CqCDaNCZ.js";import{f as te}from"./DefaultLayouts-CBF6SkyQ.js";import{e as re}from"./TriangleMaterial-D-IjcYAX.js";import{_ as ie}from"./index-4eY77cms.js";import{B as se,g as oe,f as ae,o as ne}from"./renderState-Ci93M1-P.js";import{r as p}from"./Accessor-BmwT4B0c.js";import{i as c}from"./ShaderTechniqueConfiguration-D4dZMCXS.js";import"./mat3f64-BBpwCtoL.js";import"./mat4f64-Dk4dwAN8.js";import"./vec3f64-BLpZdpfb.js";import{t as P,n as I}from"./glsl-BH37Aalp.js";import"./BindType-BBwFZqyN.js";import"./vec2-ChnYg_BJ.js";import"./vec2f64-Dy6m9Nrb.js";import"./mat4-Fi6iAz29.js";import"./vec32-Dvg_eL9J.js";import{i as le}from"./ShaderBuilder-BKul5qh8.js";import{o as pe}from"./VertexColor.glsl-D3WyDYIi.js";import{c as ce}from"./NoParameters-t-PuNrgq.js";class T extends ce{}function $(r){const e=new le,{vertex:t,fragment:i}=e,{output:f,perspectiveInterpolation:s}=r;return w(t,r),e.include(pe,r),e.include(x,r),e.fragment.include(S,r),e.include(C,r),e.include(N,r),e.attributes.add(n.POSITION,"vec3"),e.attributes.add(n.UV0,"vec2"),s&&e.attributes.add(n.PERSPECTIVEDIVIDE,"float"),t.main.add(I`
    vpos = position;
    forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);
    vTexCoord = uv0;
    gl_Position = transformPosition(proj, view, vpos);
    ${P(s,"gl_Position *= perspectiveDivide;")}`),e.varyings.add("vpos","vec3"),e.varyings.add("vTexCoord","vec2"),i.include(R),i.uniforms.add(new F("opacity",o=>o.opacity),new M("tex",o=>o.texture)).main.add(I`
    discardBySlice(vpos);
    discardByTerrainDepth();
    ${P(f===y.ObjectAndLayerIdColor,"fragColor = vec4(0, 0, 0, 1); return;")}
    vec4 finalColor = texture(tex, vTexCoord) * opacity;
    outputColorHighlightOID(finalColor, vpos);`),e}const ue=Object.freeze(Object.defineProperty({__proto__:null,ImageMaterialPassParameters:T,build:$},Symbol.toStringTag,{value:"Module"}));let fe=class extends V{constructor(e,t){super(e,t,new j(ue,()=>ie(()=>Promise.resolve().then(()=>ve),void 0,import.meta.url)),b)}_getPipelineState(e,t){const{oitPass:i,output:f,hasOccludees:s,enableOffset:o,cullFace:u}=e,l=i===_.NONE,d=i===_.FrontFace;return se({blending:D(f)?l?ne:q(i):null,culling:ae(u),depthTest:{func:k(i)},depthWrite:H(e),drawBuffers:W(i,f),colorWrite:oe,stencilWrite:s?U:null,stencilTest:s?t?B:z:null,polygonOffset:l||d?null:L(o)})}initializePipeline(e){return this._occludeePipeline=this._getPipelineState(e,!0),this._getPipelineState(e,!1)}getPipeline(e){return e?this._occludeePipeline:super.getPipeline()}};const b=new Map([[n.POSITION,0],[n.UV0,2],[n.PERSPECTIVEDIVIDE,3]]);class a extends G{constructor(){super(...arguments),this.cullFace=v.None,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.perspectiveInterpolation=!0,this.textureCoordinateType=J.None,this.emissionSource=Q.None,this.discardInvisibleFragments=!0,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1}}p([c({count:v.COUNT})],a.prototype,"cullFace",void 0),p([c()],a.prototype,"enableOffset",void 0),p([c()],a.prototype,"writeDepth",void 0),p([c()],a.prototype,"hasOccludees",void 0),p([c()],a.prototype,"terrainDepthTest",void 0),p([c()],a.prototype,"cullAboveTerrain",void 0),p([c()],a.prototype,"perspectiveInterpolation",void 0);class ke extends re{constructor(e){super(e,he),this._configuration=new a,this.vertexAttributeLocations=b,this.supportsEdges=!0,this.produces=new Map([[m.OPAQUE_MATERIAL,t=>g(t)],[m.TRANSPARENT_MATERIAL,t=>h(t)&&this.parameters.writeDepth],[m.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,t=>h(t)&&!this.parameters.writeDepth],[m.DRAPED_MATERIAL,t=>h(t)||g(t)]])}getConfiguration(e,t){return this._configuration.output=e,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=t.hasOccludees,this._configuration.oitPass=t.oitPass,this._configuration.enableOffset=t.camera.relativeElevation<K,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration.perspectiveInterpolation=this.parameters.perspectiveInterpolation,this._configuration}get visible(){return!0}createGLMaterial(e){return new de(e)}createBufferWriter(){const e=te.clone();return this.parameters.perspectiveInterpolation&&e.f32(n.PERSPECTIVEDIVIDE),new me(e)}}class de extends O{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(fe,e)}}class me extends Y{write(e,t,i,f,s,o){for(const u of this.vertexBufferLayout.fields.keys()){const l=i.get(u);if(l)if(u===n.PERSPECTIVEDIVIDE){X(l.size===1);const d=s.getField(u,E);d&&Z(l,d,o)}else ee(u,l,e,t,s,o)}}}class he extends A{constructor(e){super(),this.textureId=e,this.writeDepth=!0,this.hasSlicePlane=!1,this.cullFace=v.None,this.opacity=1,this.perspectiveInterpolation=!1}}const ve=Object.freeze(Object.defineProperty({__proto__:null,ImageMaterialPassParameters:T,build:$},Symbol.toStringTag,{value:"Module"}));export{ke as I};
