import{q as C,Q as B,a as H,b as W,p as L}from"./Accessor-D6mNnsWy.js";import{U as N,E as R}from"./assets-C2mb-ea2.js";import{p as G}from"./workers-8Q6jrI18.js";import{t as d}from"./Rect-CUzevAry.js";import{G as K,D as U}from"./enums-BlUEVwJR.js";import{e as O,c as T}from"./Texture-BbJIOVx_.js";import{n as q}from"./pbf-CmaozfCN.js";import"./subclass-BR3PhgZG.js";import{i as F}from"./rasterizingUtils-Cm2OdJYT.js";import{e as m}from"./TileKey-CIqLSCov.js";import{z as $}from"./TileInfo-DkEc90N-.js";import{h as j}from"./TileStrategy-_ezroEyM.js";class w{constructor(t,s){this._width=0,this._height=0,this._free=[],this._width=t,this._height=s,this._free.push(new d(0,0,t,s))}get width(){return this._width}get height(){return this._height}allocate(t,s){if(t>this._width||s>this._height)return new d;let e=null,i=-1;for(let r=0;r<this._free.length;++r){const h=this._free[r];t<=h.width&&s<=h.height&&(e===null||h.y<=e.y&&h.x<=e.x)&&(e=h,i=r)}return e===null?new d:(this._free.splice(i,1),e.width<e.height?(e.width>t&&this._free.push(new d(e.x+t,e.y,e.width-t,s)),e.height>s&&this._free.push(new d(e.x,e.y+s,e.width,e.height-s))):(e.width>t&&this._free.push(new d(e.x+t,e.y,e.width-t,e.height)),e.height>s&&this._free.push(new d(e.x,e.y+s,t,e.height-s))),new d(e.x,e.y,t,s))}release(t){for(let s=0;s<this._free.length;++s){const e=this._free[s];if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)e.width+=t.width;else if(e.x===t.x&&e.width===t.width&&e.y+e.height===t.y)e.height+=t.height;else if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)e.x=t.x,e.width+=t.width;else{if(t.x!==e.x||t.width!==e.width||t.y+t.height!==e.y)continue;e.y=t.y,e.height+=t.height}this._free.splice(s,1),this.release(t)}this._free.push(t)}}let z=class{constructor(t,s,e){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=s,this._glyphSource=e,this._binPack=new w(t-4,s-4),this._glyphData.push(new Uint8Array(t*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(t,s){const e=[],i=this._glyphSource,r=new Set,h=1/256;for(const o of s){const n=Math.floor(o*h);r.add(n)}const a=[];return r.forEach(o=>{const n=t+o;if(this._rangePromises.has(n))a.push(this._rangePromises.get(n));else{const l=i.getRange(t,o).then(()=>{this._rangePromises.delete(n)},()=>{this._rangePromises.delete(n)});this._rangePromises.set(n,l),a.push(l)}}),Promise.all(a).then(()=>{let o=this._glyphIndex[t];o||(o={},this._glyphIndex[t]=o);for(const n of s){const l=o[n];if(l){e[n]={sdf:!0,rect:l.rect,metrics:l.metrics,page:l.page,code:n};continue}const g=i.getGlyph(t,n);if(!(g!=null&&g.metrics))continue;const u=g.metrics;let _;if(u.width===0)_=new d(0,0,0,0);else{const c=u.width+6,y=u.height+2*3;let S=c%4?4-c%4:4,b=y%4?4-y%4:4;S===1&&(S=5),b===1&&(b=5),_=this._binPack.allocate(c+S,y+b),_.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new w(this.width-4,this.height-4),_=this._binPack.allocate(c+S,y+b));const E=this._glyphData[this._currentPage],I=g.bitmap;let M,k;if(I)for(let x=0;x<y;x++){M=c*x,k=this.width*(_.y+x+1)+_.x;for(let P=0;P<c;P++)E[k+P+1]=I.at(M+P)}}o[n]={rect:_,metrics:u,tileIDs:null,page:this._currentPage},e[n]={sdf:!0,rect:_,metrics:u,page:this._currentPage,code:n},this._dirties[this._currentPage]=!0}return e})}removeGlyphs(t){for(const s in this._glyphIndex){const e=this._glyphIndex[s];if(!e)continue;let i;for(const r in e)if(i=e[r],i.tileIDs.delete(t),i.tileIDs.size===0){const h=this._glyphData[i.page],a=i.rect;let o,n;for(let l=0;l<a.height;l++)for(o=this.width*(a.y+l)+a.x,n=0;n<a.width;n++)h[o+n]=0;delete e[r],this._dirties[i.page]=!0}}}bind(t,s,e,i=0){if(!this._textures[e]){const h=new O;h.pixelFormat=K.ALPHA,h.wrapMode=U.CLAMP_TO_EDGE,h.width=this.width,h.height=this.height,this._textures[e]=new T(t,h,new Uint8Array(this.width*this.height))}const r=this._textures[e];r.setSamplingMode(s),this._dirties[e]&&r.setData(this._glyphData[e]),t.bindTexture(r,i),this._dirties[e]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0}};class D{constructor(t){if(this._metrics=[],!t)return void(this._allBitmaps=null);const s=new Map;let e=0;for(;t.next();)switch(t.tag()){case 1:{const h=t.getMessage();for(;h.next();)switch(h.tag()){case 3:{const a=h.getMessage();let o,n,l,g,u,_,p;for(;a.next();)switch(a.tag()){case 1:o=a.getUInt32();break;case 2:n=a.getBytes();break;case 3:l=a.getUInt32();break;case 4:g=a.getUInt32();break;case 5:u=a.getSInt32();break;case 6:_=a.getSInt32();break;case 7:p=a.getUInt32();break;default:a.skip()}if(a.release(),o){const c=(n==null?void 0:n.length)??0;this._metrics[o]={width:l,height:g,left:u,top:_,advance:p,startOffset:e,length:c},s.set(o,n),e+=c}break}default:h.skip()}h.release();break}default:t.skip()}const i=new Uint8Array(e),r=this._metrics;for(const[h,a]of s){const{startOffset:o,length:n}=r[h];if(a)for(let l=0;l<n;++l)i[o+l]=a[l]}this._allBitmaps=i}getMetrics(t){return this._metrics[t]}getBitmap(t){if(!this._allBitmaps)return;const s=this._metrics[t];if(s===void 0)return;const{startOffset:e,length:i}=s;return i!==0?new V(this._allBitmaps,e,i):void 0}}class Q{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(t){return this._ranges[t]}addRange(t,s){this._ranges[t]=s}}let A=class{constructor(t){this._glyphInfo={},this._baseURL=t}getRange(t,s){const e=this._getFontStack(t);if(e.getRange(s))return Promise.resolve();const i=256*s,r=i+255;if(this._baseURL){const h=this._baseURL.replace("{fontstack}",t).replace("{range}",i+"-"+r);return N(h,{responseType:"array-buffer"}).then(a=>{e.addRange(s,new D(new q(new Uint8Array(a.data),new DataView(a.data))))}).catch(()=>{e.addRange(s,new D)})}return e.addRange(s,new D),Promise.resolve()}getGlyph(t,s){const e=this._getFontStack(t);if(!e)return;const i=Math.floor(s/256),r=e.getRange(i);return r?{metrics:r.getMetrics(s),bitmap:r.getBitmap(s)}:void 0}_getFontStack(t){let s=this._glyphInfo[t];return s||(s=this._glyphInfo[t]=new Q),s}};class V{constructor(t,s,e){this._array=t,this._start=s,this.length=e}at(t){return 0<=t&&t<this.length?this._array[this._start+t]:void 0}}const J="dasharray-";class v{constructor(t,s,e=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,s<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=t,this._pageHeight=s,e>0&&(this._maxItemSize=e),this._binPack=new w(t-4,s-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const t of this._textures)t&&t.dispose();this._textures.length=0}getWidth(t){return t>=this._size.length?-1:this._size[t][0]}getHeight(t){return t>=this._size.length?-1:this._size[t][1]}getPageSize(t){return t>=this._size.length?null:this._size[t]}setSpriteSource(t){if(this.dispose(),this.pixelRatio=t.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new w(this._pageWidth-4,this._pageHeight-4);const s=Math.floor(this._pageWidth),e=Math.floor(this._pageHeight),i=new Uint32Array(s*e);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=t}getSpriteItem(t,s=!1){let e,i,r=this._mosaicRects[t];if(r)return r;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(t&&t.startsWith(J)?([e,i]=this._rasterizeDash(t),s=!0):e=this._sprites.getSpriteInfo(t),!(e!=null&&e.width)||!e.height||e.width<0||e.height<0))return null;const h=e.width,a=e.height,[o,n,l]=this._allocateImage(h,a);return o.width<=0?null:(this._copy(o,e,n,l,s,i),r={type:"sprite",rect:o,width:h,height:a,sdf:e.sdf,simplePattern:!1,rasterizationScale:e.pixelRatio,page:n},this._mosaicRects[t]=r,r)}getSpriteItems(t){const s={};for(const e of t)s[e.name]=this.getSpriteItem(e.name,e.repeat);return s}getMosaicItemPosition(t,s){const e=this.getSpriteItem(t,s),i=e==null?void 0:e.rect;if(!i)return null;i.width=e.width,i.height=e.height;const r=e.width,h=e.height,a=2;return{tl:[i.x+a,i.y+a],br:[i.x+a+r,i.y+a+h],page:e.page}}bind(t,s,e=0,i=0){if(e>=this._size.length||e>=this._mosaicsData.length)return;if(!this._textures[e]){const h=new O;h.wrapMode=U.CLAMP_TO_EDGE,h.width=this._size[e][0],h.height=this._size[e][1],this._textures[e]=new T(t,h,new Uint8Array(this._mosaicsData[e].buffer))}const r=this._textures[e];r.setSamplingMode(s),this._dirties[e]&&r.setData(new Uint8Array(this._mosaicsData[e].buffer)),t.bindTexture(r,i),this._dirties[e]=!1}static _copyBits(t,s,e,i,r,h,a,o,n,l,g){let u=i*s+e,_=o*h+a;if(g){_-=h;for(let p=-1;p<=l;p++,u=((p+l)%l+i)*s+e,_+=h)for(let c=-1;c<=n;c++)r[_+c]=t[u+(c+n)%n]}else for(let p=0;p<l;p++){for(let c=0;c<n;c++)r[_+c]=t[u+c];u+=s,_+=h}}_copy(t,s,e,i,r,h){if(!this._sprites||this._sprites.loadStatus!=="loaded"||e>=this._mosaicsData.length)return;const a=new Uint32Array(h?h.buffer:this._sprites.image.buffer),o=this._mosaicsData[e],n=2,l=h?s.width:this._sprites.width;v._copyBits(a,l,s.x,s.y,o,i[0],t.x+n,t.y+n,s.width,s.height,r),this._dirties[e]=!0}_allocateImage(t,s){t+=2,s+=2;const e=Math.max(t,s);if(this._maxItemSize&&this._maxItemSize<e){const a=new d(0,0,t,s);return this._mosaicsData.push(new Uint32Array(t*s)),this._dirties.push(!0),this._size.push([t,s]),this._textures.push(void 0),[a,this._mosaicsData.length-1,[t,s]]}let i=t%4?4-t%4:4,r=s%4?4-s%4:4;i===1&&(i=5),r===1&&(r=5);const h=this._binPack.allocate(t+i,s+r);return h.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new w(this._pageWidth-4,this._pageHeight-4),this._allocateImage(t,s)):[h,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(t){const s=/\[(.*?)\]/,e=t.match(s);if(!e)return null;const i=e[1].split(",").map(Number),r=t.slice(t.lastIndexOf("-")+1),[h,a,o]=F(i,r);return[{x:0,y:0,width:a,height:o,sdf:!0,pixelRatio:1},new Uint8Array(h.buffer)]}}class ut{constructor(t,s,e,i){this._layer=t,this._styleRepository=s,this.devicePixelRatio=e,this._sourceDataMaxLOD=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){var t,s,e;(t=this._connection)==null||t.close(),this._connection=null,this._styleRepository=null,this._layer=null,(s=this._spriteMosaic)==null||s.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=C(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&((e=this._startOptionsInputSignal)==null||e.removeEventListener("abort",this._inputSignalEventListener)),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(t){this._requestSprite(t);const s=this._layer.currentStyleInfo.glyphsUrl,e=new A(s?R(s,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new z(1024,1024,e),this._broadcastPromise=G("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then(i=>{var r;if(this._layer&&((r=this._connection)==null||r.close(),this._connection=i,this._layer&&!this._connection.closed)){const h=i.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},t);Promise.all(h).catch(a=>B(a))}})}_requestSprite(t){var h,a;(h=this._spriteSourceAbortController)==null||h.abort();const s=new AbortController;this._spriteSourceAbortController=s;const e=t==null?void 0:t.signal;this._inputSignalEventListener&&((a=this._startOptionsInputSignal)==null||a.removeEventListener("abort",this._inputSignalEventListener)),this._startOptionsInputSignal=null,e&&(this._inputSignalEventListener=X(s),e.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:i}=s,r={...t,signal:i};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,r),this._spriteSourcePromise.then(o=>{H(i),this._spriteMosaic=new v(1024,1024,250),this._spriteMosaic.setSpriteSource(o)})}async updateStyle(t){return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",t)),this._broadcastPromise}setSpriteSource(t){const s=new v(1024,1024,250);return s.setSpriteSource(t),this._spriteMosaic=s,this._spriteSourcePromise=Promise.resolve(t),this._spriteSourceAbortController=null,s}async setStyle(t,s,e){await this._broadcastPromise,this._styleRepository=t,this._sourceDataMaxLOD=e,this._requestSprite();const i=new A(this._layer.currentStyleInfo.glyphsUrl?R(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new z(1024,1024,i),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:s,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(t,s){const e=await this._getRefKeys(t,s);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),e,s)}async fetchTilePBFs(t){const s=Object.keys(this._layer.sourceNameToSource),e={},i=await this._getRefKeys(t,e),r=[],h=[];for(let a=0;a<i.length;a++)if(i[a].value==null||s[a]==null)h.push(null);else{const o=i[a].value,n=this._getTilePayload(o,s[a],e);n.then(l=>{r.push({...l,key:o})}),h.push(n)}return Promise.all(h).then(()=>r)}async parseTileData(t,s){const e=t&&t.data;if(!e)return null;const{sourceName2DataAndRefKey:i,transferList:r}=e;return Object.keys(i).length===0?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:i,styleLayerUIDs:t.styleLayerUIDs},{...s,transferList:r}))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}async _getTilePayload(t,s,e){const i=m.pool.acquire(t.id),r=this._layer.sourceNameToSource[s],{level:h,row:a,col:o}=i;m.pool.release(i);try{return{protobuff:await r.requestTile(h,a,o,e),sourceName:s}}catch(n){if(W(n))throw n;return{protobuff:null,sourceName:s}}}async _getRefKeys(t,s){const e=this._layer.sourceNameToSource,i=new Array;for(const r in e){const h=e[r].getRefKey(t,s);i.push(h)}return L(i)}_getSourcesData(t,s,e){const i=[];for(let r=0;r<s.length;r++)if(s[r].value==null||t[r]==null)i.push(null);else{const h=s[r].value,a=this._getTilePayload(h,t[r],e);i.push(a)}return L(i).then(r=>{const h={},a=[];for(let o=0;o<r.length;o++){const n=r[o].value;if(n&&n.protobuff&&n.protobuff.byteLength>0){const l=s[o].value.id;h[n.sourceName]={refKey:l,protobuff:n.protobuff},a.push(n.protobuff)}}return{sourceName2DataAndRefKey:h,transferList:a}})}}function X(f){return()=>f.abort()}class gt extends j{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(t){const s=m.pool.acquire(t),e=s.level===0?null:m.getId(s.level-1,s.row>>1,s.col>>1,s.world);return m.pool.release(s),e}getTileCoverage(t,s,e=!0,i){const r=super.getTileCoverage(t,s,e,i);if(!r)return r;const h=1<<r.lodInfo.level;return r.spans=r.spans.filter(a=>a.row>=0&&a.row<h),r}scaleToLevel(t){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[t])return this._levelByScale[t];{const s=this._fullCacheLodInfos;if(t>s[0].scale)return s[0].level;let e,i;for(let r=0;r<s.length-1;r++)if(i=s[r+1],t>i.scale)return e=s[r],e.level+(e.scale-t)/(e.scale-i.scale);return s[s.length-1].level}}_initializeFullCacheLODs(t){let s;if(t[0].level===0)s=t.map(e=>({level:e.level,resolution:e.resolution,scale:e.scale}));else{const e=this.tileInfo.size[0],i=this.tileInfo.spatialReference;s=$.create({size:e,spatialReference:i}).lods.map(r=>({level:r.level,resolution:r.resolution,scale:r.scale}))}for(let e=0;e<s.length;e++)this._levelByScale[s[e].scale]=s[e].level;this._fullCacheLodInfos=s}}export{ut as h,gt as t};
