import{O as nt,P as it,Q as j,R as S,S as rt,T as f,U as at,V as z,i as ct}from"./index-5cc0d3e9-BXwdUzLn.js";/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.31/esri/copyright.txt for details.
 * v4.31.2
 */function lt(t,e){var s;if(e){const o=t.constructor.elementProperties;t.manager.internals.members=Object.fromEntries(Array.from(o,([r,n])=>n.noAccessor?void 0:[r,[(n.readOnly?2048:0)|(n.state?32:16)]]).filter(z))}else{const o=t.constructor,r=((s=o.__registerControllers)==null?void 0:s.call(o,t))??void 0;if(o.__registerControllers=void 0,typeof r!="object")throw new Error("Failed to retrieve component meta");t.manager.internals.members=Object.fromEntries(Object.entries(r).filter(([n,[c]])=>(c&63)!==0))}}function dt(t,e=8){return t==null||typeof t=="object"||typeof t=="function"?t:e&4?t==="false"?!1:t===""||!!t:e&2?Number.parseFloat(t):e&1?String(t):t}var Q=(t,e)=>{var s,o;return(o=(s=t.manager.internals.members)==null?void 0:s[e])==null?void 0:o[0]},G=Symbol.for("controller"),ht=t=>typeof t=="object"&&t!==null&&(G in t||"hostConnected"in t||"hostDisconnected"in t||"hostUpdate"in t||"hostUpdated"in t),P;function D(t){P!==t&&(P=t,queueMicrotask(()=>{P===t&&(P=void 0)}))}function O(t){return P}var C=[];function H(t){if(t===void 0){C=[];return}const e=C.indexOf(t);C=e===-1?[...C,t]:C.slice(0,e+1),queueMicrotask(()=>{C=[]})}function ft(){return C}var k;function ut(t){k!==t&&(k=t,queueMicrotask(()=>{k===t&&(k=void 0)}))}function pt(){const t=k;return k=void 0,t}var yt=async(t,e)=>{const s=q(t);if(s===void 0)return t;if(await s.ready,typeof e=="function"){const o=s.watchExports(r=>e(r,o))}return s.exports},mt=async t=>{const e=q(t);return await e.ready,e},q=t=>{const e=pt();if(e!==void 0)return e;const o=O().manager.internals.resolveExports(t);if(o!==void 0)return o;if(ht(t))return t},v={setter:!1,getter:!1,readOnly:!1},A=new WeakMap,J;J=G;var X=class{constructor(t){this._callbacks={hostConnected:[],hostDisconnected:[],hostLoad:[],hostLoaded:[],hostUpdate:[],hostUpdated:[],hostDestroy:[],hostLifecycle:[]},this._ready=new j,this._lifecycleCleanups=[],this.connectedCalled=!1,this._loadCalled=!1,this.loadedCalled=!1,this[J]=!0,this.ready=this._ready.promise,this._exports=N(this),this._exportWatchers=new Set;const e=t??O();this.component=e,this.component.addController(this),H(this),this.component.manager===void 0||queueMicrotask(()=>this.catchUpLifecycle())}catchUpLifecycle(){const{manager:t}=this.component;t.connectedCalled&&!this.connectedCalled&&this.triggerConnected(),t._loadCalled&&this.triggerLoad().then(()=>{t.loadedCalled&&this.triggerLoaded()}).catch(console.error)}get exports(){return this._exports}set exports(t){const e=this._exports;e!==t&&(this._exports=t,this._exportWatchers.forEach(f),this.connectedCalled&&this.assignedProperty!==!1&&this.component.requestUpdate(this.assignedProperty,e)),this._ready.resolve(t)}setProvisionalExports(t){this._exports=N(t),this._exportWatchers.forEach(f)}watchExports(t){const e=()=>t(this._exports);return this._exportWatchers.add(e),()=>void this._exportWatchers.delete(e)}get use(){return D(this.component),yt}get useRef(){return D(this.component),mt}get useRefSync(){return D(this.component),q}controllerRemoved(){this.component.el.isConnected&&this.triggerDisconnected(),this.triggerDestroy()}onConnected(t){this._callbacks.hostConnected.push(t)}onDisconnected(t){this._callbacks.hostDisconnected.push(t)}onLoad(t){this._callbacks.hostLoad.push(t)}onLoaded(t){this._callbacks.hostLoaded.push(t)}onUpdate(t){this._callbacks.hostUpdate.push(t)}onUpdated(t){this._callbacks.hostUpdated.push(t)}onDestroy(t){this._callbacks.hostDestroy.push(t)}onLifecycle(t){this._callbacks.hostLifecycle.push(t),this.connectedCalled&&this.component.el.isConnected&&this._callLifecycle(t)}triggerConnected(){const t=this;t.hostConnected&&f(t.hostConnected,t),this._callbacks.hostConnected.forEach(f),this.triggerLifecycle(),this.connectedCalled=!0}triggerDisconnected(){const t=this;t.hostDisconnected&&f(t.hostDisconnected,t),this._callbacks.hostDisconnected.forEach(f),this._lifecycleCleanups.forEach(f),this._lifecycleCleanups=[]}async triggerLoad(){if(this._loadCalled)return;this._loadCalled=!0;const t=this;t.hostLoad&&await S(t.hostLoad,t),this._callbacks.hostLoad.length>0&&await Promise.allSettled(this._callbacks.hostLoad.map(S)),this._ready.resolve(this._exports)}triggerLoaded(){if(this.loadedCalled)return;const t=this;t.hostLoaded&&f(t.hostLoaded,t),this._callbacks.hostLoaded.forEach(f),this.loadedCalled=!0}triggerUpdate(t){const e=this;e.hostUpdate&&f(e.hostUpdate,e,t),this._callbacks.hostUpdate.forEach(K,t)}triggerUpdated(t){const e=this;e.hostUpdated&&f(e.hostUpdated,e,t),this._callbacks.hostUpdated.forEach(K,t)}triggerDestroy(){const t=this;t.hostDestroy&&f(t.hostDestroy,t),this._callbacks.hostDestroy.forEach(f)}triggerLifecycle(){const t=this;t.hostLifecycle&&this._callLifecycle(()=>t.hostLifecycle()),this._callbacks.hostLifecycle.forEach(this._callLifecycle,this)}_callLifecycle(t){D(this.component);const e=f(t);(Array.isArray(e)?e:[e]).forEach(o=>{typeof o=="function"?this._lifecycleCleanups.push(o):typeof o=="object"&&typeof o.remove=="function"&&this._lifecycleCleanups.push(o.remove)})}};function K(t){f(t,void 0,this)}var Y=X;function N(t){if(typeof t!="object"&&typeof t!="function"||t===null)return t;const e=new Proxy(t,{get(s,o,r){if(!(gt.has(o)&&o in s&&s[o]===e)&&(o in s||o in Promise.prototype||typeof o=="symbol"))return typeof s=="function"?s[o]:Reflect.get(s,o,r)},set:(s,o,r,n)=>Reflect.set(s,o,r,n)});return e}var gt=new Set(["exports","_exports"]);function _t(t,e,s){const o=Object.keys(t),r=o.length;_===void 0&&queueMicrotask(Z),_??(_=new Map);let n=_.get(t);return n===void 0&&(n={callbacks:[],keyCount:r},_.set(t,n)),n.keyCount!==r&&(n.callbacks.forEach(c=>c(o)),n.callbacks=[],n.keyCount=r),n.callbacks.push(c=>{const i=l=>f(e,null,l),a=c[r];a===void 0?i(void 0):t[a]===s?i(a):i(void 0)}),s}var _=void 0;function Z(){Array.from((_==null?void 0:_.entries())??[]).forEach(([t,{callbacks:e}])=>{const s=Object.keys(t);e.forEach(o=>o(s))}),_=void 0}function tt(t,e,s){var o;const r=e,n=t.manager.internals;(o=n.allWatchers)[r]??(o[r]=[]);const c=n.allWatchers[r],i=s,a=(l,d,h)=>f(i,null,l,d,h);return c.push(a),()=>{const l=c.indexOf(a);l!==-1&&c.splice(l,1)}}var vt=class{constructor(t){this.enabledWatchers={},this.allWatchers={},this.enableReadonly=()=>{if(this.enableReadonly=void 0,!this.component.manager.isLit)return;const e=this.component.manager.internals;Object.entries(e.members).forEach(([s,[o]])=>{var r;o&2048&&((r=e.setters)[s]??(r[s]=[]),e.setters[s].push(e.readonlySetter))})},this.trackedValue=I,this.keyTrackers=[],this.getters={},this.setters={},this.accessorGetter={},this.accessorSetter={},this.reactiveUtilsIntegrations=new Set,this._exports=new WeakMap,this.readonlySetter=(e,s,o)=>{if(v.readOnly)return e;throw new Error(`Cannot assign to read-only property "${o}" of ${this.component.el.tagName.toLowerCase()}. Trying to assign "${String(e)}"`)},this.component=t}firePropTrackers(t,e){const s=this.keyTrackers;this.trackedValue=I,this.keyTrackers=[],s.forEach(o=>o(t,e))}getSetProxy(t){const e=this.component,s=e.constructor.prototype;if(this._getSetProxy(s,t,"class"),e.manager.isLit)return;const o=e.el.constructor.prototype;s!==o&&this._getSetProxy(o,t,"html")}_getSetProxy(t,e,s){const o=this.component,r=Q(o,e);let n;do n=Object.getOwnPropertyDescriptor(t,e);while(!n&&(t=Object.getPrototypeOf(t)));if(!n)return;const c=n.get,i=n.set,a=U in c,l=U in i;if(a&&l)return;const d=!a,h=!l,u=d?function(){let y=c.call(this);const g=A.get(this);if(v.getter||g===void 0)return y;const L=g.manager.internals;y=L.accessorGetter[e](y,e);const p=L.getters[e]??R;for(let m=0;m<p.length;m++)y=p[m](y,e);return y}:c,b=h?function(y){var V;const g=c.call(this),L=A.get(this);if(L===void 0){i.call(this,y);return}let p=L.manager.isLit?y??void 0:dt(y,r);const m=L.manager.internals;if(p===g)i.call(this,p);else{const $=v.setter?R:m.setters[e]??R;for(let x=0;x<$.length&&(p=$[x](p,g,e),p!==g);x++);p=m.accessorSetter[e](p,g,e),i.call(this,p),p!==g&&((V=m.enabledWatchers[e])==null||V.forEach(x=>x(p,g,e)))}m.keyTrackers.length>0&&(m==null||m.firePropTrackers(e,y))}:i;d&&(u[U]=!0),h&&(b[U]=!0),Object.defineProperty(t,e,{...n,get:u,set:b})}markExports(t,e){(typeof e=="object"&&e!==null||typeof e=="function")&&this._exports.set(e,t)}resolveExports(t){if(typeof t=="object"&&t!==null||typeof t=="function")return this._exports.get(t)}},R=[],U=Symbol(),I=Symbol(),qt=(t,e)=>new Ct(t,e),Ct=class extends Y{constructor(t,e){const s="addController"in t,o=new Set;function r(a){var l;o.add(a),!(G in a)&&t.renderRoot&&t.el.isConnected&&((l=a.hostConnected)==null||l.call(a))}function n(a){var l;o.delete(a),(l=a.controllerRemoved)==null||l.call(a)}const c=t;if(c.addController=r,c.removeController=n,!s){const a=e??t.constructor.__forceUpdate;c.requestUpdate=()=>a(t)}super(t),this.internals=new vt(this.component),this.destroyed=!1,this._updatePromise=new j,this._originalLifecycles={},this.isLit=s,this.component.manager=this,lt(t,s),this._controllers=o,this.exports=void 0,this.hasDestroy=T in this.component&&typeof this.component.destroy=="function",this._bindLifecycleMethods();const i=this.internals;Object.keys(i.members).forEach(a=>{i.accessorGetter[a]=E,i.accessorSetter[a]=E,i.getSetProxy(a)}),s?this.internals.enabledWatchers=this.internals.allWatchers:Object.defineProperty(t,"updateComplete",{get:async()=>await this._updatePromise.promise}),queueMicrotask(i.enableReadonly),H(void 0),D(t),A.set(t.el,t),A.set(t,t)}_bindLifecycleMethods(){const t=this.component,e=this.isLit,s=t.el===t;this._originalLifecycles={_connectedCallback:e||s?void 0:t.connectedCallback,_disconnectedCallback:e||s?void 0:t.disconnectedCallback,_load:e?t.load:t.componentWillLoad,_loaded:e?t.loaded:t.componentDidLoad,_willUpdate:e?void 0:t.componentWillUpdate,_updated:e?void 0:t.componentDidUpdate,_destroy:t.destroy};const o=this._connectedCallback.bind(this),r=this._disconnectedCallback.bind(this),n=this._update.bind(this),c=this._updated.bind(this);e?t.constructor.prototype.addController.call(t,{hostConnected:o,hostDisconnected:r,hostUpdate:n,hostUpdated:c}):(t.connectedCallback=o,t.disconnectedCallback=r,t.componentWillLoad=this._load.bind(this),t.componentDidLoad=this._loaded.bind(this),t.componentWillUpdate=n,t.componentDidUpdate=c),this.hasDestroy&&(t.destroy=this.destroy.bind(this))}_connectedCallback(){var e,s;if(this.destroyed){const o=this.component.el.tagName.toLowerCase();throw this.component.el.remove(),new Error(`The ${o} component has already been destroyed. It cannot be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the ${T} prop.`)}this._autoDestroyTimeout!==void 0&&clearTimeout(this._autoDestroyTimeout);const t=this.internals;t.enabledWatchers=t.allWatchers,Z(),(e=t.enableReadonly)==null||e.call(t),this._controllers.forEach(Lt),(s=this._originalLifecycles._connectedCallback)==null||s.call(this.component)}_disconnectedCallback(){var t;this.destroyed||(this._controllers.forEach(kt),(t=this._originalLifecycles._disconnectedCallback)==null||t.call(this.component),this.hasDestroy&&this._setAutoDestroyTimeout())}async _load(){var e;const t=this.internals.reactiveUtilsIntegrations;if(t.size>0)for(const s of t)"triggerLoad"in s?await s.triggerLoad():await S(s.hostLoad,s);await Promise.allSettled(Array.from(this._controllers,wt,t)),await((e=this._originalLifecycles._load)==null?void 0:e.call(this.component)),this.hasDestroy&&tt(this.component,T,()=>this._setAutoDestroyTimeout())}_loaded(){var t;this._controllers.forEach(xt),(t=this._originalLifecycles._loaded)==null||t.call(this.component)}_update(){var e;const t=this.component;this._controllers.forEach(Pt,t.$changes),(e=this._originalLifecycles._willUpdate)==null||e.call(this.component)}_updated(){var e;const t=this.component;if(this._controllers.forEach(Dt,t.$changes),(e=this._originalLifecycles._updated)==null||e.call(this.component),this.isLit)t.$changes=new Map;else{const s=this._updatePromise;this._updatePromise=new j,s.resolve(!0)}}async destroy(){var t;if(!this.destroyed){if(this.component.el.isConnected){this.hasDestroy=!1;try{this.component.el.remove()}finally{this.hasDestroy=!0}}this._autoDestroyTimeout=void 0,this.destroyed=!0,this._controllers.forEach(Et),this._controllers.clear(),await((t=this._originalLifecycles._destroy)==null?void 0:t.call(this.component))}}_setAutoDestroyTimeout(){if(this._autoDestroyTimeout!==void 0&&clearTimeout(this._autoDestroyTimeout),!this.component.el.isConnected&&!this.component.autoDestroyDisabled){const t=()=>void this.destroy().catch(console.error);this._autoDestroyTimeout=rt(t,bt)}}},T="autoDestroyDisabled",bt=1e3,E=t=>t;function Lt(t){"triggerConnected"in t?t.triggerConnected():f(t.hostConnected,t)}function kt(t){"triggerDisconnected"in t?t.triggerDisconnected():f(t.hostDisconnected,t)}async function wt(t){this.has(t)||("triggerLoad"in t?await t.triggerLoad():await S(t.hostLoad,t))}function xt(t){"triggerLoaded"in t?t.triggerLoaded():f(t.hostLoaded,t)}function Pt(t){"triggerUpdate"in t?t.triggerUpdate(this):f(t.hostUpdate,t,this)}function Dt(t){"triggerUpdated"in t?t.triggerUpdated(this):f(t.hostUpdated,t,this)}function Et(t){"triggerDestroy"in t?t.triggerDestroy():f(t.hostDestroy,t)}function B(t,e,s){const o=t.manager.internals;return o.trackedValue!==I&&o.trackedValue!==s&&o.firePropTrackers(void 0,void 0),o.keyTrackers.length===0&&queueMicrotask(()=>o.firePropTrackers(void 0,void 0)),o.trackedValue=s,o.keyTrackers.push((r,n)=>f(e,void 0,s===n?r:void 0)),s}function et(t,e,s){const o=Array.isArray(t)?t:[t];let r=o.length+1;const n=i=>{r-=1,i!==void 0&&(r=Math.min(r,0)),r===0&&e(i)};o.forEach(i=>_t(i,a=>n(a===void 0?void 0:{key:a,host:i,isReactive:!1}),s));const c=o.find(i=>"manager"in i&&typeof i.manager=="object"&&i.manager.component===i);return c&&B(c,i=>n(i===void 0?void 0:{key:i,host:c,isReactive:Q(c,i)!==void 0}),s),s}function Ut(t,e){const s=O();return B(s,o=>{const r=o,n=s.manager,c=s,i=c[r];if(i!=null&&i!==t&&typeof e.set=="function"&&!!1){const l=e.set(i,t,r);if(l!==i)if(n.isLit)c[r]=l;else{let d=!0;n.onConnected(()=>{d&&(d=!0,st(()=>{c[r]=l}))})}}St(s,r,e)},t)}function st(t){v.setter=!0;try{return t()}finally{v.setter=!1}}function ot(t){v.getter=!0;try{return t()}finally{v.getter=!1}}function St(t,e,s){var o,r;const n=s,c=t.manager.internals,i=typeof n.get=="function"?n.get:void 0;i&&((o=c.getters)[e]??(o[e]=[]),c.getters[e].unshift(i));const a=n.set==="ignore"?At:n.set;a&&((r=c.setters)[e]??(r[e]=[]),c.setters[e].unshift(a))}var At=(t,e)=>e;function Bt(t){const e=O();return Ut(t,{set:e.manager.internals.readonlySetter})}function Ot(t){v.readOnly=!0;try{return t()}finally{v.readOnly=!1}}var Rt=t=>(...e)=>{const s=ft(),o=new t(...e),r=o.exports;H(s.at(-1));const n=o.component.manager.internals;n.markExports(o,r),o.watchExports(i=>n.markExports(o,i)),ut(o);const c=[o.component,...s].reverse();return et(c,i=>i===void 0?void 0:Tt(o,i,r),r)};function Tt(t,{host:e,key:s,isReactive:o},r){const n=e,c=n[s]!==t.exports,i=n[s]!==r,a=r!==t.exports;if(c&&!i&&a&&(n[s]=t.exports),e===t.component){if(o){const d=t.component.manager.internals;i&&d.markExports(t,n[s]),tt(t.component,s,h=>{h!==t.exports&&d.markExports(t,h)})}t.assignedProperty=o?void 0:s}t.watchExports(()=>{var u;if(n[s]===t.exports)return;const d=t.component.manager;((u=d.internals.setters[s])==null?void 0:u.includes(d.internals.readonlySetter))?Ot(()=>{n[s]=t.exports}):n[s]=t.exports})}var W;async function Wt(){return W??(W=ct()),await W}var Mt=Promise.all([nt(),it()]),F=class extends X{async hostLoad(){const[t,{subclass:e,property:s}]=await Mt;class o extends t{}const r=(h,u)=>d[u];function n(h,u,b){return d!==void 0&&(d[b]=h),h}const c=this.component,i=c.manager.internals,a=[];if(ot(()=>Object.keys(i.members).forEach(h=>{i.accessorSetter[h]===E&&(a.push(h),i.accessorGetter[h]=r,i.accessorSetter[h]=n,s({value:c[h]})(o.prototype,h))})),this._enabledMembers=a,a.length===0)return;const l=e(c.el.tagName)(o),d=new l;this._instance=d}controllerRemoved(){var e,s;super.controllerRemoved();const t=this.component.manager.internals;(e=this._instance)==null||e.destroy(),(s=this._enabledMembers)==null||s.forEach(o=>{t.accessorGetter[o]=E,t.accessorSetter[o]=E})}},Vt=(t,e)=>(s,o)=>It(s,t,o),jt=class extends Y{constructor(t,e,s){super(t),this._loadAccessor=e,this._options=s,this._watchedProperties=new Map,this._isBinding={value:!0},this.setProvisionalExports(M.makeGetterProxy(t,this._watchedProperties,this._isBinding,this.constructor.allowedPropNameMismatches));const o=t.manager.internals.reactiveUtilsIntegrations;o.add(this);const r=Array.from(o).find(n=>n instanceof F);r&&o.delete(r),o.add(r??new F(this.component)),B(t,n=>{n&&(this._instancePropName=n)},this.exports)}hostConnected(){this._isBinding.value=!1}async hostLoad(){var i,a;this.reactiveUtils=await Wt();const t=this.component,e=this._gatherParameters(),s=((a=(i=this._options)==null?void 0:i.editConstructorProperties)==null?void 0:a.call(t,e))??e,o=s instanceof Promise?await s:s,r=t,n=typeof this._instancePropName=="string"?r[this._instancePropName]:void 0;n!=null&&n!==this.exports?(this._instance=n,n.set(o)):this._instance=await this._createInstance(o),!t.manager.destroyed&&(M.watchComponentUpdates(this,this._instance,this._watchedProperties),M.watchAccessorUpdates(this,this._instance,this._watchedProperties),this.exports=this._instance)}_gatherParameters(){return Object.fromEntries(Array.from(this._watchedProperties,([s,o])=>[o,this.component[s]]).filter(([,s])=>s!==void 0))}async _createInstance(t){return this._isAccessorConstructor(this._loadAccessor)?new this._loadAccessor(t):await this._loadAccessor(t)}_isAccessorConstructor(t){return"prototype"in t&&"declaredClass"in t.prototype}hostDestroy(){this._instance&&this._instance.destroy()}async reCreate(){this.hostDestroy(),await this.hostLoad()}},It=Rt(jt),M={makeGetterProxy:(t,e,s,o)=>new Proxy({},{has:(r,n)=>typeof n=="string"||n in r,get:(r,n)=>{const c=Reflect.get(r,n);if(typeof n=="symbol"||n in Promise.prototype)return c;const i=n in r,a=(s==null?void 0:s.value)??!0;return i||!a?c:et(t,l=>{l!==void 0&&e.set(l.key,n)},c)}}),watchComponentUpdates(t,e,s){function o(i,a){const l=s.get(a),d=e[l];return typeof d=="boolean"&&l!==a&&a.toLowerCase().includes("disable")?!d:d}const r=(i,a,l)=>{const d=s.get(l),h=e[d],u=typeof h=="boolean"&&d!==l&&l.toLowerCase().includes("disable");if((u?!h:n.manager.isLit?h??void 0:h)===i)return i;e[d]=u?!i:i;const w=e[d];return u?!w:w},n=t.component,c=n.manager.internals;s.forEach((i,a)=>{c.accessorGetter[a]=o,c.accessorSetter[a]=r})},watchAccessorUpdates(t,e,s){const{component:o}=t,r=o,n=e,c=Gt(e);ot(()=>s.forEach((i,a)=>{if(c.has(i))return;const l=r[a];let d=n[i];o.manager.isLit&&(d??(d=void 0));const u=typeof l=="boolean"&&i!==a&&a.toLowerCase().includes("disable")?!l:l;u!=null&&d!==u&&(n[i]=u)})),t.onLifecycle(()=>{if(!e.destroyed)return Array.from(s,([i,a])=>t.reactiveUtils.watch(()=>n[a],()=>{const l=n[a],h=typeof l=="boolean"&&a!==i&&i.toLowerCase().includes("disable")?!l:l;st(()=>{r[i]=h})},{initial:!0}))})},reEmitAccessorEvents(t,e,s,o){if(!("on"in e&&typeof e.on=="function"))return;const n=Object.entries(t.component).map(([a,l])=>{const d=l;if(!a.startsWith(o)||a===o||typeof d!="object"||d===null||!("emit"in d)||typeof d.emit!="function")return;const h=d.emit,u=a.slice(o.length);return[at(u).toLowerCase(),h]}).filter(z);if(n.length===0)return;const c=e,i=()=>c;t.onLifecycle(()=>{if(!e.destroyed)return n.map(([a,l])=>s.on(i,a,l))})},async reCreate(t,e){const s=e.manager.useRefSync(t);s!==void 0&&await s.reCreate()}};function Gt(t){var o;const s=Object.entries(((o=t.__accessor__)==null?void 0:o.metadata)??{});return new Set(s.filter(([r,n])=>(n==null?void 0:n.readOnly)===!0).map(([r])=>r))}export{jt as A,X as C,M as a,Ut as g,Vt as m,Rt as p,Bt as r,D as s,B as t,qt as u,tt as w};
