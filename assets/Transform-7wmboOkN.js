import{r as M,o as w,E as H}from"./vec32-Dvg_eL9J.js";import{F as y,l as O,e as z,N as a,A as _}from"./projectBuffer-Bs7GwaPY.js";import{s as F,t as C}from"./Point-Cg0-ChZE.js";import{r as h}from"./tslib.es6-B3Jf3DVX.js";import{b as j}from"./Accessor-BLX9ikPh.js";import{o as L}from"./Evented-BHRw9x22.js";import{n as G,m as d,a as P}from"./subclass-BZA_h8Db.js";import{_ as W}from"./mat4-GpOFENPA.js";import{e as B}from"./mat4f64-Dk4dwAN8.js";import{n as R}from"./vec3f64-BLpZdpfb.js";import{a as T}from"./RenderTexture-CDO7DfmT.js";import{D as S,j as q}from"./Polyline-D9YkgmM_.js";import{V as I}from"./sphere-C77djCO6.js";import{e as b}from"./ElevationRange-BrgM1moX.js";import{b as D}from"./LineCallout.glsl-C1R4fy2f.js";import{T as K}from"./dehydratedFeatureUtils-B--Sgpdi.js";import{e as U}from"./intersectorUtils-BK9EUwUf.js";function pe(e,r,t,i){if(r==null||i==null)return!1;const n=y(r,O),o=y(i,z);if(n===o&&n!==a.UNKNOWN||F(r,i))return t[0]=1,t[1]=1,t[2]=1,!0;if(n===a.SPHERICAL_ECEF){const c=M(e),m=c/Math.sqrt(e[0]*e[0]+e[1]*e[1]),u=c/C.radius;if(o===a.WEB_MERCATOR)return t[0]=m*u,t[1]=m*u,t[2]=1,!0;if(o===a.WGS84||o===a.CGCS2000){const s=_;return t[0]=s*m*u,t[1]=s*u,t[2]=1,!0}}else if(n===a.PLATE_CARREE){if(o===a.WGS84||o===a.CGCS2000)return t[0]=_,t[1]=_,t[2]=1,!0;if(o===a.WEB_MERCATOR){const c=e[1]/C.radius;return t[0]=1,t[1]=1/Math.cos(c),t[2]=1,!0}}return!1}let p=class extends L.EventedMixin(j){constructor(e){super(e),this._tmpEvent=new D,this._renderCoordsHelper=e.view.renderCoordsHelper,this._renderSR=this._renderCoordsHelper.spatialReference,this._layerElevationSource=e.layerElevationSource}initialize(){this._intersector=K(this.view.state.viewingMode),this._intersector.options.store=U.MIN,this._intersector.options.normalRequired=!1,this._tmpEvent.context=this.intersectionHandler.isGround?"ground":"scene"}get spatialReference(){var e,r;return(r=(e=this.view)==null?void 0:e.elevationProvider)==null?void 0:r.spatialReference}getElevation(e,r,t,i){const n=this._renderCoordsHelper,o=w(l,e,r,t);if(!n.toRenderCoords(o,i,o))return G.getLogger(this).error("could not project point to compute elevation"),null;const{layerElevationSource:c,_intersector:m,intersectionHandler:u}=this,s=c.fullExtent,v=s!=null&&Number.isFinite(s.xmin)&&Number.isFinite(s.xmax)&&Number.isFinite(s.ymin)&&Number.isFinite(s.ymax)&&Number.isFinite(s.zmin)&&Number.isFinite(s.zmax)?new b(s.zmin,s.zmax):c.elevationRange;if(v==null)return null;const E=c.elevationOffset,$=v.elevationRangeMin+E,A=v.elevationRangeMax+E,x=n.setAltitude(V,A,o),g=n.setAltitude(Z,$,o);return m.reset(x,g,null),u.intersect(m,null,x,g,null,!0),m.results.min.getIntersectionPoint(o)?n.getAltitude(o):null}getSphereElevationBounds(e,r){return T(e,r,N,this._renderSR),this._layerElevationSource.getElevationRange(N)}getRootElevationBounds(){const e=this.layerElevationSource.fullExtent;return e!=null&&e.hasZ?new b(e.zmin,e.zmax):null}objectsChanged(e){this.spatialReference&&(this._computeLayerExtent(e,this._tmpEvent.extent),this._tmpEvent.spatialReference=this.spatialReference,this.emit("elevation-change",this._tmpEvent))}objectChanged(e){this.spatialReference&&(this._computeObjectExtent(e,this._tmpEvent.extent),this._tmpEvent.spatialReference=this.spatialReference,this.emit("elevation-change",this._tmpEvent))}_computeObjectExtent(e,r){S(r),this._expandExtent(e,r)}_computeLayerExtent(e,r){S(r);for(const t of e)this._expandExtent(t,r)}_expandExtent(e,r){const t=this.spatialReference;if(t==null||e==null)return;W(f,e.quaternion),f[12]=e.center[0],f[13]=e.center[1],f[14]=e.center[2];const i=e.halfSize;for(let n=0;n<8;++n)l[0]=1&n?i[0]:-i[0],l[1]=2&n?i[1]:-i[1],l[2]=4&n?i[2]:-i[2],H(l,l,f),this._renderCoordsHelper.fromRenderCoords(l,l,t),q(r,l,r)}};h([d({constructOnly:!0})],p.prototype,"layerElevationSource",void 0),h([d({constructOnly:!0})],p.prototype,"intersectionHandler",void 0),h([d({constructOnly:!0})],p.prototype,"view",void 0),h([d()],p.prototype,"spatialReference",null),p=h([P("esri.views.3d.layers.i3s.LayerElevationProvider")],p);const f=B(),N=I(0,0,0,0),l=R(),V=R(),Z=R();class he{constructor(r,t,i,n){this.toMapSpace=r,this.transform=t,this.obb=i,this.geometry=n}}class fe{constructor(r,t){this.position=r,this.rotationScale=t,this.origin=void 0}}export{pe as f,fe as i,he as t,p as x};
