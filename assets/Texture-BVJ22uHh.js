import{B as C,s as _,M as $,i as V,E as k}from"./Accessor-BmwT4B0c.js";import{r as z}from"./signal-CySMLEX9.js";import{A as K,c as T,P as n,B as M,G as p,M as f,U as w,L as d,D as Y,V as B}from"./enums-D9v74xTE.js";import{s as q}from"./getDataTypeBytes-BTGR5GyG.js";const j=()=>C.getLogger("esri.views.webgl.checkWebGLError");function Z(t,e){switch(e){case t.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case t.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case t.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case t.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case t.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case t.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const L=!!$("enable-feature:webgl-debug");function X(){return L}function he(){return L}function b(t){if(X()){const e=t.getError();if(e){const r=Z(t,e),s=new Error().stack;j().error(new _("webgl-error","WebGL error occurred",{message:r,stack:s}))}}}function J(t){const e=t.gl;switch(e.getError()){case e.NO_ERROR:return null;case e.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case e.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case e.INVALID_OPERATION:return"The specified command is not allowed for the current state";case e.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case e.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case e.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function pe(t,e){var r;return(((r=t.vertexBuffers.get(e))==null?void 0:r.usedMemory)??0)/Q(t.layout.get(e))}function Q(t){return t[0].stride}function me(t,e,r,s,i=0){var l;const c=t.gl;t.bindBuffer(r);for(const o of s){const a=e.get(o.name);if(a==null){console.warn(`There is no location for vertex attribute '${o.name}' defined.`);continue}const h=i*o.stride;if(o.count<=4)c.vertexAttribPointer(a,o.count,o.type,o.normalized,o.stride,o.offset+h),c.enableVertexAttribArray(a),o.divisor>0&&t.gl.vertexAttribDivisor(a,o.divisor);else if(o.count===9)for(let u=0;u<3;u++)c.vertexAttribPointer(a+u,3,o.type,o.normalized,o.stride,o.offset+12*u+h),c.enableVertexAttribArray(a+u),o.divisor>0&&t.gl.vertexAttribDivisor(a+u,o.divisor);else if(o.count===16)for(let u=0;u<4;u++)c.vertexAttribPointer(a+u,4,o.type,o.normalized,o.stride,o.offset+16*u+h),c.enableVertexAttribArray(a+u),o.divisor>0&&((l=t.gl)==null||l.vertexAttribDivisor(a+u,o.divisor));else console.error("Unsupported vertex attribute element count: "+o.count);if(X()){const u=J(t),m=q(o.type),E=o.offset,g=Math.round(m/E)!==m/E?`. Offset not a multiple of stride. DataType requires ${m} bytes, but descriptor has an offset of ${E}`:"";u&&console.error(`Unable to bind vertex attribute "${o.name}" with baseInstanceOffset ${h}${g}:`,u,o)}}}function _e(t,e,r,s){var c,l,o;const i=t.gl;t.bindBuffer(r);for(const a of s){const h=e.get(a.name);if(a.count<=4)i.disableVertexAttribArray(h),a.divisor&&a.divisor>0&&((c=t.gl)==null||c.vertexAttribDivisor(h,0));else if(a.count===9)for(let u=0;u<3;u++)i.disableVertexAttribArray(h+u),a.divisor&&a.divisor>0&&((l=t.gl)==null||l.vertexAttribDivisor(h+u,0));else if(a.count===16)for(let u=0;u<4;u++)i.disableVertexAttribArray(h+u),a.divisor&&a.divisor>0&&((o=t.gl)==null||o.vertexAttribDivisor(h+u,0));else console.error("Unsupported vertex attribute element count: "+a.count)}t.unbindBuffer(K.ARRAY_BUFFER)}function ee(t){switch(t){case p.ALPHA:case p.LUMINANCE:case p.RED:case p.RED_INTEGER:case n.R8:case n.R8I:case n.R8UI:case n.R8_SNORM:case M.STENCIL_INDEX8:return 1;case p.LUMINANCE_ALPHA:case p.RG:case p.RG_INTEGER:case n.RGBA4:case n.R16F:case n.R16I:case n.R16UI:case n.RG8:case n.RG8I:case n.RG8UI:case n.RG8_SNORM:case n.RGB565:case n.RGB5_A1:case M.DEPTH_COMPONENT16:return 2;case p.DEPTH_COMPONENT:case p.RGB:case p.RGB_INTEGER:case n.RGB8:case n.RGB8I:case n.RGB8UI:case n.RGB8_SNORM:case n.SRGB8:case M.DEPTH_COMPONENT24:return 3;case p.DEPTH_STENCIL:case p.DEPTH24_STENCIL8:case p.RGBA:case p.RGBA_INTEGER:case n.RGBA8:case n.R32F:case n.R11F_G11F_B10F:case n.RG16F:case n.R32I:case n.R32UI:case n.RG16I:case n.RG16UI:case n.RGBA8I:case n.RGBA8UI:case n.RGBA8_SNORM:case n.SRGB8_ALPHA8:case n.RGB9_E5:case n.RGB10_A2UI:case n.RGB10_A2:case M.DEPTH_STENCIL:case M.DEPTH_COMPONENT32F:case M.DEPTH24_STENCIL8:return 4;case M.DEPTH32F_STENCIL8:return 5;case n.RGB16F:case n.RGB16I:case n.RGB16UI:return 6;case n.RG32F:case n.RG32I:case n.RG32UI:case n.RGBA16F:case n.RGBA16I:case n.RGBA16UI:return 8;case n.RGB32F:case n.RGB32I:case n.RGB32UI:return 12;case n.RGBA32F:case n.RGBA32I:case n.RGBA32UI:return 16;case T.COMPRESSED_RGB_S3TC_DXT1_EXT:case T.COMPRESSED_RGBA_S3TC_DXT1_EXT:return .5;case T.COMPRESSED_RGBA_S3TC_DXT3_EXT:case T.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case T.COMPRESSED_R11_EAC:case T.COMPRESSED_SIGNED_R11_EAC:case T.COMPRESSED_RGB8_ETC2:case T.COMPRESSED_SRGB8_ETC2:case T.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case T.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return .5;case T.COMPRESSED_RG11_EAC:case T.COMPRESSED_SIGNED_RG11_EAC:case T.COMPRESSED_RGBA8_ETC2_EAC:case T.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}var U;(function(t){t[t.Texture=0]="Texture",t[t.RenderBuffer=1]="RenderBuffer"})(U||(U={}));let te=class{constructor(e=0,r=e){this.width=e,this.height=r,this.target=f.TEXTURE_2D,this.pixelFormat=p.RGBA,this.dataType=w.UNSIGNED_BYTE,this.samplingMode=d.LINEAR,this.wrapMode=Y.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.shouldCompress=!1,this.depth=1,this.isImmutable=!1}};function re(t){return t.width<=0||t.height<=0?0:Math.round(t.width*t.height*t.depth*(t.hasMipmap?4/3:1)*(t.internalFormat==null?4:ee(t.internalFormat))*(t.target===f.TEXTURE_CUBE_MAP?6:1))}const se=()=>C.getLogger("esri/views/webgl/textureUtils");function N(t){(t.width!=null&&t.width<0||t.height!=null&&t.height<0||t.depth!=null&&t.depth<0)&&se().error("Negative dimension parameters are not allowed!")}function ie(t){return t in n}function H(t){return t in T}function S(t){return t!=null&&"type"in t&&t.type==="compressed"}function Ee(t){return!!t.descriptor.internalFormat&&H(t.descriptor.internalFormat)}function ae(t){return t!=null&&"byteLength"in t}function O(t){return t!=null&&!S(t)&&!ae(t)}function D(t){return t===f.TEXTURE_3D||t===f.TEXTURE_2D_ARRAY}function y(t,e,r,s=1){let i=Math.max(e,r);return t===f.TEXTURE_3D&&(i=Math.max(i,s)),Math.floor(Math.log2(i))+1}function P(t){if(t.internalFormat!=null)return t.internalFormat===p.DEPTH_STENCIL?p.DEPTH24_STENCIL8:t.internalFormat;switch(t.dataType){case w.FLOAT:switch(t.pixelFormat){case p.RGBA:return n.RGBA32F;case p.RGB:return n.RGB32F;default:throw new _("Unable to derive format")}case w.UNSIGNED_BYTE:switch(t.pixelFormat){case p.RGBA:return n.RGBA8;case p.RGB:return n.RGB8}}return t.internalFormat=t.pixelFormat===p.DEPTH_STENCIL?p.DEPTH24_STENCIL8:t.pixelFormat}function oe(t){let e="width"in t?t.width:t.codedWidth,r="height"in t?t.height:t.codedHeight;return t instanceof HTMLVideoElement&&(e=t.videoWidth,r=t.videoHeight),{width:e,height:r,depth:1}}class G extends te{constructor(e,r){switch(super(),this.context=e,Object.assign(this,r),this.internalFormat){case n.R16F:case n.R16I:case n.R16UI:case n.R32F:case n.R32I:case n.R32UI:case n.R8_SNORM:case n.R8:case n.R8I:case n.R8UI:this.pixelFormat=p.RED}}static validate(e,r){return new G(e,r)}}const x=()=>C.getLogger("esri/views/webgl/Texture");let v=class R{constructor(e,r=null,s=null){if(this.type=U.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,this._compressionAbortController=z(null),"context"in e)this._descriptor=e,s=r;else{const i=G.validate(e,r);if(!i)throw new _("Texture descriptor invalid");this._descriptor=i}this._descriptor.target===f.TEXTURE_CUBE_MAP?this._setDataCubeMap(s):this.setData(s)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return re(this._descriptor)}get cachedMemory(){return this.usedMemory}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}get isCompressing(){return this._compressionAbortController.value!==null}dispose(){this.abortCompression(),this._glName&&this._descriptor.context.instanceCounter.decrement(B.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,r){const s=this._descriptor;if(s.width!==e||s.height!==r){if(this._wasImmutablyAllocated)throw new _("Immutable textures can't be resized!");s.width=e,s.height=r,this._descriptor.target===f.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}enableCompression(e){this._descriptor.shouldCompress=e}setData(e){this.abortCompression(),!S(e)&&this._descriptor.internalFormat&&this._descriptor.internalFormat in T&&(this._descriptor.internalFormat=void 0),this._setData(e),!S(e)&&this._descriptor.shouldCompress&&this._compressOnWorker(e)}updateData(e,r,s,i,c,l,o=0){l||x().error("An attempt to use uninitialized data!"),this._glName||x().error("An attempt to update uninitialized texture!");const a=this._descriptor;a.internalFormat=P(a);const{context:h,pixelFormat:u,dataType:m,target:E,isImmutable:g}=a;if(g&&!this._wasImmutablyAllocated)throw new _("Cannot update immutable texture before allocation!");const I=h.bindTexture(this,R.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||s<0||r+i>a.width||s+c>a.height)&&x().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:A}=h;o&&(i&&c||x().warn("Must pass width and height if `UNPACK_SKIP_ROWS` is used"),A.pixelStorei(A.UNPACK_SKIP_ROWS,o)),O(l)?A.texSubImage2D(E,e,r,s,i,c,u,m,l):S(l)?A.compressedTexSubImage2D(E,e,r,s,i,c,a.internalFormat,l.levels[e]):A.texSubImage2D(E,e,r,s,i,c,u,m,l),o&&A.pixelStorei(A.UNPACK_SKIP_ROWS,0),h.bindTexture(I,R.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,r,s,i,c,l,o,a){a||x().error("An attempt to use uninitialized data!"),this._glName||x().error("An attempt to update an uninitialized texture!");const h=this._descriptor;h.internalFormat=P(h);const{context:u,pixelFormat:m,dataType:E,isImmutable:g,target:I}=h;if(g&&!this._wasImmutablyAllocated)throw new _("Cannot update immutable texture before allocation!");D(I)||x().warn("Attempting to set 3D texture data on a non-3D texture");const A=u.bindTexture(this,R.TEXTURE_UNIT_FOR_UPDATES);u.setActiveTexture(R.TEXTURE_UNIT_FOR_UPDATES),(r<0||s<0||i<0||r+c>h.width||s+l>h.height||i+o>h.depth)&&x().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:F}=u;if(S(a))a=a.levels[e],F.compressedTexSubImage3D(I,e,r,s,i,c,l,o,h.internalFormat,a);else{const W=a;F.texSubImage3D(I,e,r,s,i,c,l,o,m,E,W)}u.bindTexture(A,R.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(e.width===0||e.height===0)return;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new _("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,N(e)}e.samplingMode===d.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=d.LINEAR_MIPMAP_NEAREST):e.samplingMode===d.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=d.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,R.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(R.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(r,R.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new _("Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,N(e)}e.samplingMode===d.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,e.samplingMode=d.LINEAR):e.samplingMode===d.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=d.NEAREST)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,N(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){this._samplingModeDirty&&(this._applySamplingMode(),this._samplingModeDirty=!1),this._wrapModeDirty&&(this._applyWrapMode(),this._wrapModeDirty=!1)}abortCompression(){this.isCompressing&&(this._compressionAbortController.value=V(this._compressionAbortController.value))}_setData(e,r){var a;const s=this._descriptor,i=(a=s.context)==null?void 0:a.gl;if(!i)return;b(i),this._glName||(this._glName=i.createTexture(),this._glName&&s.context.instanceCounter.increment(B.Texture,this)),N(s);const c=s.context.bindTexture(this,R.TEXTURE_UNIT_FOR_UPDATES);s.context.setActiveTexture(R.TEXTURE_UNIT_FOR_UPDATES),this._configurePixelStorage(),b(i);const l=r??s.target,o=D(l);if(O(e))this._setDataFromTexImageSource(e,l);else{const{width:h,height:u,depth:m}=s;if(h==null||u==null)throw new _("Width and height must be specified!");if(o&&m==null)throw new _("Depth must be specified!");if(s.internalFormat=P(s),s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(l,s.internalFormat,s.hasMipmap,h,u,m),S(e)){if(!H(s.internalFormat))throw new _("Attempting to use compressed data with an uncompressed format!");this._setDataFromCompressedSource(e,s.internalFormat,l)}else this._texImage(l,0,s.internalFormat,h,u,m,e),b(i),s.hasMipmap&&this.generateMipmap()}this._applySamplingMode(),this._applyWrapMode(),this._applyAnisotropicFilteringParameters(),b(i),s.context.bindTexture(c,R.TEXTURE_UNIT_FOR_UPDATES)}_setDataCubeMap(e=null){for(let r=f.TEXTURE_CUBE_MAP_POSITIVE_X;r<=f.TEXTURE_CUBE_MAP_NEGATIVE_Z;r++)this._setData(e,r)}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:r,flipped:s,preMultiplyAlpha:i}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,r),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,s?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_setDataFromTexImageSource(e,r){const{gl:s}=this._descriptor.context,i=this._descriptor;i.internalFormat=P(i);const c=D(r),{width:l,height:o,depth:a}=oe(e);i.width&&i.height,i.width||(i.width=l),i.height||(i.height=o),c&&i.depth,c&&(i.depth=a),i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(r,i.internalFormat,i.hasMipmap,l,o,a),this._texImage(r,0,i.internalFormat,l,o,a,e),b(s),i.hasMipmap&&(this.generateMipmap(),b(s))}_setDataFromCompressedSource(e,r,s){const i=this._descriptor,{width:c,height:l,depth:o}=i,a=e.levels,h=y(s,c,l,o),u=Math.min(h,a.length)-1;this._descriptor.context.gl.texParameteri(i.target,i.context.gl.TEXTURE_MAX_LEVEL,u),this._forEachMipmapLevel((m,E,g,I)=>{const A=a[Math.min(m,a.length-1)];this._compressedTexImage(s,m,r,E,g,I,A)},u)}_texStorage(e,r,s,i,c,l){const{gl:o}=this._descriptor.context;if(!ie(r))throw new _("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const a=s?y(e,i,c,l):1;if(D(e)){if(l==null)throw new _("Missing depth dimension for 3D texture upload");o.texStorage3D(e,a,r,i,c,l)}else o.texStorage2D(e,a,r,i,c);this._wasImmutablyAllocated=!0}_texImage(e,r,s,i,c,l,o){const a=this._descriptor.context.gl,h=D(e),{isImmutable:u,pixelFormat:m,dataType:E}=this._descriptor;if(u){if(o!=null){const g=o;if(h){if(l==null)throw new _("Missing depth dimension for 3D texture upload");a.texSubImage3D(e,r,0,0,0,i,c,l,m,E,g)}else a.texSubImage2D(e,r,0,0,i,c,m,E,g)}}else{const g=o;if(h){if(l==null)throw new _("Missing depth dimension for 3D texture upload");a.texImage3D(e,r,s,i,c,l,0,m,E,g)}else a.texImage2D(e,r,s,i,c,0,m,E,g)}}_compressedTexImage(e,r,s,i,c,l,o){const a=this._descriptor.context.gl,h=D(e);if(this._descriptor.isImmutable){if(o!=null)if(h){if(l==null)throw new _("Missing depth dimension for 3D texture upload");a.compressedTexSubImage3D(e,r,0,0,0,i,c,l,s,o)}else a.compressedTexSubImage2D(e,r,0,0,i,c,s,o)}else if(h){if(l==null)throw new _("Missing depth dimension for 3D texture upload");a.compressedTexImage3D(e,r,s,i,c,l,0,o)}else a.compressedTexImage2D(e,r,s,i,c,0,o)}async _compressOnWorker(e){var i,c;if(!R.compressionWorkerHandle||!R.compressionWorkerHandle.isCompressible(e))return;const r=(i=this._descriptor.context)==null?void 0:i.gl.getExtension("WEBGL_compressed_texture_etc"),s=(c=this._descriptor.context)==null?void 0:c.gl.getExtension("WEBGL_compressed_texture_s3tc");if(r||s){const l=new AbortController;this._compressionAbortController.value=l;const o={data:await createImageBitmap(e),flipped:this.descriptor.flipped,width:e.width,height:e.height,hasMipmap:this._descriptor.hasMipmap,hasETC:!!r,hasS3TC:!!s};R.compressionWorkerHandle.invoke(o,this._compressionAbortController.value.signal).then(a=>{a&&this.isCompressing&&this.glName&&(this._descriptor.internalFormat=a.internalFormat,this._setData(a.compressedTexture)),l===this._compressionAbortController.value&&(this._compressionAbortController.value=null)}).catch(a=>{k(a)||l!==this._compressionAbortController.value||(this._compressionAbortController.value=null)})}}_forEachMipmapLevel(e,r=1/0){let{width:s,height:i,depth:c,hasMipmap:l,target:o}=this._descriptor;const a=o===f.TEXTURE_3D;if(s==null||i==null||a&&c==null)throw new _("Missing texture dimensions for mipmap calculation");for(let h=0;e(h,s,i,c),l&&(s!==1||i!==1||a&&c!==1)&&!(h>=r);++h)s=Math.max(1,s>>1),i=Math.max(1,i>>1),a&&(c=Math.max(1,c>>1))}_applySamplingMode(){var c;const e=this._descriptor,r=(c=e.context)==null?void 0:c.gl;let s=e.samplingMode,i=e.samplingMode;s===d.LINEAR_MIPMAP_NEAREST||s===d.LINEAR_MIPMAP_LINEAR?(s=d.LINEAR,e.hasMipmap||(i=d.LINEAR)):s!==d.NEAREST_MIPMAP_NEAREST&&s!==d.NEAREST_MIPMAP_LINEAR||(s=d.NEAREST,e.hasMipmap||(i=d.NEAREST)),r.texParameteri(e.target,r.TEXTURE_MAG_FILTER,s),r.texParameteri(e.target,r.TEXTURE_MIN_FILTER,i)}_applyWrapMode(){var s;const e=this._descriptor,r=(s=e.context)==null?void 0:s.gl;typeof e.wrapMode=="number"?(r.texParameteri(e.target,r.TEXTURE_WRAP_S,e.wrapMode),r.texParameteri(e.target,r.TEXTURE_WRAP_T,e.wrapMode)):(r.texParameteri(e.target,r.TEXTURE_WRAP_S,e.wrapMode.s),r.texParameteri(e.target,r.TEXTURE_WRAP_T,e.wrapMode.t))}_applyAnisotropicFilteringParameters(){const e=this._descriptor,r=e.context.capabilities.textureFilterAnisotropic;r&&e.context.gl.texParameterf(e.target,r.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}};v.TEXTURE_UNIT_FOR_UPDATES=0,v.compressionWorkerHandle=null;export{me as E,_e as _,ee as a,X as b,he as c,G as d,U as e,pe as i,L as n,J as o,te as p,Ee as s,b as u,v as w};
