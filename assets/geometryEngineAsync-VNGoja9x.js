import"./geometry-CnaxvJsv.js";import{p as h}from"./workers-D8NOwm_V.js";import{_ as l}from"./Point-TlcsOcXV.js";import{y as m}from"./jsonUtils-DtWlwXHP.js";import"./subclass-BR3PhgZG.js";import"./Extent-B4rrMrqp.js";import"./Evented-CXIxDjmW.js";import"./Accessor-D6mNnsWy.js";import"./Polyline-BQFeqYXi.js";import"./writer-3zufXUNV.js";import"./mathUtils-ClvKsMak.js";import"./jsonMap-DCC6W5ex.js";import"./Queue-DpHko4Yk.js";import"./reactiveUtils-BFQ0BtrB.js";import"./shared-B3wH2qpO.js";import"./assets-BNizZMOZ.js";import"./index-BVncS3aY.js";import"./intl-CArXn1et.js";import"./Promise-CZrWwByK.js";function n(e){var t;return Array.isArray(e)?(t=e[0])==null?void 0:t.spatialReference:e==null?void 0:e.spatialReference}function p(e){return e&&(Array.isArray(e)?e.map(p):e.toJSON?e.toJSON():e)}function o(e){return Array.isArray(e)?e.map(t=>m(t)):m(e)}function S(e,t){let r;return Array.isArray(e)?r=e:(r=[],r.push(e),t!=null&&r.push(t)),r}let f;async function w(){return f||(f=h("geometryEngineWorker",{strategy:"distributed"})),f}async function a(e,t){return(await w()).invoke("executeGEOperation",{operation:e,parameters:p(t)})}async function d(e,t){const r=await w();return Promise.all(r.broadcast("executeGEOperation",{operation:e,parameters:p(t)}))}function q(e){return a("extendedSpatialReferenceInfo",[e])}async function B(e,t){return o(await a("clip",[n(e),e,t]))}async function C(e,t){return o(await a("cut",[n(e),e,t]))}function G(e,t){return a("contains",[n(e),e,t])}function $(e,t){return a("crosses",[n(e),e,t])}function W(e,t,r){return a("distance",[n(e),e,t,r])}function _(e,t){return a("equals",[n(e),e,t])}function F(e,t){return a("intersects",[n(e),e,t])}function K(e,t){return a("touches",[n(e),e,t])}function M(e,t){return a("within",[n(e),e,t])}function Q(e,t){return a("disjoint",[n(e),e,t])}function U(e,t){return a("overlaps",[n(e),e,t])}function X(e,t,r){return a("relate",[n(e),e,t,r])}function Y(e){return a("isSimple",[n(e),e])}async function Z(e){return o(await a("simplify",[n(e),e]))}async function ee(e,t=!1){return o(await a("convexHull",[n(e),e,t]))}async function te(e,t){return o(await a("difference",[n(e),e,t]))}async function re(e,t){return o(await a("symmetricDifference",[n(e),e,t]))}async function ae(e,t){return o(await a("intersect",[n(e),e,t]))}async function ne(e,t=null){const r=S(e,t);return o(await a("union",[n(r),r]))}async function ie(e,t,r,i,c,u){return o(await a("offset",[n(e),e,t,r,i,c,u]))}async function oe(e,t,r,i=!1){const c=[n(e),e,t,r,i];return o(await a("buffer",c))}async function ce(e,t,r,i,c,u){const g=[n(e),e,t,r,i,c,u];return o(await a("geodesicBuffer",g))}async function se(e,t,r=!0){const i=await a("nearestCoordinate",[n(e),e,t,r]);return{...i,coordinate:l.fromJSON(i.coordinate)}}async function ue(e,t){const r=await a("nearestVertex",[n(e),e,t]);return{...r,coordinate:l.fromJSON(r.coordinate)}}async function fe(e,t,r,i){return(await a("nearestVertices",[n(e),e,t,r,i])).map(c=>({...c,coordinate:l.fromJSON(c.coordinate)}))}function y(e){var t;return"xmin"in e?e.center:"x"in e?e:(t=e.extent)==null?void 0:t.center}async function le(e,t,r){if(e==null)throw new s;const i=e.spatialReference;if((r=r??y(e))==null)throw new s;const c=e.constructor.fromJSON(await a("rotate",[i,e,t,r]));return c.spatialReference=i,c}async function pe(e,t){if(e==null)throw new s;const r=e.spatialReference;if((t=t??y(e))==null)throw new s;const i=e.constructor.fromJSON(await a("flipHorizontal",[r,e,t]));return i.spatialReference=r,i}async function ye(e,t){if(e==null)throw new s;const r=e.spatialReference;if((t=t??y(e))==null)throw new s;const i=e.constructor.fromJSON(await a("flipVertical",[r,e,t]));return i.spatialReference=r,i}async function me(e,t,r,i){return o(await a("generalize",[n(e),e,t,r,i]))}async function we(e,t,r){return o(await a("densify",[n(e),e,t,r]))}async function de(e,t,r,i=0){return o(await a("geodesicDensify",[n(e),e,t,r,i]))}function ge(e,t){return a("planarArea",[n(e),e,t])}function he(e,t){return a("planarLength",[n(e),e,t])}function Se(e,t,r){return a("geodesicArea",[n(e),e,t,r])}function xe(e,t,r){return a("geodesicLength",[n(e),e,t,r])}async function Re(e,t){return o(await a("intersectLinesToPoints",[n(e),e,t]))}async function Ae(e,t){await d("changeDefaultSpatialReferenceTolerance",[e,t])}async function Oe(e){await d("clearDefaultSpatialReferenceTolerance",[e])}class s extends Error{constructor(){super("Illegal Argument Exception")}}export{oe as buffer,Ae as changeDefaultSpatialReferenceTolerance,Oe as clearDefaultSpatialReferenceTolerance,B as clip,G as contains,ee as convexHull,$ as crosses,C as cut,we as densify,te as difference,Q as disjoint,W as distance,_ as equals,q as extendedSpatialReferenceInfo,pe as flipHorizontal,ye as flipVertical,me as generalize,Se as geodesicArea,ce as geodesicBuffer,de as geodesicDensify,xe as geodesicLength,ae as intersect,Re as intersectLinesToPoints,F as intersects,Y as isSimple,se as nearestCoordinate,ue as nearestVertex,fe as nearestVertices,ie as offset,U as overlaps,ge as planarArea,he as planarLength,X as relate,le as rotate,Z as simplify,re as symmetricDifference,K as touches,ne as union,M as within};
