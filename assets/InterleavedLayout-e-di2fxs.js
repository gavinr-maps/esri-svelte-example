import{u as a,m as l,i as c,T as o,c as p,h as _,l as y,a as F,p as m,b as w,x as g,y as b,o as v,d as E,g as A,j as T,V as $,q as M,A as z,L as B,B as C,O as x,w as H,E as I,F as O,I as k,U as D,M as G,S as V,k as j,v as q,z as J,C as K,D as N,G as S,H as P}from"./BufferView-_QDXRCew.js";import{s as Q}from"./Util-BIfApRF5.js";function f(n){switch(n){case"u8":case"i8":return 1;case"u16":case"i16":return 2;case"u32":case"i32":case"f32":return 4;case"f64":return 8}}class h{constructor(t,e){this.layout=t,this.buffer=typeof e=="number"?new ArrayBuffer(e*t.stride):e;for(const s of t.fields.keys()){const i=t.fields.get(s);this[s]=new i.constructor(this.buffer,i.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(t,e){const s=this[t];return s&&s.elementCount===e.ElementCount&&s.elementType===e.ElementType?s:null}slice(t,e){return new h(this.layout,this.buffer.slice(t*this.stride,e*this.stride))}copyFrom(t,e=0,s=0,i=t.count){const r=this.stride;if(r%4==0){const d=new Uint32Array(t.buffer,e*r,i*r/4);new Uint32Array(this.buffer,s*r,i*r/4).set(d)}else{const d=new Uint8Array(t.buffer,e*r,i*r);new Uint8Array(this.buffer,s*r,i*r).set(d)}return this}get usedMemory(){return this.byteLength}dispose(){}}class u{constructor(t){this._stride=0,this._lastAligned=0,this._fields=new Map,t&&(this._stride=t.stride,t.fields.forEach(e=>this._fields.set(e[0],{...e[1],constructor:W(e[1].constructor)})))}freeze(){return this}vec2f(t,e){return this._appendField(t,a,e),this}vec2f64(t,e){return this._appendField(t,l,e),this}vec3f(t,e){return this._appendField(t,c,e),this}vec3f64(t,e){return this._appendField(t,o,e),this}vec4f(t,e){return this._appendField(t,p,e),this}vec4f64(t,e){return this._appendField(t,_,e),this}mat3f(t,e){return this._appendField(t,y,e),this}mat3f64(t,e){return this._appendField(t,F,e),this}mat4f(t,e){return this._appendField(t,m,e),this}mat4f64(t,e){return this._appendField(t,w,e),this}vec4u8(t,e){return this._appendField(t,g,e),this}f32(t,e){return this._appendField(t,b,e),this}f64(t,e){return this._appendField(t,v,e),this}u8(t,e){return this._appendField(t,E,e),this}u16(t,e){return this._appendField(t,A,e),this}i8(t,e){return this._appendField(t,T,e),this}vec2i8(t,e){return this._appendField(t,$,e),this}vec2i16(t,e){return this._appendField(t,M,e),this}vec2u8(t,e){return this._appendField(t,z,e),this}vec4u16(t,e){return this._appendField(t,B,e),this}u32(t,e){return this._appendField(t,C,e),this}_appendField(t,e,s){if(this._fields.has(t))return void Q(!1,`${t} already added to vertex buffer layout`);const i=e.ElementCount*f(e.ElementType),r=this._stride;this._stride+=i,this._fields.set(t,{size:i,constructor:e,offset:r,optional:s})}createBuffer(t){return new h(this,t)}createView(t){return new h(this,t)}clone(){const t=new u;return t._stride=this._stride,t._fields=new Map,this._fields.forEach((e,s)=>t._fields.set(s,e)),t.BufferType=this.BufferType,t}get stride(){if(this._lastAligned!==this._fields.size){let t=1;this._fields.forEach(e=>t=Math.max(t,f(e.constructor.ElementType))),this._stride=Math.floor((this._stride+t-1)/t)*t,this._lastAligned=this._fields.size}return this._stride}get fields(){return this._fields}}function Z(){return new u}class tt{constructor(t){this.fields=new Array,t.fields.forEach((e,s)=>{const i={...e,constructor:L(e.constructor)};this.fields.push([s,i])}),this.stride=t.stride}}const R=[b,a,c,p,y,m,v,l,o,_,F,w,E,z,x,g,A,H,I,B,C,O,k,D,T,$,G,V,j,M,q,J,K,N,S,P];function L(n){return`${n.ElementType}_${n.ElementCount}`}function W(n){return U.get(n)}const U=new Map;R.forEach(n=>U.set(L(n),n));export{u as G,Z as H,tt as I,f as e};
