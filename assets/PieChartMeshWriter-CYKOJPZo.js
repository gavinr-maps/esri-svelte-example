const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngineJSON-BwrklJA_.js","./geometryEngineBase-yFIvKOkM.js","./_commonjsHelpers-DCkdB7M8.js","./json-Wa8cmqdu.js"])))=>i.map(i=>d[i]);
import{C as h}from"./enums-D9v74xTE.js";import{u as y}from"./screenUtils-_ZIvrt5o.js";import{Z as Tt,A as Mt,s as Et,d as T,g as ue,j as le,k as he,O as pe}from"./CIMSymbolHelper-Vkq7AVTn.js";import{g as Rt,i as Ct,l as de}from"./GeometryUtils-B5FJlfZD.js";import{C as fe,q as Ot,B as Wt,K as et,L as zt,r as ut,e as $t,F as xe,H as me,a as lt,D as ye,E as _e,o as U}from"./UpdateTracking2D-BJv4lrAz.js";import{w as R,e as ht,G as pt,a as dt,n as it,i as Ut}from"./enums-BJSSbDkD.js";import{a as st,s as ct,t as v,R as ge,c as rt,i as Se,l as ke,G as Pe,A as ve}from"./definitions-LJaw2n5Z.js";import{M as be,s as we,B as Ht}from"./Accessor-BHnuXKD2.js";import{s as Te,r as At}from"./mathUtils-DV9iOXpW.js";import{a as Me,i as Ee,c as ze}from"./libtess-BP1QYsmS.js";import{r as $e,a as Xt}from"./utils-ilH32Koe.js";import{E as Vt}from"./utils-B91u8350.js";import"./earcut-Lltz9D9k.js";import{e as Ae}from"./OptimizedGeometry-7IxBWtHr.js";import{a as De,i as Ie,s as Le}from"./mat2d-D9DBP-jx.js";import{n as Ne}from"./mat2df32-orApM5a3.js";import{S as j}from"./vec2-maR1OrZI.js";import{e as J}from"./rasterizingUtils-5QTNbyfl.js";import{h as Be}from"./Color-gncXBiLc.js";import{V as Ye}from"./Polyline-BmuD2-ZN.js";import{_ as Ge}from"./index-tefRSezt.js";import{c as Fe,a as Re}from"./dataViewUtils-CH0QMRr9.js";function Ce(e,t,i,s,r,n,o){yt=0;const a=(s-i)*n,c=r&&r.length,u=c?(r[0]-i)*n:a;let l,p,x,f,d,m=Zt(t,i,s,0,u,n,!0);if(m&&m.next!==m.prev){if(c&&(m=He(t,i,s,r,m,n)),a>80*n){l=x=t[0+i*n],p=f=t[1+i*n];for(let _=n;_<u;_+=n){const k=t[_+i*n],P=t[_+1+i*n];l=Math.min(l,k),p=Math.min(p,P),x=Math.max(x,k),f=Math.max(f,P)}d=Math.max(x-l,f-p),d=d!==0?1/d:0}X(m,e,n,l,p,d,o,0)}}function Zt(e,t,i,s,r,n,o){let a;if(o===Qe(e,t,i,s,r,n)>0)for(let c=s;c<r;c+=n)a=Dt(c+t*n,e[c+t*n],e[c+1+t*n],a);else for(let c=r-n;c>=s;c-=n)a=Dt(c+t*n,e[c+t*n],e[c+1+t*n],a);return a&&L(a,a.next)&&(V(a),a=a.next),a}function H(e,t=e){if(!e)return e;let i,s=e;do if(i=!1,s.steiner||!L(s,s.next)&&S(s.prev,s,s.next)!==0)s=s.next;else{if(V(s),s=t=s.prev,s===s.next)break;i=!0}while(i||s!==t);return t}function X(e,t,i,s,r,n,o,a){if(!e)return;!a&&n&&(e=qt(e,s,r,n));let c=e;for(;e.prev!==e.next;){const u=e.prev,l=e.next;if(n?We(e,s,r,n):Oe(e))t.push(u.index/i+o),t.push(e.index/i+o),t.push(l.index/i+o),V(e),e=l.next,c=l.next;else if((e=l)===c){a?a===1?X(e=Je(e,t,i,o),t,i,s,r,n,o,2):a===2&&Ke(e,t,i,s,r,n,o):X(H(e),t,i,s,r,n,o,1);break}}}function Oe(e){const t=e.prev,i=e,s=e.next;if(S(t,i,s)>=0)return!1;let r=e.next.next;const n=r;let o=0;for(;r!==e.prev&&(o===0||r!==n);){if(o++,F(t.x,t.y,i.x,i.y,s.x,s.y,r.x,r.y)&&S(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function We(e,t,i,s){const r=e.prev,n=e,o=e.next;if(S(r,n,o)>=0)return!1;const a=r.x<n.x?r.x<o.x?r.x:o.x:n.x<o.x?n.x:o.x,c=r.y<n.y?r.y<o.y?r.y:o.y:n.y<o.y?n.y:o.y,u=r.x>n.x?r.x>o.x?r.x:o.x:n.x>o.x?n.x:o.x,l=r.y>n.y?r.y>o.y?r.y:o.y:n.y>o.y?n.y:o.y,p=xt(a,c,t,i,s),x=xt(u,l,t,i,s);let f=e.prevZ,d=e.nextZ;for(;f&&f.z>=p&&d&&d.z<=x;){if(f!==e.prev&&f!==e.next&&F(r.x,r.y,n.x,n.y,o.x,o.y,f.x,f.y)&&S(f.prev,f,f.next)>=0||(f=f.prevZ,d!==e.prev&&d!==e.next&&F(r.x,r.y,n.x,n.y,o.x,o.y,d.x,d.y)&&S(d.prev,d,d.next)>=0))return!1;d=d.nextZ}for(;f&&f.z>=p;){if(f!==e.prev&&f!==e.next&&F(r.x,r.y,n.x,n.y,o.x,o.y,f.x,f.y)&&S(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;d&&d.z<=x;){if(d!==e.prev&&d!==e.next&&F(r.x,r.y,n.x,n.y,o.x,o.y,d.x,d.y)&&S(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function Dt(e,t,i,s){const r=C.create(e,t,i);return s?(r.next=s.next,r.prev=s,s.next.prev=r,s.next=r):(r.prev=r,r.next=r),r}function V(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Ue(e){let t=e,i=e;do(t.x<i.x||t.x===i.x&&t.y<i.y)&&(i=t),t=t.next;while(t!==e);return i}function He(e,t,i,s,r,n){const o=new Array;for(let a=0,c=s.length;a<c;a++){const u=Zt(e,t,i,s[a]*n,a<c-1?s[a+1]*n:i*n,n,!1);u===u.next&&(u.steiner=!0),o.push(Ue(u))}o.sort(je);for(const a of o)r=Xe(a,r);return r}function Xe(e,t){const i=Ve(e,t);if(!i)return t;const s=jt(i,e);return H(s,s.next),H(i,i.next)}function Ve(e,t){let i=t;const s=e.x,r=e.y;let n,o=-1/0;do{if(r<=i.y&&r>=i.next.y&&i.next.y!==i.y){const x=i.x+(r-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(x<=s&&x>o){if(o=x,x===s){if(r===i.y)return i;if(r===i.next.y)return i.next}n=i.x<i.next.x?i:i.next}}i=i.next}while(i!==t);if(!n)return null;if(s===o)return n.prev;const a=n,c=n.x,u=n.y;let l,p=1/0;for(i=n.next;i!==a;)s>=i.x&&i.x>=c&&s!==i.x&&F(r<u?s:o,r,c,u,r<u?o:s,r,i.x,i.y)&&(l=Math.abs(r-i.y)/(s-i.x),(l<p||l===p&&i.x>n.x)&&Z(i,e)&&(n=i,p=l)),i=i.next;return n}function qt(e,t,i,s){let r;for(;r!==e;r=r.next){if(r=r||e,r.z===null&&(r.z=xt(r.x,r.y,t,i,s)),r.prev.next!==r||r.next.prev!==r)return r.prev.next=r,r.next.prev=r,qt(e,t,i,s);r.prevZ=r.prev,r.nextZ=r.next}return e.prevZ.nextZ=null,e.prevZ=null,Ze(e)}function Ze(e){let t,i=1;for(;;){let s,r=e;e=null,t=null;let n=0;for(;r;){n++,s=r;let o=0;for(;o<i&&s;o++)s=s.nextZ;let a=i;for(;o>0||a>0&&s;){let c;o===0?(c=s,s=s.nextZ,a--):a!==0&&s?r.z<=s.z?(c=r,r=r.nextZ,o--):(c=s,s=s.nextZ,a--):(c=r,r=r.nextZ,o--),t?t.nextZ=c:e=c,c.prevZ=t,t=c}r=s}if(t.nextZ=null,i*=2,n<2)return e}}function S(e,t,i){return(t.y-e.y)*(i.x-t.x)-(t.x-e.x)*(i.y-t.y)}function Qt(e,t,i,s){return!!(L(e,t)&&L(i,s)||L(e,s)&&L(i,t))||S(e,t,i)>0!=S(e,t,s)>0&&S(i,s,e)>0!=S(i,s,t)>0}function qe(e,t){let i=e;do{if(i.index!==e.index&&i.next.index!==e.index&&i.index!==t.index&&i.next.index!==t.index&&Qt(i,i.next,e,t))return!0;i=i.next}while(i!==e);return!1}function Qe(e,t,i,s,r,n){let o=0;for(let a=s,c=r-n;a<r;a+=n)o+=(e[c+t*n]-e[a+t*n])*(e[a+1+t*n]+e[c+1+t*n]),c=a;return o}function F(e,t,i,s,r,n,o,a){return(r-o)*(t-a)-(e-o)*(n-a)>=0&&(e-o)*(s-a)-(i-o)*(t-a)>=0&&(i-o)*(n-a)-(r-o)*(s-a)>=0}function Z(e,t){return S(e.prev,e,e.next)<0?S(e,t,e.next)>=0&&S(e,e.prev,t)>=0:S(e,t,e.prev)<0||S(e,e.next,t)<0}function xt(e,t,i,s,r){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*r)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*r)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function L(e,t){return e.x===t.x&&e.y===t.y}function je(e,t){return e.x-t.x}function Je(e,t,i,s){let r=e;do{const n=r.prev,o=r.next.next;!L(n,o)&&Qt(n,r,r.next,o)&&Z(n,o)&&Z(o,n)&&(t.push(n.index/i+s),t.push(r.index/i+s),t.push(o.index/i+s),V(r),V(r.next),r=e=o),r=r.next}while(r!==e);return r}function Ke(e,t,i,s,r,n,o){let a=e;do{let c=a.next.next;for(;c!==a.prev;){if(a.index!==c.index&&ti(a,c)){let u=jt(a,c);return a=H(a,a.next),u=H(u,u.next),X(a,t,i,s,r,n,o,0),void X(u,t,i,s,r,n,o,0)}c=c.next}a=a.next}while(a!==e)}function ti(e,t){return e.next.index!==t.index&&e.prev.index!==t.index&&!qe(e,t)&&Z(e,t)&&Z(t,e)&&ei(e,t)}function ei(e,t){let i=e,s=!1;const r=(e.x+t.x)/2,n=(e.y+t.y)/2;do i.y>n!=i.next.y>n&&i.next.y!==i.y&&r<(i.next.x-i.x)*(n-i.y)/(i.next.y-i.y)+i.x&&(s=!s),i=i.next;while(i!==e);return s}function jt(e,t){const i=C.create(e.index,e.x,e.y),s=C.create(t.index,t.x,t.y),r=e.next,n=t.prev;return e.next=t,t.prev=e,i.next=r,r.prev=i,s.next=i,i.prev=s,n.next=s,s.prev=n,s}class C{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,i,s){const r=yt<mt.length?mt[yt++]:new C;return r.index=t,r.x=i,r.y=s,r.prev=null,r.next=null,r.z=null,r.prevZ=null,r.nextZ=null,r.steiner=!1,r}}const mt=[],ii=8096;let yt=0;for(let e=0;e<ii;e++)mt.push(new C);const si=1e-5,D=new Rt(0,0,0,1,0),_t=new Rt(0,0,0,1,0);function It(e,t,i){let s=0;for(let r=1;r<i;r++){const n=e[2*(t+r-1)],o=e[2*(t+r-1)+1];s+=(e[2*(t+r)]-n)*(e[2*(t+r)+1]+o)}return s}function ri(e,t,i,s,r){let n=0;const o=2;for(let a=i;a<s;a+=3){const c=(e[a]-r)*o,u=(e[a+1]-r)*o,l=(e[a+2]-r)*o;n+=Math.abs((t[c]-t[l])*(t[u+1]-t[c+1])-(t[c]-t[u])*(t[l+1]-t[c+1]))}return n}function ni(e,t){const{coords:i,lengths:s}=t,r=0,n=e;let o=0;for(let a=0;a<s.length;){let c=a,u=s[a],l=It(i,o,u);const p=[];for(;++c<s.length;){const m=s[c],_=It(i,o+u,m);if(!(_>0))break;l+=_,p.push(o+u),u+=m}const x=n.length;Ce(n,i,o,o+u,p,2,r);const f=ri(n,i,x,n.length,r),d=Math.abs(l);if(Math.abs((f-d)/Math.max(1e-7,d))>si)return n.length=0,!1;a=c,o+=u}return!0}function oi(e){const{coords:t,lengths:i}=e,{buffer:s}=Me(t,i);return s}function ai(e,t,i){let s=0;for(let r=0;r<e.lengths.length;r++){const n=e.lengths[r];for(let o=0;o<n;o++){const a=e.coords[2*(o+s)],c=e.coords[2*(o+s)+1];if(a<t||a>i||c<t||c>i)return!0}s+=n}return!1}function Jt(e,t){if(e==null)return null;if(!ai(e,-128,st+128))return e;D.setPixelMargin(t),D.reset(Ct.Polygon);let i=0;for(let o=0;o<e.lengths.length;o++){const a=e.lengths[o];let c=e.coords[2*(0+i)],u=e.coords[2*(0+i)+1];D.moveTo(c,u);for(let l=1;l<a;l++)c=e.coords[2*(l+i)],u=e.coords[2*(l+i)+1],D.lineTo(c,u);D.close(),i+=a}const s=D.result(!1);if(!s)return null;const r=[],n=[];for(const o of s){let a=0;for(const c of o)n.push(c.x),n.push(c.y),a++;r.push(a)}return new Ae(r,n)}function ci(e,t){_t.setPixelMargin(t);const i=_t,s=-t,r=st+t;let n=[],o=!1;if(!e.nextPath())return null;let a=e.pathLength(),c=!0;for(;c;){e.seekPathStart();const u=[];if(!e.pathSize)return null;i.reset(Ct.LineString),e.nextPoint();let l=e.x,p=e.y;if(o)i.moveTo(l,p);else{if(l<s||l>r||p<s||p>r){o=!0;continue}u.push({x:l,y:p})}let x=!1;for(;e.nextPoint();)if(l=e.x,p=e.y,o)i.lineTo(l,p);else{if(l<s||l>r||p<s||p>r){x=!0;break}u.push({x:l,y:p})}if(x)o=!0;else{if(o){const f=i.resultWithStarts();if(f)for(const d of f)n.push({...d,pathLength:a})}else n.push({line:u,start:0,pathLength:a});c=e.nextPath(),a=c?e.pathLength():0,o=!1}}return n=n.filter(u=>u.line.length>1),n.length===0?null:n}D.setExtent(st),_t.setExtent(st);const ui=96/72;let li=class{static executeEffects(t,i,s,r,n){const o=ui,a=Tt(t);let c=new Et(i);for(const u of t){const l=Mt(u);l&&(c=l.execute(c,u,o,s,r,a,n))}return c}static applyEffects(t,i,s){if(!t)return i;const r=Tt(t);let n,o=new Et(T.fromJSONCIM(i));for(const u of t){const l=Mt(u);l&&(o=l.execute(o,u,1,null,s,r,!1))}const a=[];let c=null;for(;n=o.next();)a.push(...Ye(n)),c=n.geometryType;return a.length===0||c===null?null:c==="esriGeometryPolygon"?{rings:a}:{paths:a}}},Kt=null;function St(){return Kt}async function hi(){Kt=await Ge(()=>import("./geometryEngineJSON-BwrklJA_.js").then(e=>e.g),__vite__mapDeps([0,1,2,3]),import.meta.url)}function te(e){switch(e){case h.BYTE:case h.UNSIGNED_BYTE:return 1;case h.SHORT:case h.UNSIGNED_SHORT:case h.HALF_FLOAT:return 2;case h.FLOAT:case h.INT:case h.UNSIGNED_INT:return 4}}function pi(e){const t=[],i=[],s=[];for(const r of e){const n=te(r.type)*r.count;switch(n%2||n%4||4){case 4:t.push(r);continue;case 2:i.push(r);continue;case 1:s.push(r);continue;default:throw new Error("Found unexpected dataType byte count")}}return t.push(...i),t.push(...s),t}let di=class ee{static fromVertexSpec(t,i){const{attributes:s,optionalAttributes:r}=t;let n,o,a;const c=[];for(const m in s){const _=s[m];_.pack==="position"?n={..._,name:m,offset:0}:_.pack==="id"?o={..._,name:m,offset:4}:m==="bitset"?a={..._,name:m,offset:7}:c.push({..._,name:m})}for(const m in r)if(i[m]===!0){const _=r[m];c.push({..._,name:m})}const u=pi(c),l=[];let p=8,x=1;for(const m of u)l.push({...m,offset:p}),p+=te(m.type)*m.count,m.packAlternating&&(x=Math.max(m.packAlternating.count,x));const f=Uint32Array.BYTES_PER_ELEMENT,d=p%f;return new ee(n,o,a,l,p+(d?f-d:0),x)}constructor(t,i,s,r,n,o){this.position=t,this.id=i,this.bitset=s,this.standardAttributes=r,this.stride=n,this.packVertexCount=o,r.push(s),this._attributes=[t,i,s,...r]}get attributeLayout(){if(!this._attributeLayout){const t=$e(this._attributes),i=this._attributes.map(s=>({name:s.name,count:s.count,offset:s.offset,type:s.type,packPrecisionFactor:s.packPrecisionFactor,normalized:s.normalized??!1}));this._attributeLayout={attributes:i,hash:t,stride:this.stride}}return this._attributeLayout}},fi=class ie{static fromVertexSpec(t,i){const s=di.fromVertexSpec(t,i);return new ie(s)}constructor(t){this._spec=t,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(t,i,s,r,n,o){var a;for(let c=0;c<this._spec.packVertexCount;c++){const u=c*this._spec.stride;this._packPosition(s,r,u),this._packId(i,u);const l=this._spec.bitset;if(o){if(l.packTessellation){const p=l.packTessellation(o,n,s,r);this._pack(p,l,u)}for(const p of this._spec.standardAttributes)if(p.packTessellation!=null){const x=p.packTessellation(o,n,s,r);this._pack(x,p,u)}else if((a=p.packAlternating)!=null&&a.packTessellation){const x=p.packAlternating.packTessellation(o,n,s,r);for(let f=0;f<this._spec.packVertexCount;f++){const d=x[f];this._pack(d,p,f*this._spec.stride)}}}}t.vertexWriteRegion(this._packedU32View)}pack(t,i){var s;for(const r of this._spec.standardAttributes)if(r.pack&&typeof r.pack!="string"){const n=r.pack(t,i);for(let o=0;o<this._spec.packVertexCount;o++)this._pack(n,r,o*this._spec.stride)}else if((s=r.packAlternating)!=null&&s.pack){const n=r.packAlternating.pack(t,i);for(let o=0;o<this._spec.packVertexCount;o++){const a=n[o];this._pack(a,r,o*this._spec.stride)}}}_packPosition(t,i,s){const{offset:r}=this._spec.position,n=this._spec.position.packPrecisionFactor??1,o=Re(t*n,i*n);this._dataView.setUint32(s+r,o,!0)}_packId(t,i){const s=t*(this._spec.id.packPrecisionFactor??1),r=4278190080&this._dataView.getUint32(i+this._spec.id.offset,!0);this._dataView.setUint32(i+this._spec.id.offset,s|r,!0)}_pack(t,i,s){Fe(this._dataView,t,i,s)}};function xi(e){if(!e)return!1;for(const t of e)switch(t.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectOffset":case"CIMGeometricEffectDonut":return!0}return!1}let O=class{constructor(t,i,s,r){this._instanceId=t,this._evaluator=i,this._enabledOptionalAttributes=s,this._viewParams=r,this._evaluator.evaluator=n=>this.vertexSpec.createComputedParams(n)}get _vertexPack(){if(!this._cachedVertexPack){const t=fi.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){var t;xi((t=this._evaluator.inputMeshParams.effects)==null?void 0:t.effectInfos)&&await hi()}enqueueRequest(t,i,s){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,i,s)}write(t,i,s,r,n){var f;this.ensurePacked(i,s,r);const o=this.evaluatedMeshParams.effects;if(!o||o.length===0)return void this._write(t,s,void 0,n);const a=(f=s.readGeometryForDisplay())==null?void 0:f.clone();if(!a)return;const c=T.fromOptimizedCIM(a,s.geometryType),u=St();c.invertY();const l=t.id||"",p=li.executeEffects(o,c,l,u,this._preventEffectClipping);let x;for(;x=p.next();)x.invertY(),this._write(t,s,x,n)}ensurePacked(t,i,s){if(!this._evaluator.hasDynamicProperties)return;const r=this._evaluator.evaluateMeshParams(t,i,s);this._vertexPack.pack(r,this._viewParams)}hasArcadeDependency(t){return this._evaluator.hasArcadeDependency(t)}_writeVertex(t,i,s,r,n){const o=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,i,s,r,o,n)}};const mi=100,yi=be("featurelayer-fast-triangulation-enabled");let kt=class extends O{async loadDependencies(){await Promise.all([super.loadDependencies(),Ee()])}_write(t,i,s){const r=(s==null?void 0:s.asOptimized())??i.readGeometryForDisplay(),n=this._clip(r);n&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,i,n),t.recordEnd())}_clip(t){if(!t)return null;const i=this.hasEffects;return Jt(t,i?256:8)}_writeGeometry(t,i,s){const r=s.maxLength>mi,n=[],o=this.createTesselationParams(i);if(!r&&yi&&ni(n,s))return void(n.length&&this._writeVertices(t,i,s.coords,o,n));const a=oi(s);this._writeVertices(t,i,a,o)}_writeVertices(t,i,s,r,n){const o=i.getDisplayId(),a=t.vertexCount(),c=this.hasEffects;let u=0;if(n)for(const l of n){const p=s[2*l],x=s[2*l+1];c&&t.recordBounds(p,x,0,0),this._writeVertex(t,o,p,x,r),u++}else for(let l=0;l<s.length;l+=2){const p=Math.round(s[l]),x=Math.round(s[l+1]);c&&t.recordBounds(p,x,0,0),this._writeVertex(t,o,p,x,r),u++}t.indexEnsureSize(u);for(let l=0;l<u;l++)t.indexWrite(l+a)}};const _i={createComputedParams:e=>e,optionalAttributes:{},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:h.FLOAT,count:1,packTessellation:({inverseArea:e})=>e}}};let Ds=class extends kt{constructor(){super(...arguments),this.vertexSpec=_i}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}};const gi=()=>Ht.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),Si=0,ki=100;function Q(e,t){return[!!(e!=null&&e.minScale)&&t.scaleToZoom(e.minScale)||Si,!!(e!=null&&e.maxScale)&&t.scaleToZoom(e.maxScale)||ki]}function I(e){return 1<<e}function W(e){let t=0;for(const[i,s]of e)s&&(t|=1<<i);return t}function g(e){let t;if(!e)return[0,0,0,0];if(typeof e=="string"){const o=Be.fromString(e);if(!o)return gi().errorOnce(new we("mapview:mesh-processing","Unable to parse string into color",{color:e})),[0,0,0,0];t=o.toArray()}else t=e;const[i,s,r,n]=t;return[i*(n/255),s*(n/255),r*(n/255),n]}function Pi(e){switch(e){case"butt":case R.Butt:return ht.BUTT;case"round":case R.Round:return ht.ROUND;case"square":case R.Square:return ht.SQUARE}}function vi(e){switch(e){case"bevel":case pt.Bevel:return dt.BEVEL;case"miter":case pt.Miter:return dt.MITER;case"round":case pt.Round:return dt.ROUND}}function ft(e,t){return Math.round(Math.min(Math.sqrt(e*t),255))}function K(e,t){return Math.round(e*t)/t}const q={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:ct,pack:({scaleInfo:e},{tileInfo:t})=>Q(e,t)}},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>g(e)}}};let se=class extends kt{constructor(){super(...arguments),this.vertexSpec=q}createTesselationParams(t){return null}};const N={createComputedParams:e=>e,optionalAttributes:q.optionalAttributes,attributes:{...q.attributes,tlbr:{count:4,type:h.UNSIGNED_SHORT,pack:({sprite:e})=>{const{rect:t,width:i,height:s}=e,r=t.x+v,n=t.y+v;return[r,n,r+i,n+s]}},inverseRasterizationScale:{count:1,type:h.BYTE,packPrecisionFactor:16,pack:({sprite:e})=>1/e.rasterizationScale}}};let bi=class extends se{constructor(){super(...arguments),this.vertexSpec=N}_write(t,i,s){var a;const r=(s==null?void 0:s.asOptimized())??i.readGeometryForDisplay(),n=this._clip(r);if(!n)return;const o=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,i,n),t.recordEnd()}};function nt(e){const{sprite:t,aspectRatio:i,scaleProportionally:s}=e,r=y(e.height),n=r>0?r:t.height;let o=r*i;return o<=0?o=t.width:s&&(o*=t.width/t.height),{width:o,height:n}}function re(e){const{applyRandomOffset:t,sampleAlphaOnly:i}=e;return W([[fe,t],[Ot,i]])}const ne={createComputedParams:e=>e,optionalAttributes:N.optionalAttributes,attributes:{...N.attributes,bitset:{count:1,type:h.UNSIGNED_BYTE,pack:re},width:{count:1,type:h.HALF_FLOAT,pack:e=>nt(e).width},height:{count:1,type:h.HALF_FLOAT,pack:e=>nt(e).height},offset:{count:2,type:h.HALF_FLOAT,pack:({offsetX:e,offsetY:t})=>[y(e),-y(t)]},scale:{count:2,type:h.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:e,scaleY:t})=>[e,t]},angle:{count:1,type:h.UNSIGNED_BYTE,pack:({angle:e})=>de(e)}}};let Bs=class extends bi{constructor(){super(...arguments),this.vertexSpec=ne}},wi=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0}};const E={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:ct,pack:({scaleInfo:e},{tileInfo:t})=>Q(e,t)}},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:h.UNSIGNED_BYTE,count:1},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>g(e)},offset:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:e,extrusionOffsetY:t})=>[K(e,16),K(t,16)]},normal:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:e,normalY:t})=>[K(e,16),K(t,16)]},halfWidth:{type:h.HALF_FLOAT,count:1,pack:({width:e})=>y(.5*e)},referenceHalfWidth:{type:h.HALF_FLOAT,count:1,pack:({referenceWidth:e})=>y(.5*e)}}};let Ti=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const Lt=65535;let Pt=class extends O{constructor(t,i,s,r){super(t,i,s,r),this.vertexSpec=E,this._currentWrite=new Ti,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Lt,textured:!1},this._tessParams=new wi,this._initializeTessellator()}writeLineVertices(t,i,s){const r=this._getLines(i);r!=null&&this._writeVertices(t,s,r)}_initializeTessellator(){this._lineTessellator=new ze(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,i,s){const r=s??T.fromFeatureSetReaderCIM(i);r&&this._writeGeometry(t,i,r)}_writeGeometry(t,i,s,r){t.recordStart(this.instanceId,this.attributeLayout,r),this.writeLineVertices(t,s,i),t.recordEnd()}_getLines(t){return ci(t,Xt(this.evaluatedMeshParams))}_writeVertices(t,i,s){const{_currentWrite:r,_tessellationOptions:n,evaluatedMeshParams:o}=this,{width:a,capType:c,joinType:u,miterLimit:l,hasSizeVV:p}=o,x=y(.5*a);n.halfWidth=x,n.capType=Pi(c),n.joinType=vi(u),n.miterLimit=l;const f=!p;r.out=t,r.id=i.getDisplayId(),r.vertexCount=0,r.indexCount=0,r.vertexFrom=t.vertexCount(),r.vertexBounds=f&&x<ge?0:1;for(const{line:d,start:m,pathLength:_}of s)n.initialDistance=m%Lt,r.pathLength=_,this._lineTessellator.tessellate(d,n,f)}_writeTesselatedVertex(t,i,s,r,n,o,a,c,u,l,p){const{out:x,id:f,vertexBounds:d,pathLength:m}=this._currentWrite;return this.hasEffects&&x.recordBounds(t,i,d,d),this._tessParams.extrusionOffsetX=a,this._tessParams.extrusionOffsetY=c,this._tessParams.normalX=u,this._tessParams.normalY=l,this._tessParams.directionX=n,this._tessParams.directionY=o,this._tessParams.distance=p,this._tessParams.pathLength=m,this._writeVertex(x,f,t,i,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,i,s){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(t),r.indexWrite(i),r.indexWrite(s),this._currentWrite.indexCount+=3}};const oe={createComputedParams:e=>e,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:e=>0},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>g(e)}}},vt={createComputedParams:e=>e,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:e=>W([[Wt,!0]])},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>g(e)}}};let bt=class extends Pt{constructor(){super(...arguments),this.vertexSpec=vt}},ae=class extends se{constructor(t,i,s,r){super(t,i,s,r),this.vertexSpec=oe,this._lineMeshWriter=this._createOutlineWriter(t,i,s,r)}_createOutlineWriter(t,i,s,r){return new bt(t,i,s,r)}_write(t,i,s){const r=(s==null?void 0:s.asOptimized())??i.readGeometryForDisplay(),n=this._clip(r);n&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,i,n),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(n,"esriGeometryPolyline"),i),t.recordEnd())}_clip(t){return t?Jt(t,Xt(this.evaluatedMeshParams)):null}ensurePacked(t,i,s){super.ensurePacked(t,i,s),this._lineMeshWriter.ensurePacked(t,i,s)}enqueueRequest(t,i,s){super.enqueueRequest(t,i,s),this._lineMeshWriter.enqueueRequest(t,i,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const ot=ne,Mi=vt,Ei={createComputedParams:e=>e,optionalAttributes:ot.optionalAttributes,attributes:{...ot.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:e=>re(e)},aux1:{count:1,type:h.HALF_FLOAT,pack:e=>nt(e).width},aux2:{count:1,type:h.HALF_FLOAT,pack:e=>nt(e).height},aux3:{count:2,type:h.HALF_FLOAT,pack:({offsetX:e,offsetY:t})=>[y(e),y(t)]},aux4:{count:2,type:h.UNSIGNED_BYTE,pack:({scaleX:e,scaleY:t})=>[e*et,t*et]}}},zi={createComputedParams:e=>e,optionalAttributes:ot.optionalAttributes,attributes:{...ot.attributes,color:Mi.attributes.color,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:e=>W([[Wt,!0]])},aux1:{count:1,type:h.HALF_FLOAT,pack:e=>y(.5*e.width)},aux2:{count:1,type:h.HALF_FLOAT,pack:e=>y(.5*e.referenceWidth)},aux3:{count:2,type:h.HALF_FLOAT,packTessellation:({extrusionOffsetX:e,extrusionOffsetY:t})=>[e,t]},aux4:{count:2,type:h.UNSIGNED_BYTE,packTessellation:({normalX:e,normalY:t})=>[e*et+zt,t*et+zt]}}};let $i=class extends bt{constructor(){super(...arguments),this.vertexSpec=zi}},Us=class extends ae{constructor(){super(...arguments),this.vertexSpec=Ei}_createOutlineWriter(t,i,s,r){return new $i(t,i,s,r)}_write(t,i,s){var a;const r=(s==null?void 0:s.asOptimized())??i.readGeometryForDisplay(),n=this._clip(r);if(!n)return;const o=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,i,n),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(n,"esriGeometryPolyline"),i),t.recordEnd()}ensurePacked(t,i,s){super.ensurePacked(t,i,s),this._lineMeshWriter.ensurePacked(t,i,s)}enqueueRequest(t,i,s){super.enqueueRequest(t,i,s),this._lineMeshWriter.enqueueRequest(t,i,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const Ai=()=>Ht.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");let Di=class{constructor(t,i){this._size=t,this._sizeUnits=i,this._relativeSize=null}get relativeSize(){return this._relativeSize??(this._relativeSize=this.calculateRelativeSize()),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===it.Relative){const t=Math.min(this._size/100,1);return[t,t]}return this.calculateRelativeSizeFromAbsolute()}},wt=class extends Di{constructor(t,i,s,r){super(i,s),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(r),this.rotationMatrix01=-Math.sin(r),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:n,rotationMatrix00:o,rotationMatrix01:a,rotationMatrix10:c,rotationMatrix11:u}=this;t.forEachVertex((l,p)=>{const x=l*o+p*a,f=l*c+p*u;n.xmin=Math.min(n.xmin,x),n.ymin=Math.min(n.ymin,f),n.xmax=Math.max(n.xmax,x),n.ymax=Math.max(n.ymax,f)}),this.center=[(n.xmin+n.xmax)/2,(n.ymin+n.ymax)/2]}},Ii=class extends wt{constructor(t,i,s,r){super(t,i,s,r),this.method="linear"}getRelativePosition(t,i){const{rotationMatrix00:s,rotationMatrix01:r,bounds:n}=this,{xmin:o,xmax:a}=n;return[(t*s+i*r-o)/(a-o),0]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:i}=this,{xmin:s,xmax:r}=i;return[y(t)/(r-s),0]}},Li=class extends wt{constructor(t,i,s,r){super(t,i,s,r),this.method="rectangular"}getRelativePosition(t,i){const{bounds:s,center:r,rotationMatrix00:n,rotationMatrix01:o,rotationMatrix10:a,rotationMatrix11:c}=this,u=t*a+i*c,l=t*n+i*o-r[0],p=u-r[1];return[l*(2/(s.xmax-s.xmin)),-p*(2/(s.ymax-s.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:i}=this,{xmin:s,ymin:r,xmax:n,ymax:o}=i;return[y(2*t)/(n-s),y(2*t)/(o-r)]}};class Ni extends wt{constructor(t,i,s){super(t,i,s,0),this.method="circular";const{xmin:r,xmax:n,ymin:o,ymax:a}=this.bounds,c=n-r,u=a-o;this.radius=Math.sqrt(c*c+u*u)/2}getRelativePosition(t,i){const{center:s,radius:r}=this;return[(t-s[0])/r,-((i-s[1])/r)]}calculateRelativeSizeFromAbsolute(){const{_size:t}=this;return[y(t)/this.radius,0]}}function Bi(e,t){if(e==null)return null;const i=Te(t.angle),s=t.gradientSize,r=t.gradientSizeUnits;switch(t.gradientMethod.toLowerCase()){case"linear":return new Ii(e,s,r,i);case"rectangular":return new Li(e,s,r,i);case"circular":return new Ni(e,s,r);default:return Ai().errorOnce(`Gradient fill method "${t.gradientMethod}" currently unsupported.`),null}}const Yi={createComputedParams:e=>e,optionalAttributes:q.optionalAttributes,attributes:{...q.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:e,gradientType:t})=>{let i=0;return e===it.Absolute&&(i|=I($t.isAbsolute)),t.toLowerCase()==="discrete"&&(i|=I($t.isDiscrete)),i}},tlbr:{count:4,type:h.UNSIGNED_SHORT,pack:({sprite:e})=>{const{rect:t,width:i,height:s}=e,r=t.x+v+rt,n=t.y+v;return[r,n,r+i-2*rt,n+s]}},relativePosition:{count:2,type:h.HALF_FLOAT,packTessellation:({gradientStats:e},t,i,s)=>(e==null?void 0:e.getRelativePosition(i,s))??[0,0]},relativeGradientSize:{count:2,type:h.HALF_FLOAT,packTessellation:({gradientStats:e})=>(e==null?void 0:e.relativeSize)??[1,1]},gradientMethod:{count:1,type:h.UNSIGNED_BYTE,pack:({gradientMethod:e})=>{switch(e.toLowerCase()){case"rectangular":return ut.rectangular;case"circular":return ut.circular;default:return ut.linear}}}}};let Qs=class extends kt{constructor(){super(...arguments),this.vertexSpec=Yi}get _preventEffectClipping(){return!0}createTesselationParams(t){return{gradientStats:Bi(t.readGeometryForDisplay(),this.evaluatedMeshParams)}}_write(t,i,s){var a;const r=(s==null?void 0:s.asOptimized())??i.readGeometryForDisplay(),n=this._clip(r);if(!n)return;const o=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,i,n),t.recordEnd()}};const Gi={optionalAttributes:N.optionalAttributes,createComputedParams:e=>e,attributes:{...N.attributes,...oe.attributes}},Fi={optionalAttributes:N.optionalAttributes,createComputedParams:e=>e,attributes:{...N.attributes,...vt.attributes}};class Ri extends bt{constructor(){super(...arguments),this.vertexSpec=Fi}}class Js extends ae{constructor(){super(...arguments),this.vertexSpec=Gi}_createOutlineWriter(t,i,s,r){return new Ri(t,i,s,r)}_write(t,i,s){var a;const r=(s==null?void 0:s.asOptimized())??i.readGeometryForDisplay(),n=this._clip(r);if(!n)return;const o=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(t,i,n),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(n,"esriGeometryPolyline"),i),t.recordEnd()}ensurePacked(t,i,s){super.ensurePacked(t,i,s),this._lineMeshWriter.ensurePacked(t,i,s)}enqueueRequest(t,i,s){super.enqueueRequest(t,i,s),this._lineMeshWriter.enqueueRequest(t,i,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const Ci={createComputedParams:e=>e,optionalAttributes:{},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},offset:{type:h.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let Ks=class extends O{constructor(){super(...arguments),this.vertexSpec=Ci}_write(t,i){t.recordStart(this.instanceId,this.attributeLayout);const s=i.getDisplayId();if(i.geometryType==="esriGeometryPoint"){const r=i.readXForDisplay(),n=i.readYForDisplay();this._writeQuad(t,s,r,n)}else if(i.geometryType==="esriGeometryMultipoint"){const r=i.readGeometryForDisplay();r==null||r.forEachVertex((n,o)=>{n>=0&&n<=512&&o>=0&&o<=512&&this._writeQuad(t,s,n,o)})}t.recordEnd()}_writeQuad(t,i,s,r){const n=t.vertexCount();this._writeVertex(t,i,s,r),t.indexWrite(n+0),t.indexWrite(n+1),t.indexWrite(n+2),t.indexWrite(n+1),t.indexWrite(n+3),t.indexWrite(n+2)}};class ce{static getPlacement(t,i,s,r,n,o){const a=ue(s);return a?(i===-1&&t.invertY(),a.execute(t,s,r,n,o)):null}}const Nt=96;class Oi{constructor(t){const{offsetX:i,offsetY:s,postAngle:r,fontSize:n,haloSize:o,outlineSize:a,scaleFactor:c,transforms:u}=t;if(this.offsetX=i,this.offsetY=s,this.postAngle=r,this.fontSize=Math.min(n,Nt),this.haloSize=o??0,this.outlineSize=a??0,this.transforms=u,u&&u.infos.length>1){const l=Vt(n,r,!1,i,s,u,!1);this.fontSize=Math.min(l.size,Nt);const p=l.size/n;this.haloSize*=p,this.outlineSize*=p,this.postAngle=l.rotation,this.offsetX=l.offsetX,this.offsetY=l.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const Wi=28,$=[4,4],tt=[16,4],Ui={topLeft:tt,topRight:tt,bottomLeft:tt,bottomRight:tt},at=[4,2],b=[4,6],Bt={topLeft:at,topRight:at,bottomLeft:b,bottomRight:b},Yt={topLeft:at,topRight:b,bottomLeft:at,bottomRight:b},Hi={topLeft:b,topRight:b,bottomLeft:$,bottomRight:$},Xi={topLeft:$,topRight:$,bottomLeft:b,bottomRight:b},Vi={topLeft:b,topRight:$,bottomLeft:b,bottomRight:$},Zi={topLeft:$,topRight:b,bottomLeft:$,bottomRight:b},qi={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:h.UNSIGNED_SHORT,count:2,packPrecisionFactor:ct,packTessellation:({minZoom:e,maxZoom:t})=>[e||0,t||Wi]},clipAngle:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:e})=>Qi(e||0)},referenceSymbol:{type:h.BYTE,count:4,packPrecisionFactor:1,packTessellation:(e,t)=>{const i=e.isLineLabel||!e.referenceBounds,s=le(i?"center":t.horizontalAlignment),r=he(i?"middle":t.verticalAlignment),{offsetX:n,offsetY:o,size:a}=i?{offsetX:0,offsetY:0,size:0}:e.referenceBounds;return[y(n),-y(o),Math.round(y(a)),s+1<<2|r+1]}}},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:e,mapAligned:t})=>W([[xe,e],[me,!!t]])},offset:{type:h.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:e})=>{const{bottomLeft:t,bottomRight:i,topLeft:s,topRight:r}=e;return[s,r,t,i]}}},textureUV:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:e})=>{const{bottomLeft:t,bottomRight:i,topLeft:s,topRight:r}=e;return[s,r,t,i]}}},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:e})=>e},fontSize:{type:h.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:e})=>Math.round(y(e))},referenceSize:{type:h.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:e},{referenceSize:t})=>Math.round(y(t??e))},outlineColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>g(e)},haloColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:e})=>g(e)},outlineAndHaloSize:{type:h.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:e,haloSize:t})=>[Math.round(y(e)),Math.round(y(t))]}}};class er extends O{constructor(){super(...arguments),this.vertexSpec=qi,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,i,s){super.ensurePacked(t,i,s),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new Oi(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,i,s){const r=this._getShaping();if(!r)return;const n=i.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(t,i,r,s);if(s!=null&&s.nextPath())return s.nextPoint(),this._writeGlyphs(t,n,s.x,s.y,r,0);if(i.geometryType==="esriGeometryPolygon"){const c=i.readCentroidForDisplay();if(!c)return;const[u,l]=c.coords;return this._writeGlyphs(t,n,u,l,r,0)}if(i.geometryType==="esriGeometryMultipoint"){const c=i.readGeometryForDisplay();return void(c==null?void 0:c.forEachVertex((u,l)=>this._writeGlyphs(t,n,u,l,r,0)))}const o=i.readXForDisplay(),a=i.readYForDisplay();return this._writeGlyphs(t,n,o,a,r,0)}_writePlacedTextMarkers(t,i,s,r){const n=r??T.fromFeatureSetReaderCIM(i);if(!n)return;const o=-1,a=ce.getPlacement(n,o,this.evaluatedMeshParams.placement,y(1),t.id,St());if(!a)return;const c=i.getDisplayId();let u=a.next();for(;u!=null;){const l=u.tx,p=-u.ty,x=-u.getAngle();this._writeGlyphs(t,c,l,p,s,x),u=a.next()}}_getShaping(t){var u;const i=this._textMeshTransformProps,s=this.evaluatedMeshParams;if(!((u=s.glyphs)!=null&&u.glyphs.length))return null;const r=y(i.fontSize),n=y(i.offsetX),o=y(i.offsetY),a=At(y(s.lineWidth),ke,Se),c=Pe*At(s.lineHeightRatio,.25,4);return pe(s.glyphs,{scale:r/ve,angle:i.postAngle,xOffset:n,yOffset:o,horizontalAlignment:s.horizontalAlignment,verticalAlignment:t||s.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:s.decoration,borderLineSizePx:y(s.boxBorderLineSize),hasBackground:!!s.boxBackgroundColor,useCIMAngleBehavior:s.useCIMAngleBehavior})}_writeGlyphs(t,i,s,r,n,o,a,c){const u=this.evaluatedMeshParams,l=this._textMeshTransformProps,p=y(l.fontSize),x=l.haloSize,f=l.outlineSize,d=y(l.offsetX),m=y(l.offsetY),[_,k]=Q(u.scaleInfo,this.getTileInfo());o!==0&&n.setRotation(o);const P=n.bounds,A=s+P.x+d,M=r+P.y-m,B=2*(u.minPixelBuffer?u.minPixelBuffer/p:1),w=Math.max(P.width,P.height)*B;n.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding),t.recordBounds(A,M,w,w),this._writeTextBox(t,i,s,r,n.textBox,a,c),t.recordEnd());for(const z of n.glyphs){t.recordStart(this.instanceId,this.attributeLayout,z.textureBinding),t.recordBounds(A,M,w,w);const{texcoords:Y,offsets:G}=z;this._writeQuad(t,i,s,r,{texcoords:Y,offsets:G,fontSize:p,haloSize:x,outlineSize:f,color:g(u.color),isBackground:!1,referenceBounds:a,minZoom:_,maxZoom:k,...c}),t.recordEnd()}o!==0&&n.setRotation(-o)}_writeTextBox(t,i,s,r,n,o,a){const c=this.evaluatedMeshParams,{fontSize:u,haloSize:l,outlineSize:p}=this._textMeshTransformProps,{boxBackgroundColor:x,boxBorderLineColor:f}=c,d={isBackground:!0,fontSize:u,haloSize:l,outlineSize:p,referenceBounds:o,...a};x&&(this._writeQuad(t,i,s,r,{texcoords:Ui,offsets:n.main,color:g(x),...d}),f||(this._writeQuad(t,i,s,r,{texcoords:Hi,offsets:n.top,color:g(x),...d}),this._writeQuad(t,i,s,r,{texcoords:Xi,offsets:n.bot,color:g(x),...d}),this._writeQuad(t,i,s,r,{texcoords:Vi,offsets:n.left,color:g(x),...d}),this._writeQuad(t,i,s,r,{texcoords:Zi,offsets:n.right,color:g(x),...d}))),f&&(this._writeQuad(t,i,s,r,{texcoords:Bt,offsets:n.top,color:g(f),...d}),this._writeQuad(t,i,s,r,{texcoords:Bt,offsets:n.bot,color:g(f),...d}),this._writeQuad(t,i,s,r,{texcoords:Yt,offsets:n.left,color:g(f),...d}),this._writeQuad(t,i,s,r,{texcoords:Yt,offsets:n.right,color:g(f),...d}))}_writeQuad(t,i,s,r,n){const o=t.vertexCount();this._writeVertex(t,i,s,r,n),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const Qi=e=>Math.round(e*(254/360)),ji={createComputedParams:e=>e,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({gradientMethod:e,gradientSizeUnits:t,gradientType:i})=>W([[lt.isAlongLine,e.toLowerCase()==="alongline"],[lt.isAbsoluteSize,t===it.Absolute],[lt.isDiscrete,i.toLowerCase()==="discrete"]])},tlbr:{type:h.UNSIGNED_SHORT,count:4,pack:({sprite:e})=>{const{rect:t,width:i,height:s}=e,r=t.x+v+rt,n=t.y+v;return[r,n,r+i-2*rt,n+s]}},accumulatedDistance:{type:h.UNSIGNED_SHORT,count:1,packTessellation:({distance:e})=>e},gradientSize:{type:h.HALF_FLOAT,count:1,pack:({gradientSize:e,gradientSizeUnits:t})=>t===it.Relative?e/100:y(e)},totalLength:{type:h.HALF_FLOAT,count:1,packTessellation:({pathLength:e})=>e},segmentDirection:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:e,directionY:t})=>[e,t]}}};let ir=class extends Pt{get _preventEffectClipping(){return!0}constructor(t,i,s,r){super(t,i,s,r),this.vertexSpec=ji,this._tessellationOptions.textured=!0}_write(t,i,s){const r=s??T.fromFeatureSetReaderCIM(i);if(!r)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(t,i,r,n==null?void 0:n.textureBinding)}};const Ji={createComputedParams:e=>e,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:e,shouldScaleDash:t,isSDF:i})=>W([[Ot,e],[ye,t],[_e,i]])},tlbr:{type:h.UNSIGNED_SHORT,count:4,pack:({sprite:e})=>{const{rect:t,width:i,height:s}=e,r=t.x+v,n=t.y+v;return[r,n,r+i,n+s]}},accumulatedDistance:{type:h.UNSIGNED_SHORT,count:1,packTessellation:({distance:e})=>e},segmentDirection:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:e,directionY:t})=>[e,t]},offsetAlongLine:{type:h.HALF_FLOAT,count:1,pack:({offsetAlongLine:e})=>y(e)},capType:{type:h.UNSIGNED_BYTE,count:1,pack:({capType:e})=>{switch(e){case R.Butt:case"butt":return 0;case R.Square:case"square":return 1;case R.Round:case"round":return 2;default:return 0}}}}};class rr extends Pt{constructor(t,i,s,r){super(t,i,s,r),this.vertexSpec=Ji,this._tessellationOptions.textured=!0}_write(t,i,s){const r=s??T.fromFeatureSetReaderCIM(i);if(!r)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(t,i,r,n==null?void 0:n.textureBinding)}}let Ki=class gt{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const i=new gt(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:s,width:r,height:n,angle:o,alignment:a,outlineSize:c,referenceSize:u,sprite:l,overrideOutlineColor:p}=t;return i.rawWidth=y(r),i.rawHeight=y(n),i.angle=o,i.alignment=a,i.outlineSize=y(c),i.referenceSize=y(u),i.overrideOutlineColor=p,i.offsetX=y(t.offsetX),i.offsetY=y(t.offsetY),s!=="simple"||l.sdf||(i.rawWidth=l.width,i.rawHeight=l.height),i._computeSize(t,!1),i}static fromComplexMeshParams(t){const i=new gt(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:s,transforms:r,size:n,scaleX:o,anchorX:a,anchorY:c,angle:u,colorLocked:l,frameHeight:p,widthRatio:x,offsetX:f,offsetY:d,outlineSize:m,referenceSize:_,scaleFactor:k,sizeRatio:P,isAbsoluteAnchorPoint:A,rotateClockwise:M,scaleSymbolsProportionally:B,sprite:w}=t;if(r&&r.infos.length>0){const G=Vt(n,u,M,f,d,r);n=G.size,u=G.rotation,f=G.offsetX,d=G.offsetY,M=!1}k&&(n*=k,f*=k,d*=k);const z=o*(w.width/w.height);i.alignment=s,i.rawHeight=y(n),i.rawWidth=i.rawHeight*z,i.referenceSize=y(_),i.sizeRatio=P,i.sdfDecodeCoeff=(w.sdfDecodeCoeff??1)*P,i.angle=u,i.rotateClockwise=M,i.anchorX=a,i.anchorY=c,i.offsetX=y(f),i.offsetY=y(d),A&&n&&(w.sdf?i.anchorX=a/(n*x):i.anchorX=a/(n*z),i.anchorY=c/n);const Y=B&&p?n/p:1;return i.outlineSize=m===0||isNaN(m)?0:y(m)*Y,i.scaleSymbolsProportionally=B,i.colorLocked=l,i._computeSize(t,!0),i}constructor(t,i,s,r,n,o,a){this.sprite=t,this.color=i,this.outlineColor=s,this.minPixelBuffer=r,this.placement=n,this.scaleInfo=o,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=Ut.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,i){const{sprite:s,hasSizeVV:r}=t,n=!!s.sdf,o=s.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:u,outlineSize:l}=this,p=s.rect;let x=a*u,f=c*u,d=0,m=0;if(n){const M=1/(1-o);if(x*=M,f*=M,r)this.computedWidth=x,this.computedHeight=f;else{const B=i&&a>c?x:a,w=c,z=l+2*1;this.computedWidth=Math.min(B+z,x),this.computedHeight=Math.min(w+z,f);const Y=Math.max(s.width,s.height)/Math.max(x,f);d=(this.computedWidth-x)*Y,m=(this.computedHeight-f)*Y}}else this.computedWidth=x*(p.width/s.width),this.computedHeight=f*(p.height/s.height),d=2*v,m=2*v;const _=p.x+v-d/2,k=p.y+v-m/2,P=_+s.width+d,A=k+s.height+m;this.texXmin=Gt(_),this.texYmin=Gt(k),this.texXmax=Ft(P),this.texYmax=Ft(A),this.computedWidth*=(this.texXmax-this.texXmin)/(P-_),this.computedHeight*=(this.texYmax-this.texYmin)/(A-k),this.anchorX*=x/this.computedWidth,this.anchorY*=f/this.computedHeight}};function Gt(e,t=1e-7){const i=Math.ceil(e);return i-e<t?i:Math.floor(e)}function Ft(e,t=1e-7){const i=Math.floor(e);return e-i<t?i:Math.ceil(e)}const ts=3.14159265359/180,es=128/Math.PI;function is(e,t){return e%=t,Math.abs(e>=0?e:e+t)}function ss(e){return is(e*es,256)}function rs(e,t,i,s,r=!1){const n=Ne(),o=r?1:-1;return De(n),(t||i)&&Ie(n,n,[t,-i]),s&&Le(n,n,o*ts*-s),n}const ns={createComputedParams:e=>Ki.from(e),optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:ct,pack:({scaleInfo:e},{tileInfo:t})=>Q(e,t)}},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({sprite:e,alignment:t,scaleSymbolsProportionally:i,overrideOutlineColor:s,colorLocked:r})=>{let n=0;return e.sdf&&(n|=I(U.bitset.isSDF)),t===Ut.MAP&&(n|=I(U.bitset.isMapAligned)),i&&(n|=I(U.bitset.scaleSymbolsProportionally)),s&&(n|=I(U.bitset.overrideOutlineColor)),r&&(n|=I(U.bitset.colorLocked)),n}},offset:{type:h.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:e,computedWidth:t,computedHeight:i,anchorX:s,anchorY:r,offsetX:n,offsetY:o,rotateClockwise:a})=>{const c=rs(0,n,o,-e,a),u=-(.5+s)*t,l=-(.5-r)*i,p=[u,l],x=[u+t,l],f=[u,l+i],d=[u+t,l+i];return j(p,p,c),j(x,x,c),j(f,f,c),j(d,d,c),[p,x,f,d]}}},textureUV:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:e,texXmin:t,texYmax:i,texYmin:s})=>[[t,s],[e,s],[t,i],[e,i]]}},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>g(e)},outlineColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>g(e)},sizing:{type:h.UNSIGNED_BYTE,count:4,pack:({rawWidth:e,rawHeight:t,outlineSize:i,referenceSize:s})=>{const r=Math.max(e,t);return[ft(r,128),ft(i,128),ft(s,128),0]}},placementAngle:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:e})=>ss(e)},sdfDecodeCoeff:{type:h.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:e})=>e}}};class nr extends O{constructor(){super(...arguments),this.vertexSpec=ns}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(t,i,s){var f;const r=(f=this.evaluatedMeshParams.sprite)==null?void 0:f.textureBinding,n=i.getDisplayId();t.recordStart(this.instanceId,this.attributeLayout,r);const o=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,o),c=Math.max(this.evaluatedMeshParams.computedHeight,o),u=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,l=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,p=this.evaluatedMeshParams.offsetX+u,x=-this.evaluatedMeshParams.offsetY+l;if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(t,i,s,a,c);else if(s!=null&&s.nextPath()){s.nextPoint();const d=s.x,m=s.y;t.recordBounds(d+p,m+x,a,c),this._writeQuad(t,n,d,m)}else if(i.geometryType==="esriGeometryPolygon"){const d=i.readCentroidForDisplay();if(!d)return;const[m,_]=d.coords;t.recordBounds(m+p,_+x,a,c),this._writeQuad(t,n,m,_)}else if(i.geometryType==="esriGeometryPoint"){const d=i.readXForDisplay(),m=i.readYForDisplay();t.recordBounds(d+p,m+x,a,c),this._writeQuad(t,n,d,m)}else{const d=i.readGeometryForDisplay();d==null||d.forEachVertex((m,_)=>{t.recordBounds(m+p,_+x,a,c),Math.abs(m)>J||Math.abs(_)>J||this._writeQuad(t,n,m,_)})}t.recordEnd()}_writePlacedMarkers(t,i,s,r,n){var f;const o=s??((f=T.fromFeatureSetReaderCIM(i))==null?void 0:f.clone());if(!o)return;const a=-1,c=ce.getPlacement(o,a,this.evaluatedMeshParams.placement,y(1),t.id,St());if(!c)return;const u=i.getDisplayId();let l=c.next();const p=this.evaluatedMeshParams.offsetX,x=-this.evaluatedMeshParams.offsetY;for(;l!=null;){const d=l.tx,m=-l.ty;if(Math.abs(d)>J||Math.abs(m)>J){l=c.next();continue}const _=-l.getAngle();t.recordBounds(d+p,m+x,r,n),this._writeQuad(t,u,d,m,_),l=c.next()}}_writeQuad(t,i,s,r,n){const o=t.vertexCount(),a=n==null?null:{placementAngle:n};this._writeVertex(t,i,s,r,a),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const os={createComputedParams:e=>e,optionalAttributes:{},attributes:{pos:{type:h.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,pack:e=>0},offset:{type:h.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:e})=>{const t=y(e),i=-t/2,s=-t/2;return[[i,s],[i+t,s],[i,s+t],[i+t,s+t]]}}},texCoords:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:h.UNSIGNED_BYTE,count:2,pack:({size:e})=>[e,e]},referenceSize:{type:h.UNSIGNED_BYTE,count:1,pack:({size:e})=>y(e)},zoomRange:{type:h.UNSIGNED_BYTE,count:2,pack:({scaleInfo:e},{tileInfo:t})=>Q(e,t)}}};class or extends O{constructor(){super(...arguments),this.vertexSpec=os}_write(t,i){const s=i.getDisplayId(),r=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(y(this.evaluatedMeshParams.size),r);let o,a;if(i.geometryType==="esriGeometryPoint")o=i.readXForDisplay(),a=i.readYForDisplay();else{const u=i.readCentroidForDisplay();if(!u)return;o=u==null?void 0:u.coords[0],a=u==null?void 0:u.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(o,a,n,n);const c=t.vertexCount();this._writeVertex(t,s,o,a),t.indexWrite(c+0),t.indexWrite(c+1),t.indexWrite(c+2),t.indexWrite(c+1),t.indexWrite(c+3),t.indexWrite(c+2),t.recordEnd()}}export{nr as I,er as N,Wi as P,Pt as T,rr as a,Js as b,O as c,Bs as d,Ds as e,I as f,g,ae as h,Ks as i,se as j,li as k,ir as l,Q as m,bi as o,or as s,Qs as u,Us as x};
