import{e as n}from"./Evented-CXIxDjmW.js";import{_ as u,j as f,V as g,X as m,R as b,U as w,$ as y,a as C,g as R,f as k}from"./Point-DB4Hp4hH.js";import{y as p,b as M}from"./subclass-BR3PhgZG.js";import{j as h}from"./Polyline-D97hl-6E.js";import{b as P}from"./geodesicUtils-iciHABcX.js";var l;let c=l=class extends h{constructor(...e){super(...e),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}normalizeCtorArgs(e,o){let i;if(e!=null&&e.center)i=e;else{if(e!=null&&e.rings)return super.normalizeCtorArgs(e,o);i={center:e}}return{...super.normalizeCtorArgs(),...i,...o}}initialize(){const e=this.center,o=this.numberOfPoints;if(this.hasZ=(e==null?void 0:e.hasZ)??!1,this.rings.length!==0||!e)return;const i=f(this.radius,this.radiusUnit,"meters"),r=e.spatialReference;let t,s="geographic";if(r.isWebMercator?s="webMercator":((r.wkid&&g[r.wkid])!=null||(r.wkt2||r.wkt)&&m(r.wkt2||r.wkt))&&(s="projected"),this.geodesic){let a;switch(s){case"webMercator":a=b(e);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":a=e}t=this._createGeodesicCircle(a,i,o),s==="webMercator"&&(t=w(t))}else{let a;s==="webMercator"||s==="projected"?a=i/y(e.spatialReference):s==="geographic"&&(a=C(i,"meters",R(e.spatialReference).radius)),t=this._createPlanarCircle(e,a,o)}this.spatialReference=t.spatialReference,this.addRing(t.rings[0])}clone(){const{center:e,numberOfPoints:o,radius:i,radiusUnit:r,geodesic:t}=this;return new l({center:e==null?void 0:e.clone(),numberOfPoints:o,radius:i,radiusUnit:r,geodesic:t})}_createGeodesicCircle(e,o,i){let r=0;const t=[];for(;r<360;){const s=[0,0],a=[e.x,e.y];P(s,a,r,o,k.WGS84),this.hasZ&&s.push(e.z),t.push(s),r+=360/i}return t.push(t[0]),new h(t)}_createPlanarCircle(e,o,i){const r=[],t=2*Math.PI/i;for(let s=0;s<i;++s){const a=t*s,d=[e.x+Math.cos(-a)*o,e.y+Math.sin(-a)*o];this.hasZ&&d.push(e.z),r.push(d)}return r.push(r[0]),new h({spatialReference:e.spatialReference,rings:[r]})}};n([p({type:u})],c.prototype,"center",void 0),n([p()],c.prototype,"geodesic",void 0),n([p()],c.prototype,"numberOfPoints",void 0),n([p()],c.prototype,"radius",void 0),n([p()],c.prototype,"radiusUnit",void 0),c=l=n([M("esri.geometry.Circle")],c);const O=c;export{O as b};
