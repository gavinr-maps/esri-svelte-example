import"./geometry-D964gYQX.js";import{g as k,S as A,O as w}from"./subclass-BZA_h8Db.js";import{c as j,z as B,j as C}from"./Point-Cg0-ChZE.js";import{I as D}from"./vec32-Dvg_eL9J.js";import{n as E}from"./vec3f64-BLpZdpfb.js";import{b as G}from"./Circle-BInHZHdw.js";import{simplify as H,distance as J}from"./geometryEngine-DGiYLHJy.js";import{u as K,d as N,M as S,v as Q,c as V,z as W}from"./Polyline-D9YkgmM_.js";import{g as r}from"./surfaceCoordinateSystems-DhFxihAh.js";function d(s,t){const o=new C({x:s[0],y:s[1],spatialReference:t});return s.length>2&&(o.z=s[2]),o}function ot(s,t){return new K({points:s,spatialReference:t})}function rt(s,t,o){const e=new N({paths:s,spatialReference:t});return o&&S(e),e}function U(s,t,o,e=!0){const l=k(s);l.forEach(n=>{const c=n[0],i=n[n.length-1];A(c,i)&&n.length!==1||n.push(n[0])});let a=new Q({rings:l,spatialReference:t});return a.rings.forEach(n=>{V(n)||n.reverse()}),o&&S(a),e&&a.isSelfIntersecting&&j(t)&&(a=H(a)),a}function st(s,t,o){const e=t.mapToLocalMultiple(s),l=[],a={x:e[0].x,y:e[0].y},n={x:e[1].x,y:e[1].y},c=Math.round(n.x-a.x),i=Math.round(n.y-a.y),p=Math.max(Math.abs(c),Math.abs(i));if(o){const u={x:a.x+p,y:a.y+p},f={x:a.x-p,y:a.y-p};l.push(r(u.x,f.y),r(f.x,f.y),r(f.x,u.y),r(u.x,u.y))}else{const u={x:c>0?a.x+p:a.x-p,y:i>0?a.y+p:a.y-p};l.push(r(a.x,a.y),r(u.x,a.y),r(u.x,u.y),r(a.x,u.y))}return q(U([l.map(u=>t.localToMap(u)).filter(w)],t.spatialReference,t.doUnnormalization,!0),l,t)}function it(s,t,o){let e=t.mapToLocalMultiple(s);if(e.length===1){const i=e[0];e=[r(i.x-48,i.y+48),r(i.x+48,i.y-48),r(i.x+48,i.y-48),r(i.x-48,i.y+48)]}const l=[],a={x:e[0].x,y:e[0].y},n={x:e[1].x,y:e[1].y};if(o){const c=Math.round(n.x-a.x),i=Math.round(n.y-a.y);l.push(r(a.x-c,a.y-i),r(n.x,a.y-i),r(n.x,n.y),r(a.x-c,n.y))}else l.push(r(a.x,a.y),r(n.x,a.y),r(n.x,n.y),r(a.x,n.y));return q(U([l.map(c=>t.localToMap(c)).filter(w)],t.spatialReference,t.doUnnormalization,!0),l,t)}function q(s,t,o){const e=z(t[3],t[2],o),l=z(t[1],t[2],o),a=z(t[0],t[1],o),n=z(t[0],t[3],o);return{geometry:s,midpoints:e!=null&&l!=null&&a!=null&&n!=null?{top:e,right:l,bottom:a,left:n}:null}}function z(s,t,o){T[0]=s.x,T[1]=s.y,T[2]=0,b[0]=t.x,b[1]=t.y,b[2]=0,D(T,T,b,.5),I.x=T[0],I.y=b[1],I.z=b[2];const e=o.localToMap(I);return e!=null?d(e,o.spatialReference):null}const I=r(0,0,0),T=E(),b=E();function ct(s,t,o,e){const l=t.mapToLocalMultiple(s);let a=null,n=null;if(o)a=l[0],n=l[1];else{const y=l[0],x=l[1],g=Math.round(x.x-y.x),R=Math.round(x.y-y.y),h=Math.max(Math.abs(g),Math.abs(R));a=r(g>0?y.x+h/2:y.x-h/2,R>0?y.y+h/2:y.y-h/2),n=r(Math.abs(g)>Math.abs(R)?a.x-h/2:a.x,Math.abs(g)>Math.abs(R)?a.y:a.y-h/2)}const c=t.localToMap(a),i=t.localToMap(n);if(c==null||i==null)return null;t.doUnnormalization&&W([[c,i]],t.spatialReference);const p=d(c,t.spatialReference),u=d(i,t.spatialReference),f=B(t.spatialReference);let M=0;if(j(t.spatialReference))M=f*J(p,u,null);else{const y=a.x-n.x,x=a.y-n.y;M=f*Math.sqrt(y*y+x*x)*(e||1)}const $=new G({center:p,radius:M,radiusUnit:"meters",spatialReference:t.spatialReference});return{geometry:U($.rings,$.spatialReference,!1),center:p,edge:u}}function ut(s,t,o){const e=t.mapToLocalMultiple(s),l=e[0],a=e[1],n=Math.round(a.x-l.x),c=Math.round(a.y-l.y),i=r(o?l.x:l.x+n/2,o?l.y:l.y+c/2),p=o?n:n/2,u=o?c:c/2,f=60,M=[],$=2*Math.PI/f;function y(m){const F=Math.cos(m),O=Math.sin(m);return r(p*F+i.x,u*O+i.y)}for(let m=0;m<f;m++)M.push(y(m*$));M.push(M[0]);const{spatialReference:x,doUnnormalization:g}=t,R=U([M.map(m=>t.localToMap(m)).filter(w)],x,g,!1),h=t.localToMap(y(Math.PI/2)),P=t.localToMap(y(0)),L=t.localToMap(y(-Math.PI/2)),v=t.localToMap(y(Math.PI));return{geometry:R,midpoints:h!=null&&P!=null&&L!=null&&v!=null?{top:d(h,x),right:d(P,x),bottom:d(L,x),left:d(v,x)}:null}}export{ct as L,rt as R,st as T,it as b,ot as d,U as j,ut as v};
