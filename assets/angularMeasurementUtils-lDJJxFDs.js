import{a as B,n as q}from"./Cyclical-CPiNl4ru.js";import{o as c,m as z}from"./quantityUtils-1LswOhxZ.js";import{c as T,x}from"./Point-XGrwlf63.js";import{L as I}from"./vec2-maR1OrZI.js";import{m as k,n as C}from"./vec2f64-Dy6m9Nrb.js";import{H,s as L,o as v}from"./vec32-Dvg_eL9J.js";import{n as u}from"./vec3f64-BLpZdpfb.js";import{n as d}from"./projectVectorToVector-dS8io47t.js";import{N as R,q as N,j as P,b as U}from"./geodesicUtils-Bh_GX0Qj.js";var o;function V(e,r){if(e==null||r==null)return;const t=b(e,r);return t!=null?c(t,"radians","geographic"):void 0}(function(e){e.Absolute="absolute",e.Relative="relative",e.RelativeBilateral="relative-bilateral"})(o||(o={}));const b=(()=>{const e=u(),r=u();return(t,n)=>(v(e,t.x,t.y,t.z??0),v(r,n.x,n.y,n.z??0),D(e,r,t.spatialReference,n.spatialReference))})(),D=(()=>{const e=C(),r=u(),t=u();return(n,i,f,m)=>{if(H(n,i))return;const a=R(f),l=R(m);if(a&&l&&T(a,l)&&d(n,f,r,a)&&d(i,m,t,l)){const{azimuth:g}=N(F,r,t,a);return g!=null?x(g,"degrees","radians"):void 0}e[0]=i[0]-n[0],e[1]=i[1]-n[1];let s=I(k,e);return e[0]<0&&(s=G-s),s}})();function ee(e,r,t,n=o.Absolute){if(r&&t)switch(n){case o.Absolute:return V(r,t);case o.Relative:return w($(e,r,t),o.Relative);case o.RelativeBilateral:return w($(e,r,t),o.RelativeBilateral)}}function $(e,r,t){if(!e||!r||!t)return;const n=b(e,r),i=b(r,t);return n!=null&&i!=null?c(i-n,"radians","geographic"):void 0}function w(e,r){if(e!=null)switch(r){case o.Absolute:return E(e);case o.Relative:{const t=h(e);let n=y.normalize(t,0,!0);return n===-180&&(n=180),c(n,"degrees","geographic")}case o.RelativeBilateral:{const t=h(e),n=Math.abs(y.normalize(t,0,!0));return c(n,"degrees","geographic")}}}function E(e){const r=h(e),t=J.normalize(r,0,!0);return c(t,"degrees","geographic")}const te=(()=>{const e=u();return(r,t,n,i,f,m="geodesic")=>{L(e,t);const a=h(f);if(m==="geodesic"){const p=R(n);if(p&&d(e,n,e,p))return P(r,e,a,i,p),r[2]=t[2],!!d(r,p,r,n)}const l=z(a,"geographic","arithmetic"),s=x(l,"degrees","radians"),g=t[0]+i*Math.cos(s),M=t[1]+i*Math.sin(s),j=t[2];return v(r,g,M,j),!0}})();function h(e){if(e!=null)return z(A(e),e.rotationType,"geographic")}function re(e){if(e!=null)return z(A(e),e.rotationType,"arithmetic")}function A(e){return x(e.value,e.unit,"degrees")}const F=new U,G=2*Math.PI,J=B,y=new q(-180,180);export{E as A,te as M,V as R,h as T,re as U,o as j,w,ee as x,D as y};
