import{d as E}from"./Graphic-Bi5hWHps.js";import{r as l,n as h}from"./subclass-BR3PhgZG.js";import{w as y}from"./Extent-B4rrMrqp.js";import{$ as d}from"./Mesh-D9C5l95j.js";import{f as S,_ as N}from"./Point-TlcsOcXV.js";import{N as w}from"./MeshTransform-CtzYVl06.js";import{o as D,i as M}from"./External-ChjUrdf2.js";import{s as F}from"./infoFor3D-CxOdoily.js";import{d as T}from"./FeatureSet-4rZsDUx9.js";import"./Evented-CXIxDjmW.js";import"./Accessor-D6mNnsWy.js";import"./geometry-CnaxvJsv.js";import"./Polyline-BQFeqYXi.js";import"./writer-3zufXUNV.js";import"./mathUtils-ClvKsMak.js";import"./jsonMap-DCC6W5ex.js";import"./PopupTemplate-D8mXPxzU.js";import"./Clonable-cKbRam6-.js";import"./reactiveUtils-BFQ0BtrB.js";import"./shared-B3wH2qpO.js";import"./assets-BNizZMOZ.js";import"./index-BVncS3aY.js";import"./fieldUtils-C5R42-PY.js";import"./intl-CArXn1et.js";import"./Promise-CZrWwByK.js";import"./enumeration--HlxOQ_N.js";import"./Color-DDUWtbqR.js";import"./colorUtils-CS9vdHXB.js";import"./ActionToggle-C0Z1k2jc.js";import"./Identifiable-BLvpQbOc.js";import"./symbols-CfvYGR4J.js";import"./TextSymbol-zZq0BA1M.js";import"./screenUtils-PfxkaaMN.js";import"./materialUtils-CQ3JLQ1x.js";import"./opacityUtils-BT7mQkwC.js";import"./aaBoundingBox-BGxkJAW0.js";import"./persistableUrlUtils-Dx61-x4K.js";import"./collectionUtils-Dm1icNvk.js";import"./Portal-DCqdz-K4.js";import"./jsonUtils-DtWlwXHP.js";import"./axisAngleDegrees-CHCWDIqP.js";import"./mat4-ybYUU6jq.js";import"./quat-ChS85qAG.js";import"./mat3f64-BBpwCtoL.js";import"./quatf64-BrpT0VRp.js";import"./vec42-B1mBkh1w.js";import"./vec4f64-CBQL1T0x.js";import"./MeshComponent-uUfLXsBv.js";import"./imageUtils-Bwri-Uf9.js";import"./MeshVertexAttributes-De1gN3Wb.js";import"./MeshLocalVertexSpace-sBjAuOT3.js";import"./meshVertexSpaceUtils-BfF6O78E.js";import"./triangulationUtils-KizYbMMI.js";import"./earcut-BqgeR2O3.js";import"./_commonjsHelpers-DCkdB7M8.js";import"./DoubleArray-CF_CpVBS.js";import"./Indices-B6BGScAS.js";import"./plane-Bz78OrLf.js";import"./mat4f64-Dk4dwAN8.js";import"./vec2f64-Diu2Kaa8.js";import"./mathUtils-kvswLROa.js";import"./deduplicate-DxTSMkFY.js";import"./projection-CODyCdLE.js";import"./mat3-DRqs2t5W.js";import"./projection-tSh-0UvX.js";import"./projectBuffer-iyGwL2dv.js";import"./geodesicConstants-kj1AtlGg.js";import"./spatialReferenceEllipsoidUtils-DuE2W35w.js";import"./computeTranslationToOriginAndRotation-CFxYfzBj.js";import"./BufferView-B7Z-dzh4.js";import"./vec2-B_ymkwGp.js";import"./vec3-C3Q-RF_i.js";import"./vec4-L9zJLV3y.js";import"./projectPointToVector-C-hGM2ap.js";import"./vertexSpaceConversion-CtySDdI9.js";import"./Field-poIiHWUc.js";import"./fieldType-CIG5ey7e.js";const I=()=>h.getLogger("esri.rest.support.meshFeatureSet");function er(t,r,o){const e=o.features;o.features=[],delete o.geometryType;const i=T.fromJSON(o);if(i.geometryType="mesh",!o.assetMaps)return i;const n=A(r,o.assetMaps),m=t.sourceSpatialReference??S.WGS84,u=o.globalIdFieldName,{outFields:s}=t,f=s!=null&&s.length>0?L(s.includes("*")?null:new Set(s)):()=>({});for(const p of e){const a=O(p,u,m,r,n);i.features.push(new E({geometry:a,attributes:f(p)}))}return i}function L(t){return({attributes:r})=>{if(!r)return{};if(!t)return r;for(const o in r)t.has(o)||delete r[o];return r}}function O(t,r,o,e,i){const n=t.attributes[r],m=i.get(n);if(m==null||!t.geometry)return null;const u=$(t,o,e),s=y.fromJSON(t.geometry);s.spatialReference=o;const f=x(t.attributes,e),p=o.isGeographic?"local":"georeferenced",a=P(m);return a?d.createWithExternalSource(u,a,{extent:s,transform:f,vertexSpace:p}):d.createIncomplete(u,{extent:s,transform:f,vertexSpace:p})}function $({attributes:t},r,{transformFieldRoles:o}){const e=t[o.originX],i=t[o.originY],n=t[o.originZ];return new N({x:e,y:i,z:n,spatialReference:r})}function x(t,{transformFieldRoles:r}){return new w({translation:[t[r.translationX],-t[r.translationZ],t[r.translationY]],rotationAxis:[t[r.rotationX],-t[r.rotationZ],t[r.rotationY]],rotationAngle:t[r.rotationDeg],scale:[t[r.scaleX],t[r.scaleZ],t[r.scaleY]]})}var c;function A(t,r){const o=new Map;for(const e of r){const i=e.parentGlobalId;if(i==null)continue;const n=e.assetName,m=e.assetType,u=e.assetHash,s=e.assetURL,f=e.conversionStatus,p=e.seqNo,a=F(m,t.supportedFormats);if(!a){I().error("mesh-feature-set:unknown-format",`Service returned an asset of type ${m}, but it does not list it as a supported type`);continue}const g=l(o,i,()=>({files:new Map}));l(g.files,n,()=>({name:n,type:m,mimeType:a,status:b(f),parts:[]})).parts[p]={hash:u,url:s}}return o}function P(t){const r=Array.from(t.files.values()),o=new Array;for(const e of r){if(e.status!==c.COMPLETED)return null;const i=new Array;for(const n of e.parts){if(!n)return null;i.push(new D(n.url,n.hash))}o.push(new M(e.name,e.mimeType,i))}return o}function b(t){switch(t){case"COMPLETED":case"SUBMITTED":return c.COMPLETED;case"INPROGRESS":return c.PENDING;default:return c.FAILED}}(function(t){t[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"})(c||(c={}));export{A as assetMapFromAssetMapsJSON,O as extractMesh,er as meshFeatureSetFromJSON};
