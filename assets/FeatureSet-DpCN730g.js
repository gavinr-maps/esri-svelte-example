import{r as h,m as d,c as N,a as P}from"./Accessor-BHnuXKD2.js";import{b as F}from"./Graphic-CFXUQZlS.js";import{o as j}from"./cast-BA_-jlhc.js";import{S as q}from"./JSONSupport-CGdeqxpk.js";import{o as S,r as T}from"./writer-B2bQV2uU.js";import{g as w}from"./Point-XGrwlf63.js";import{f as J,y as v}from"./jsonUtils-Cu7OBRmN.js";import{l as O}from"./typeUtils-BSg8Y507.js";import{y as M}from"./Field-Cyk7Ur5d.js";var G;const z=new j({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh","":null});let c=G=class extends q{constructor(o){super(o),this.displayFieldName=null,this.exceededTransferLimit=!1,this.features=[],this.fields=null,this.geometryType=null,this.hasM=!1,this.hasZ=!1,this.queryGeometry=null,this.spatialReference=null}readFeatures(o,l){return this.readFeaturesWithClass(o,l,F)}writeGeometryType(o,l,n,e){if(o)return void z.write(o,l,n,e);const{features:i}=this;if(i){for(const t of i)if((t==null?void 0:t.geometry)!=null)return void z.write(t.geometry.type,l,n,e)}}readQueryGeometry(o,l){if(!o)return null;const n=!!o.spatialReference,e=J(o);return e&&!n&&l.spatialReference&&(e.spatialReference=w.fromJSON(l.spatialReference)),e}writeSpatialReference(o,l){if(o)return void(l.spatialReference=o.toJSON());const{features:n}=this;if(n){for(const e of n)if(e&&e.geometry!=null&&e.geometry.spatialReference)return void(l.spatialReference=e.geometry.spatialReference.toJSON())}}clone(){return new G(this.cloneProperties())}cloneProperties(){return N({displayFieldName:this.displayFieldName,exceededTransferLimit:this.exceededTransferLimit,features:this.features,fields:this.fields,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,queryGeometry:this.queryGeometry,spatialReference:this.spatialReference,transform:this.transform})}toJSON(o){const l=this.write();if(l.features&&Array.isArray(o)&&o.length>0)for(let n=0;n<l.features.length;n++){const e=l.features[n];if(e.geometry){const i=o==null?void 0:o[n];e.geometry=(i==null?void 0:i.toJSON())||e.geometry}}return l}quantize(o){const{scale:[l,n],translate:[e,i]}=o,t=r=>Math.round((r-e)/l),a=r=>Math.round((i-r)/n),u=this.features,y=this._getQuantizationFunction(this.geometryType,t,a);for(let r=0,m=u.length;r<m;r++)y!=null&&y(u[r].geometry)||(u.splice(r,1),r--,m--);return this.transform=o,this}unquantize(){var f,g;const{geometryType:o,features:l,transform:n}=this;if(!n)return this;const{translate:[e,i],scale:[t,a]}=n,u=p=>p*t+e,y=p=>i-p*a;let r=null,m=null;if(this.hasZ&&((f=n==null?void 0:n.scale)==null?void 0:f[2])!=null){const{translate:[,,p],scale:[,,x]}=n;r=R=>R*x+p}if(this.hasM&&((g=n==null?void 0:n.scale)==null?void 0:g[3])!=null){const{translate:[,,,p],scale:[,,,x]}=n;m=R=>R==null?R:R*x+p}const s=this._getHydrationFunction(o,u,y,r,m);for(const{geometry:p}of l)p!=null&&s&&s(p);return this.transform=null,this}readFeaturesWithClass(o,l,n){var t;const e=w.fromJSON(l.spatialReference),i=[];for(let a=0;a<o.length;a++){const u=o[a],y=n.fromJSON(u),r=(t=u.geometry)==null?void 0:t.spatialReference;y.geometry==null||r||(y.geometry.spatialReference=e);const m=u.aggregateGeometries,s=y.aggregateGeometries;if(m&&s!=null)for(const f in s){const g=s[f],p=m[f],x=p==null?void 0:p.spatialReference;g==null||x||(g.spatialReference=e)}i.push(y)}return i}_quantizePoints(o,l,n){let e,i;const t=[];for(let a=0,u=o.length;a<u;a++){const y=o[a];if(a>0){const r=l(y[0]),m=n(y[1]);r===e&&m===i||(t.push([r-e,m-i]),e=r,i=m)}else e=l(y[0]),i=n(y[1]),t.push([e,i])}return t.length>0?t:null}_getQuantizationFunction(o,l,n){return o==="point"?e=>(e.x=l(e.x),e.y=n(e.y),e):o==="polyline"||o==="polygon"?e=>{const i=v(e)?e.rings:e.paths,t=[];for(let a=0,u=i.length;a<u;a++){const y=i[a],r=this._quantizePoints(y,l,n);r&&t.push(r)}return t.length>0?(v(e)?e.rings=t:e.paths=t,e):null}:o==="multipoint"?e=>{const i=this._quantizePoints(e.points,l,n);return i&&i.length>0?(e.points=i,e):null}:o==="extent"?e=>e:null}_getHydrationFunction(o,l,n,e,i){return o==="point"?t=>{t.x=l(t.x),t.y=n(t.y),e&&(t.z=e(t.z))}:o==="polyline"||o==="polygon"?t=>{const a=v(t)?t.rings:t.paths;let u,y;for(let r=0,m=a.length;r<m;r++){const s=a[r];for(let f=0,g=s.length;f<g;f++){const p=s[f];f>0?(u+=p[0],y+=p[1]):(u=p[0],y=p[1]),p[0]=l(u),p[1]=n(y)}}if(e&&i)for(let r=0,m=a.length;r<m;r++){const s=a[r];for(let f=0,g=s.length;f<g;f++){const p=s[f];p[2]=e(p[2]),p[3]=i(p[3])}}else if(e)for(let r=0,m=a.length;r<m;r++){const s=a[r];for(let f=0,g=s.length;f<g;f++){const p=s[f];p[2]=e(p[2])}}else if(i)for(let r=0,m=a.length;r<m;r++){const s=a[r];for(let f=0,g=s.length;f<g;f++){const p=s[f];p[2]=i(p[2])}}}:o==="extent"?t=>{t.xmin=l(t.xmin),t.ymin=n(t.ymin),t.xmax=l(t.xmax),t.ymax=n(t.ymax),e&&t.zmax!=null&&t.zmin!=null&&(t.zmax=e(t.zmax),t.zmin=e(t.zmin)),i&&t.mmax!=null&&t.mmin!=null&&(t.mmax=i(t.mmax),t.mmin=i(t.mmin))}:o==="multipoint"?t=>{const a=t.points;let u,y;for(let r=0,m=a.length;r<m;r++){const s=a[r];r>0?(u+=s[0],y+=s[1]):(u=s[0],y=s[1]),s[0]=l(u),s[1]=n(y)}if(e&&i)for(let r=0,m=a.length;r<m;r++){const s=a[r];s[2]=e(s[2]),s[3]=i(s[3])}else if(e)for(let r=0,m=a.length;r<m;r++){const s=a[r];s[2]=e(s[2])}else if(i)for(let r=0,m=a.length;r<m;r++){const s=a[r];s[2]=i(s[2])}}:null}};h([d({type:String,json:{write:!0}})],c.prototype,"displayFieldName",void 0),h([d({type:Boolean,json:{write:{overridePolicy:o=>({enabled:o})}}})],c.prototype,"exceededTransferLimit",void 0),h([d({type:[F],json:{write:!0}})],c.prototype,"features",void 0),h([S("features")],c.prototype,"readFeatures",null),h([d({type:[M],json:{write:!0}})],c.prototype,"fields",void 0),h([d({type:["point","multipoint","polyline","polygon","extent","mesh"],json:{read:{reader:z.read}}})],c.prototype,"geometryType",void 0),h([T("geometryType")],c.prototype,"writeGeometryType",null),h([d({type:Boolean,json:{write:{overridePolicy:o=>({enabled:o})}}})],c.prototype,"hasM",void 0),h([d({type:Boolean,json:{write:{overridePolicy:o=>({enabled:o})}}})],c.prototype,"hasZ",void 0),h([d({types:O,json:{write:!0}})],c.prototype,"queryGeometry",void 0),h([S("queryGeometry")],c.prototype,"readQueryGeometry",null),h([d({type:w,json:{write:!0}})],c.prototype,"spatialReference",void 0),h([T("spatialReference")],c.prototype,"writeSpatialReference",null),h([d({json:{write:!0}})],c.prototype,"transform",void 0),c=G=h([P("esri.rest.support.FeatureSet")],c),c.prototype.toJSON.isDefaultToJSON=!0;const H=c;export{H as d};
