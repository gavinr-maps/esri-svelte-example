import{d as ne,m as Ge}from"./Viewpoint-7_owAOZm.js";import"./geometry-CnaxvJsv.js";import{d as Qn}from"./Graphic-Bi5hWHps.js";import{_ as Xe}from"./reactiveUtils-BFQ0BtrB.js";import{n as et,c as rn}from"./subclass-BR3PhgZG.js";import{n as Oe,r as nt,a as on}from"./Cyclical-BY_I03kj.js";import{s as b}from"./Accessor-D6mNnsWy.js";import{n as tt,u as at}from"./mat3-DRqs2t5W.js";import{e as it}from"./mat3f64-BBpwCtoL.js";import{e as De}from"./mat4f64-Dk4dwAN8.js";import{r as O,p as sn,g as R,f as ce,c as Z,P as G,s as U,n as p,z as te,_ as k,M as D,m as Ye,h as T,O as ue,b as ye,D as rt,l as Ee,t as ot,a1 as st,x as He,d as x,S as lt}from"./mathUtils-ClvKsMak.js";import{K as ln,I as j,H as cn}from"./projection-tSh-0UvX.js";import{u as ct}from"./computeTranslationToOriginAndRotation-CFxYfzBj.js";import{c as fe,i as me}from"./projectPointToVector-C-hGM2ap.js";import{t as ae,c as un}from"./projectVectorToPoint-GP7lggIC.js";import{n as B}from"./projectVectorToVector-BLdiwuTJ.js";import{i as ut,E as ft,w as mt,S as pt,P as fn,h as Ce,o as dt,s as gt,N as ht,I as yt}from"./aaBoundingBox-BGxkJAW0.js";import{H as wt,a as xt,J as vt,u as Mt}from"./Polyline-BQFeqYXi.js";import{l as Rt}from"./frustum-6KI4j9vx.js";import{u as bt}from"./scaleUtils-C_vWi-B7.js";import{G as Ve,l as Tt,S as Qe,m as St,f as J,g as Ie,U as $t,_ as h,n as zt}from"./Point-TlcsOcXV.js";import{T as Gt,b as we}from"./ElevationProvider-eMOI1-3B.js";import{l as Ct,f as At}from"./spatialReferenceEllipsoidUtils-DuE2W35w.js";import{l as _e}from"./ViewingMode-Dodu7ZZk.js";import{R as Pt,l as Ot,p as Dt,b as Et}from"./mat4-ybYUU6jq.js";import{w as Fe}from"./Extent-B4rrMrqp.js";import{l as Ht,s as It}from"./earthUtils-IMU84l4c.js";import{r as _t}from"./spatialReferenceSupport-B36j_qpq.js";function Ft(e){return Ve(e,Ct)||Tt(e)?{wkid:Qe.GCSMARS2000}:Ve(e,At)||St(e)?{wkid:Qe.GCSMOON2000}:J.WGS84}function pi(e,n,t,i){return e.renderCoordsHelper.fromRenderCoords(n.eye,pe,i)!=null&&wt(t,pe)}function Ut(e,n){return e.elevationProvider?e.elevationProvider.getElevation(n[0],n[1],n[2],e.renderCoordsHelper.spatialReference,"ground")??0:0}function K(e,n,t,i){const a=e.state.camera.clone();n&&t&&i&&(a.eye=n,a.center=t,a.up=i),kt(e,a.ray,A)||O(A,a.center);const r=e.state.constraints,o=r.minimumPoiDistance;if(sn(a.eye,A)<o){const s=r.collision.enabled;O(_,a.viewForward),R(_,_,o),s?a.eye=ce(pe,A,_):Z(A,a.eye,_);const l=e.renderCoordsHelper,c=l.getAltitude(a.eye),u=r.collision.elevationMargin;s&&c<u&&(ce(_,A,a.eye),a.eye=l.setAltitude(pe,u,a.eye),Z(A,a.eye,_))}return a.center=A,a}function en(e,n,t){if(!e.state.isGlobal||!e.stateManager.constraintsManager)return!1;const i=Ut(e,n),a=e.stateManager.constraintsManager.nearFarHeuristic,{far:r}=a.compute(n,t,e.renderDataExtent,i,Lt),o=r*r;return sn(n,t)>o}function kt(e,n,t){let i=nn[e.viewingMode];i||(i=Gt(e.state.viewingMode),i.options.backfacesTerrain=!e.state.isGlobal,i.options.invisibleTerrain=!0,nn[e.viewingMode]=i);const{isGlobal:a}=e.state;return!(!e.sceneIntersectionHelper.intersectRay(n,i,t)||en(e,n.origin,t))||!(!e.renderCoordsHelper.intersectManifold(n,0,t)||en(e,n.origin,t))||!!a&&jt(n,t,Ie(e.spatialReference).radius)}function jt(e,n,t){const i=G(e.origin,e.origin)-t*t,a=i>0?Math.sqrt(i)/3:1;return R(n,e.direction,a/U(e.direction)),Z(n,n,e.origin),!0}const nn={},pe=p(),A=p(),_=p(),Lt={near:0,far:0},qt=p(),re=p();function mn(){return{direction:p(),up:p()}}function pn(e,n,t,i,a){let r=te(qt,e),o=G(r,i);const s=o>0;o=Math.abs(o),o>.99&&(o=Math.abs(G(n,i)),o<.99?(O(r,n),s&&R(r,r,-1)):r=null);let l=0;if(r){R(re,i,G(i,r)),ce(r,r,re);const u=G(r,a)/(U(r)*U(a));k(re,r,a),l=(G(re,i)>0?1:-1)*D(Ye(u))}const c=D(Ye(-G(i,e)/U(e)));return t?(t.heading=l,t.tilt=c,t):{heading:l,tilt:c}}const dn=ye(0,1,0),gn=ye(0,0,1),Y=De(),$=p(),z=p();function hn(e,n,t,i=mn()){const{direction:a,up:r}=i;return Pt(Y,-T(n)),Ot(Y,Y,T(t)),ue(a,gn,Y),R(a,a,-1),ue(r,dn,Y),i}function Zt(e,n,t,i){return pn(n,t,i,gn,dn)}function Bt(e,n,t,i){const a=hn(e,t,i),r=p();return R(r,a.direction,-n),Z(r,r,e),{up:a.up,eye:r,heading:t,tilt:i}}function Wt(e){return D(e)}function Jt(e){return T(e)}function yn(e,n,t,i,a){const r=e.renderSpatialReference,o=e.map&&e.spatialReference||n.spatialReference;return fe(n,$,r),fe(n,z,r),$[0]-=t/2,z[0]+=t/2,$[1]-=i/2,z[1]+=i/2,B($,r,$,o),B(z,r,z,o),a?(a.xmin=$[0],a.ymin=$[1],a.xmax=z[0],a.ymax=z[1],a.spatialReference=o):a=new Fe($[0],$[1],z[0],z[1],o),a}const Kt=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:Zt,eyeForCenterWithHeadingTilt:Bt,eyeTiltToLookAtTilt:Jt,headingTiltToDirectionUp:hn,lookAtTiltToEyeTilt:Wt,toExtent:yn},Symbol.toStringTag,{value:"Module"})),wn=ye(0,0,1),xn=te(p(),ye(1,1,1)),Nt=new Oe(-180,180),V=De(),P=p(),L=p();function vn(e,n,t,i=mn()){k(P,e,wn),G(P,P)===0&&k(P,e,xn),Dt(V,-T(n),e),Et(V,V,-T(t),P);const{up:a,direction:r}=i;return k(a,P,e),te(a,a),ue(a,a,V),te(r,e),rt(r,r),ue(r,r,V),i}function Xt(e,n,t,i){const a=P,r=L;return te(a,e),k(L,a,wn),G(L,L)===0&&k(L,a,xn),k(r,L,a),pn(n,t,i,a,r)}function Yt(e,n,t,i){const a={eye:p(),up:null,tilt:i,heading:t},r=P;r[0]=e[0],r[1]=e[2],r[2]=-e[1];const o=n,s=T(t),l=T(i),c=Math.sin(s),u=Math.cos(s),g=Math.sin(l),f=Math.cos(l),y=U(r);let d;if(Math.abs(l)<1e-8)d=o+y;else{const Ne=y/g,Yn=Ee(o/Ne),Vn=Math.PI-l-Yn;d=Ne*Math.sin(Vn)}const S=f*o,C=o*o*(g*g),H=u*u*C,I=d-S,w=I*I,X=H*(H+w-r[1]*r[1]);if(X<0)return R(a.eye,r,d/y),a.tilt=0,oe(a,e);const Ze=Math.sqrt(X),Be=r[1]*I,We=H+w;let Je;if(Je=u>0?-Ze+Be:Ze+Be,Math.abs(We)<1e-8)return y<1e-8?(a.eye[0]=0,a.eye[1]=0,a.eye[2]=o):R(a.eye,r,d/y),a.tilt=0,Se(a.eye),oe(a,e);a.eye[1]=Je/We;const Nn=c*c*C,Re=g*o,Xn=u*Re*a.eye[1],Ke=a.eye[1]*a.eye[1],ie=1-Ke,be=Math.sqrt(ie),Te=H*Ke+Nn-2*Xn*be*I+ie*w;return Math.abs(Te)<1e-8?(R(a.eye,r,d/y),a.tilt=0,Se(a.eye),oe(a,e)):(a.eye[0]=(ie*(d*r[0]-S*r[0])-Re*be*(r[0]*a.eye[1]*u+r[2]*c))/Te,a.eye[2]=(ie*(d*r[2]-S*r[2])-Re*be*(r[2]*a.eye[1]*u-r[0]*c))/Te,R(a.eye,a.eye,d),Se(a.eye),oe(a,e))}function Se(e){const n=e[1];e[1]=-e[2],e[2]=n}function oe(e,n){const t=vn(n,e.heading,e.tilt);return e.up=t.up,e}function Vt(e,n,t){const i=U(n),a=Math.sqrt(t*t+i*i-2*t*i*Math.cos(Math.PI-e)),r=Ee(t/(a/Math.sin(e)));return D(e-r)}function Qt(e,n,t){const i=T(e),a=U(n);return Ee(t/(a/Math.sin(i)))+i}function Mn(e,n,t,i,a){let r,o,s,l;const c=n.latitude,u=Ie(e.spatialReference).radius,g=n.longitude,f=Ht(c,t,u)/2;r=g-f,o=g+f;const y=T(c),d=(1+Math.sin(y))/(1-Math.sin(y)),S=(d+1)*Math.tan(i/u/2),C=S*S;function H(w){const X=Math.PI/2;return(w=nt.normalize(w,-X))>X&&(w=Math.PI-w),w}if(s=1.5*Math.PI-2*Math.atan(.5*(S+Math.sqrt(4*d+C))),l=s+i/u,s=H(s),l=H(l),l<s){const w=l;l=s,s=w}if(s=Math.max(D(s),-90),l=Math.min(D(l),90),o=Nt.monotonic(r,o),o-r>180){const w=(o-r-180)/2;r+=w,o-=w}const I=e.spatialReference&&e.spatialReference.isGeographic?e.spatialReference:J.WGS84;return a?(a.xmin=r,a.ymin=s,a.xmax=o,a.ymax=l,a.spatialReference=I):a=new Fe(r,s,o,l,I),e.spatialReference&&e.spatialReference.isWebMercator&&$t(a,!1,a),a}const ea=Object.freeze(Object.defineProperty({__proto__:null,directionToHeadingTilt:Xt,eyeForCenterWithHeadingTilt:Yt,eyeTiltToLookAtTilt:Qt,headingTiltToDirectionUp:vn,lookAtTiltToEyeTilt:Vt,toExtent:Mn},Symbol.toStringTag,{value:"Module"})),Rn=()=>et.getLogger("esri.views.3d.support.cameraUtils"),bn=39.37,Tn=96,Ae=1,na=8,ta=5,Sn=1,tn=p(),aa={heading:0,tilt:0},ee=p(),ia=new Oe(-20037508342788905e-9,20037508342788905e-9),ra=new Oe(-180,180);var v;function E(e){return e.spatialReference??J.WGS84}function N(e){return e.viewingMode==="global"?ea:Kt}function di(e,n,t,i,a){return N(e).headingTiltToDirectionUp(n,t,i,a)}function oa(e,n){if(n==null)return null;const t=e.renderSpatialReference,i=N(e).headingTiltToDirectionUp,a=p();if(!fe(n.position,a,t))return null;const r=i(a,n.heading,n.tilt);R(r.direction,r.direction,e.state.camera.distance),Z(r.direction,r.direction,a);const o=K(e,a,r.direction,r.up);return o.fov=T(n.fov),o.row=n.layout.row,o.rows=n.layout.rows,o.column=n.layout.column,o.columns=n.layout.columns,o}(function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"})(v||(v={}));const q=p();function xe(e,n,t){const i=e.renderSpatialReference,a=ke(e,n.eye,n.viewForward,n.up,aa);let r=E(e);return B(n.eye,i,q,r)||(r=J.WGS84,B(n.eye,i,q,r)),t==null?t=new ne(new h(q,r),a.heading,a.tilt,D(n.fov)):(t.position.x=q[0],t.position.y=q[1],t.position.z=q[2],t.position.spatialReference=r,t.heading=a.heading,t.tilt=a.tilt,t.fov=D(n.fov)),t.layout.row=n.row,t.layout.rows=n.rows,t.layout.column=n.column,t.layout.columns=n.columns,t}function Ue(e,n,t){const i=e.state.camera,a=i.width/2/i.pixelRatio;return e.renderCoordsHelper.viewingMode===_e.Global&&t!=null&&(n*=Math.cos(T(t))),n/=e.renderCoordsHelper.unitInMeters,a/(Tn*bn/n)/Math.tan(i.fovX/2)}function W(e,n,t){const i=e.state.camera,a=n*Math.tan(i.fovX/2),r=i.width/2/i.pixelRatio;let o=Tn*bn/(r/a);return e.renderCoordsHelper.viewingMode===_e.Global&&t!=null&&(o/=Math.cos(T(t))),o*e.renderCoordsHelper.unitInMeters}async function $n(e,n,t,i,a,r){return zn(e,n,Ue(e,t,n.latitude),i,a,r)}function sa(e,n,t,i,a,r){return jn(e,Cn(e,i.heading,i.tilt,n,t,a),i.fov,r)}async function zn(e,n,t,i,a,r){const o=await An(e,i.heading,i.tilt,n,t,a,r);return b(r),Ln(e,o,i.fov,r)}function ke(e,n,t,i,a){return N(e).directionToHeadingTilt(n,t,i,a)}function Gn(e,n){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(n,ee,e.spatialReference)&&e.elevationProvider&&(we(e.elevationProvider,ee)??0)>ee[2]-Sn)}async function la(e,n,t){if(Gn(e,n))return!0;const{elevationProvider:i,spatialReference:a,renderCoordsHelper:r}=e;if(i==null||!r.fromRenderCoords(n,ee,a))return!1;const[o,s,l]=ee,c=await i.queryElevation(o,s,l,a,"ground",t)??0;return b(t),c>l-Sn}async function ca(e,n,t){const i=p();if(n==null)return O(i,e.state.camera.center);if(n instanceof h){const{renderSpatialReference:a,basemapTerrain:r,elevationProvider:o}=e,s=n.spatialReference;if(await me(n,i,a,0,{signal:t}),b(t),n.z==null&&r!=null&&o!=null){const l=await o.queryElevation(n.x,n.y,n.z??0,s,"ground",t);b(t),l!=null&&e.renderCoordsHelper.setAltitude(i,l)}return i}return O(i,n)}function ua(e,n){const t=p();if(n==null)return O(t,e.state.camera.center);if(n instanceof h){if(!fe(n,t,e.renderSpatialReference))return null;const{basemapTerrain:i,elevationProvider:a}=e;if(n.z==null&&i!=null&&a!=null){const r=we(a,n);r!=null&&e.renderCoordsHelper.setAltitude(t,r)}return t}return O(t,n)}function Cn(e,n,t,i,a,r){return Pn(e,n,t,i instanceof h?i:null,ua(e,i),a,r)}async function An(e,n,t,i,a,r,o){const s=i instanceof h?i:null,l=await ca(e,i,o);return b(o),On(e,n,t,s,l,a,r,o)}function Pn(e,n,t,i,a,r,o){if(a==null||!i&&(i=new h({spatialReference:E(e)}),!ae(a,e.renderSpatialReference,i)))return null;const s=Dn(e,n,t,a,r,o);if(En(e,t,o)&&Gn(e,s.eye)){const{tilt:l,mode:c}=Hn(e,t,a,r);return Pn(e,n,l,i,a,r,c)}return In(s,a)}async function On(e,n,t,i,a,r,o,s){i||(i=new h({spatialReference:E(e)}),await un(a,e.renderSpatialReference,i,{signal:s})||(i=null)),b(s);const l=Dn(e,n,t,a,r,o);if(En(e,t,o)&&await la(e,l.eye,s)){b(s);const{tilt:c,mode:u}=Hn(e,t,a,r);return On(e,n,c,i,a,r,u,s)}return In(l,a)}function Dn(e,n,t,i,a,r){const o=pa(e,n,t,i,a=Math.max(a,e.state.constraints.minimumPoiDistance),r);return(0,N(e).eyeForCenterWithHeadingTilt)(i,a,o.heading,o.tilt)}function En(e,n,t){const i=e.map.ground.navigationConstraint;return t===v.ADJUST&&e.viewingMode==="global"&&n>0&&(i==null||i.type==="stay-above")}function Hn(e,n,t,i){const a=kn(e,t,i,ga(e,i,n,t));return{tilt:a,mode:n-a<1?v.LOCKED:v.ADJUST}}function In(e,n){return{...e,center:ot(n)}}function _n(e,n){const{state:t,spatialReference:i}=e,a=n.spatialReference;return t.isGlobal&&_t(a,_e.Global)||t.isLocal&&i.equals(a)}function Fn(e,n){let t,i,a;if(e.state.isGlobal){const u=new h(n.xmin,n.ymin,n.spatialReference),g=new h(n.xmax,n.ymax,n.spatialReference),f=n.spatialReference.isGeographic?ra:ia;t=new h({x:f.center(u.x,g.x),y:(g.y+u.y)/2,z:n.zmax!=null&&n.zmin!=null?(n.zmax+n.zmin)/2:void 0,spatialReference:n.spatialReference});const y=Ie(n.spatialReference),d=It(t,u,g);i=d.lon,a=d.lat,f.diff(u.x,g.x)>f.range/2&&(i+=y.halfCircumference),i=Math.min(i,y.halfCircumference),a=Math.min(a,y.halfCircumference)}else{const u=e.renderSpatialReference??n.spatialReference;u.equals(n.spatialReference)||(n=ln(n,u)),i=n.xmax-n.xmin,a=n.ymax-n.ymin;const g=n.zmax!=null&&n.zmin!=null?(n.zmax+n.zmin)/2:void 0;t=new h({x:n.xmin+.5*i,y:n.ymin+.5*a,z:g,spatialReference:u})}const r=n.zmax!=null&&n.zmin!=null?n.zmax-n.zmin:0,o=e.state.camera,s=1/Math.tan(o.fovX/2),l=1/Math.tan(o.fovY/2),c=1/Math.tan(o.fov/2);return{center:t,distance:Math.max(.5*i*s,.5*a*l,.5*r*c)/Ae}}async function Un(e,n,t,i,a,r){const o=_n(e,n)?n:await j(n,e.spatialReference,{signal:r});b(r);const{center:s,distance:l}=Fn(e,o),c=await An(e,t,i,s,l,a,r);return b(r),Ln(e,c,e.camera.fov,r)}function fa(e,n,t,i,a,r){let o;try{o=_n(e,n)?n:ln(n,e.spatialReference)}catch{return null}const{center:s,distance:l}=Fn(e,o),c=Cn(e,t,i,s,l,a);return c==null?null:jn(e,c,e.camera.fov,r)}function gi(e,n,t){const i=e.renderSpatialReference,a=new h({spatialReference:E(e)});if(!ae(t,i,a))return null;const r=Math.tan(n.fovX/2),o=Math.tan(n.fovY/2),s=st(n.eye,t),l=2*s*r*Ae,c=2*s*o*Ae;return e.viewingMode==="global"?Mn(e,a,l,c):yn(e,a,l,c)}function ma(e,n,t){const i=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(t/i)/Math.LN2>na)return!0;const a=n,r=e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;return He(a,r)/(Math.tan(.5*e.state.camera.fov)*i)>ta}function pa(e,n,t,i,a,r){let o=0;return r===v.ADJUST&&ma(e,i,a)?(n=0,o=da(e,a,t,i)):o=je(e,i,a,t),o=e.state.constraints.clampTilt(a,o),{heading:n,tilt:t=kn(e,i,a,o)}}const de=.7;function da(e,n,t,i){const a=je(e,i,n,t);if(!e.state.constraints.tilt)return a;const r=e.state.constraints.tilt(n);r.max=Math.min(r.max,.5*Math.PI);const o=r.min*(1-de)+r.max*de;return Math.min(a,o)}function ga(e,n,t,i){let a=je(e,i,n,t);if(!e.state.constraints.tilt)return a;const r=e.state.constraints.tilt(n);return a=Math.min(a,.5*Math.PI),r.min*(1-de)+a*de}function kn(e,n,t,i){return N(e).lookAtTiltToEyeTilt(i,n,t)}function je(e,n,t,i){return N(e).eyeTiltToLookAtTilt(i,n,t)}function jn(e,n,t,i){if(n==null)return null;const a=e.renderSpatialReference,r=new h({spatialReference:E(e)});return ae(n.eye,a,r)?(i??(i=new ne),i.position=r,i.heading=n.heading,i.tilt=n.tilt,i.fov=t,i):null}async function Ln(e,n,t,i){const a=e.renderSpatialReference,r=new h({spatialReference:E(e)});return await un(n.eye,a,r,{signal:i}),b(i),new ne(r,n.heading,n.tilt,t)}function hi(e,n){var i;const t=(i=e.basemapTerrain)==null?void 0:i.tilingScheme;if(t)return t.levelAtScale(n);Rn().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function ha(e,n){var i;const t=(i=e.basemapTerrain)==null?void 0:i.tilingScheme;if(t)return t.scaleAtLevel(n);Rn().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function qn(e,n){const{renderSpatialReference:t}=e,i=Ft(t);let a=null;try{B(n.center,t,tn,i)&&(a=tn[1])}catch{}return W(e,n.distance,a)}const ya=.66;function Zn(e){return 360-on.normalize(e)}function ve(e){return on.normalize(360-e)}function wa(e,n,t){const i=n.camera;if(i!=null)return xa(i,E(e));const{targetGeometry:a}=n;if(a==null)return null;const{camera:r,mode:o}=Wn(e,n.rotation,t);if(a.type==="point")return Ma(e,n,a,r,o);const s=a.extent;return s==null?null:fa(e,s,r.heading,r.tilt,o)}async function Bn(e,n,t,i){const a=n.camera;if(a!=null)return va(a,E(e),i);const{targetGeometry:r}=n;if(r==null)throw new Error("Viewpoint has no targetGeometry!");const{camera:o,mode:s}=Wn(e,n.rotation,t);if(r.type==="point")return Ra(e,n,r,o,s,i);const l=r.extent;if(l==null)throw new Error("Target geometry has no extent!");return Un(e,l,o.heading,o.tilt,s,i)}function xa(e,n){const t=e.position;let i;try{i=cn(t,n)}catch{return null}if(!i)return null;const a=e.clone();return a.position=i.clone(),a}async function va(e,n,t){const i=e.position,a=await j(i,n,{signal:t});b(t);const r=e.clone();return r.position=a.clone(),r}function Wn(e,n,t){const i=xe(e,e.state.camera);let a=v.ADJUST;return n!=null&&(i.heading=Zn(n),a=v.LOCKED),t!=null&&(i.tilt=t),{camera:i,mode:a}}function Ma(e,n,t,i,a){const r=e.spatialReference;let o;try{o=cn(t.clone(),r)}catch{return null}if(!o)return null;const s=n.scale!=null?Ue(e,n.scale,o.latitude):e.state.camera.distance;return sa(e,o,s,i,a)}async function Ra(e,n,t,i,a,r){const o=e.spatialReference,s=await j(t.clone(),o,{signal:r});b(r);const l=n.scale!=null?Ue(e,n.scale,s.latitude):e.state.camera.distance;return zn(e,s,l,i,a,r)}function ba(e,n,t=null){return t==null&&(t=new Ge),qe(e,null,n.clone(),t)}async function Ta(e,n,t){const i=Ea(e,n);if(!i)throw new rn("viewpointutils-create:no-target","Missing target for creating viewpoint");const a=new ne({fov:e.camera.fov}),r=new Ge({camera:a});if(i.target instanceof Ge)return F(await za(e,i.target,i,t,r));if(i.target instanceof ne)return F(await Kn(e,i.target,t,r));const o=i.scale!=null||i.zoom!=null;if(i.target instanceof Fe){const c=i.target.xmin===i.target.xmax||i.target.ymin===i.target.ymax;return F(o||c?await Pe(e,i,i.target.center,a,t,r):await Pa(e,i,i.target,a,t,r))}const s=new Ia,l=o?Sa(e,i):void 0;if(await Jn(e,i.target,l,s,t),isFinite(s.boundingBox[0])){let c;if(ft(s.boundingBox,m),M.x=m[0],M.y=m[1],M.z=m[2],M.spatialReference=e.spatialReference,isFinite(M.z)&&s.hasZ?c=mt(s.boundingBox):(M.z=void 0,c=vt(pt(s.boundingBox,_a))),o||c)return F(await Pe(e,i,M,a,t,r));const u=Ha(e,s.screenSpaceObjects);return F(await Da(e,i,M,s.boundingBox,u,a,t,r))}return i.position?F(await Ca(e,i,a,r,t)):F(await Aa(e,i,a,t,r))}function Le(e,n){return n.scale==null&&n.zoom!=null?ha(e,n.zoom):n.scale}function Sa(e,n){const t=Le(e,n);return t?bt(t):void 0}function Me(e,n){let t=!1;return n.heading!=null?(e.heading=n.heading,t=!0):n.rotation!=null&&(e.heading=Zn(n.rotation),t=!0),n.tilt!=null&&(e.tilt=n.tilt,t=!0),n.fov!=null&&(e.fov=n.fov),t}function qe(e,n,t,i){const a=e.spatialReference||J.WGS84;if(n??(n=oa(e,t)),n==null)return i;const r=new h({spatialReference:a});if(!ae(n.center,e.renderSpatialReference,r))return i;i.targetGeometry=r;const{latitude:o}=r;return i.scale=o!=null?W(e,n.distance,o):qn(e,n),i.rotation=ve(t.heading),i.camera=t,i}async function ge(e,n,t,i){var g;const a=()=>new rn("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!n)throw a();n.type==="mesh"&&(n=n.extent);const r=e.basemapTerrain.spatialReference;if(!n.hasZ&&e.basemapTerrain){let f;switch(n.type){case"point":f=n;break;case"multipoint":case"polyline":f=(g=n.extent)==null?void 0:g.center;break;case"extent":f=n.center;break;case"polygon":f=n.centroid}f!=null&&r&&e.elevationProvider?(f=await j(f,r,{signal:i}),m[2]=we(e.elevationProvider,f)??0):m[2]=0}const o=Fa[n.type],s=new Array;if(o(n,n.hasZ?f=>{s.push([f[0],f[1],f[2]])}:f=>{s.push([f[0],f[1]])},m),s.length===0)throw a();const l=n.spatialReference,c=e.spatialReference,u=await j(new Mt({spatialReference:l,hasZ:n.hasZ,hasM:!1,points:s}),c,{signal:i});if(n.hasZ&&(t.hasZ=!0),n.hasZ)for(const[f,y,d]of u.points)m[0]=f,m[1]=y,m[2]=d,Ce(t.boundingBox,m);else for(const[f,y]of u.points)m[0]=f,m[1]=y,Ce(t.boundingBox,m)}async function $a(e,n,t,i,a){const r=await Xe(e.whenViewForGraphic(n));if(r.ok===!1||r.value==null||!("whenGraphicBounds"in r.value))return void await ge(e,n.geometry,i,a);const o=r.value,s=await Xe(o.whenGraphicBounds(n,{minDemResolution:t}));if(s.ok===!1||!s.value)return void await ge(e,n.geometry,i,a);const{screenSpaceObjects:l,boundingBox:c}=s.value;dt(i.boundingBox,c),l&&l.forEach(u=>{i.screenSpaceObjects.push(u)}),isFinite(c[2])&&(i.hasZ=!0)}async function Jn(e,n,t,i,a){var r;if(Array.isArray(n)&&n.length===2){const o=n[0],s=n[1];if(typeof o=="number"&&typeof s=="number")return M.x=o,M.y=s,M.z=void 0,M.spatialReference=(r=e.spatialReference)!=null&&r.isGeographic?e.spatialReference:J.WGS84,void await ge(e,M,i,a)}n&&"map"in n&&typeof n.map=="function"?await Promise.allSettled(n.map(o=>Jn(e,o,t,i,a))):n instanceof zt?await ge(e,n,i,a):n instanceof Qn&&await $a(e,n,t,i,a)}async function za(e,n,t,i,a){if(n.camera)return Kn(e,n.camera,i,a);a.scale=n.scale,a.rotation=n.rotation,a.targetGeometry=n.targetGeometry!=null?n.targetGeometry.clone():null,a.camera=null,t.heading!=null?a.rotation=ve(t.heading):t.rotation!=null&&(a.rotation=t.rotation);const r=Le(e,t);return r!=null&&(a.scale=r),a.camera=await Bn(e,a,t.tilt,i),a}async function Kn(e,n,t,i){const a=e.spatialReference,r=await j(n.position,a,{signal:t}),o=n.clone();return o.position=r,qe(e,null,o,i)}async function Ga(e,n,t,i,a,r,o){const s=e.renderSpatialReference;return await me(n,$e,s,0,{signal:o}),await me(t,le,s,0,{signal:o}),r.targetGeometry=new h(n),a.position=new h(t),ce(he,$e,le),ke(e,le,he,i.up,a),r.scale=W(e,He(le,$e),r.targetGeometry.latitude),r.rotation=ve(a.heading),r.camera=a,r}async function Pe(e,n,t,i,a,r){r.targetGeometry=t.clone();const o=K(e);if(n.position)return Ga(e,r.targetGeometry,n.position,o,i,r,a);if(n.zoomFactor){const l=o.distance/n.zoomFactor,c=R(m,o.viewForward,-l);o.eye=Z(m,o.center,c),r.scale=W(e,l,t.latitude)}xe(e,o,i);const s=Me(i,n)?v.LOCKED:v.ADJUST;if(!n.zoomFactor){const l=Le(e,n);l==null?(await me(t,m,e.renderSpatialReference,0,{signal:a}),Rt(o.frustum,m)?r.scale=W(e,He(o.eye,m),t.latitude):r.scale=qn(e,o)):r.scale=l,r.camera=await $n(e,r.targetGeometry,r.scale,i,s,a)}return r}async function Ca(e,n,t,i,a){const r=K(e);O(he,r.viewForward),ke(e,r.eye,he,r.up,ze);const o=e.spatialReference,{position:s}=n;if(s){const l=await j(s,o,{signal:a});t.position=l}else t.position=new h;return t.heading=n.heading!=null?n.heading:ze.heading,t.tilt=n.tilt!=null?n.tilt:ze.tilt,qe(e,null,t,i)}async function Aa(e,n,t,i,a){if(n.heading!=null||n.rotation!=null||n.scale!=null||n.tilt!=null||n.zoom!=null||n.zoomFactor!=null){const r=K(e),{spatialReference:o,renderSpatialReference:s}=e,l=new h({spatialReference:o});return ae(r.center,s,l)?Pe(e,n,l,t,i,a):a}return a.scale=e.scale,a.camera=e.camera.clone(),Me(a.camera,n),a}async function Pa(e,n,t,i,a,r){r.targetGeometry=t.clone();const o=K(e);xe(e,o,i);const s=Me(i,n)?v.LOCKED:v.ADJUST;return r.camera=await Un(e,t,i.heading,i.tilt,s,a),r}function Oa(e,n,t,i,a){let r=0;t.z!=null?r=t.z:e.basemapTerrain&&e.elevationProvider&&(r=we(e.elevationProvider,t)),x(m,t.x,t.y,r),ct(e.spatialReference,m,an,e.renderSpatialReference),tt(se,an),at(se,se),fn(Q);const o=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let d=0;d<o.length;d++){const S=o[d];let C=i[S[2]];isFinite(C)||(C=r),x(m,i[S[0]],i[S[1]],C),B(m,e.spatialReference,m,e.renderSpatialReference),Ce(Q,lt(m,m,se))}const s=gt(Q),l=ht(Q),c=yt(Q),u=1/Math.tan(n.fovX/2),g=1/Math.tan(n.fovY/2),f=.5*Math.sqrt(s*s+c*c)*Math.max(g,u)+.5*l,y=.5*l*g+.5*Math.max(s,c);return Math.max(f,y)/a}async function Da(e,n,t,i,a,r,o,s){s.targetGeometry=t.clone();const l=K(e),c=Oa(e,l,t,i,a);xe(e,l,r);const u=Me(r,n)?v.LOCKED:v.ADJUST;return s.scale=W(e,c,s.targetGeometry.latitude),s.camera=await $n(e,s.targetGeometry,s.scale,r,u,o),s}function Ea(e,n){if(!n||!e.spatialReference)return null;const t={target:void 0};return"declaredClass"in n||Array.isArray(n)?t.target=n:(Object.assign(t,n),!t.target&&"center"in n&&n.center&&(t.target=n.center)),t}function F(e){return(e==null?void 0:e.camera)!=null&&(e.rotation=ve(e.camera.heading)),e}function Ha(e,n){const t=ya;if(!n.length)return t;let i=Number.NEGATIVE_INFINITY;for(let a=0;a<n.length;a++){const r=n[a].screenSpaceBoundingRect;i=Math.max(i,Math.abs(r[0]),Math.abs(r[1]),Math.abs(r[2]),Math.abs(r[3]))}return t-i/Math.min(e.width,e.height)*2}class Ia{constructor(){this.hasZ=!1,this.boundingBox=fn(),this.screenSpaceObjects=new Array}}const m=p(),an=De(),se=it(),Q=ut(),_a=xt(),he=p(),le=p(),$e=p(),ze={heading:0,tilt:0},M=new h,Fa={point(e,n,t){t[0]=e.x,t[1]=e.y,e.z!=null&&(t[2]=e.z),n(t)},polygon(e,n,t){const i=e.hasZ;for(let a=0;a<e.rings.length;a++){const r=e.rings[a];for(let o=0;o<r.length;o++)t[0]=r[o][0],t[1]=r[o][1],i&&(t[2]=r[o][2]),n(t)}},polyline(e,n,t){const i=e.hasZ;for(let a=0;a<e.paths.length;a++){const r=e.paths[a];for(let o=0;o<r.length;o++)t[0]=r[o][0],t[1]=r[o][1],i&&(t[2]=r[o][2]),n(t)}},multipoint(e,n,t){const i=e.points,a=e.hasZ;for(let r=0;r<i.length;r++)t[0]=i[r][0],t[1]=i[r][1],a&&(t[2]=i[r][2]),n(t)},extent(e,n,t){e.zmin!=null&&e.zmax!=null?(n(x(t,e.xmin,e.ymin,e.zmin)),n(x(t,e.xmax,e.ymin,e.zmin)),n(x(t,e.xmin,e.ymax,e.zmin)),n(x(t,e.xmax,e.ymax,e.zmin)),n(x(t,e.xmin,e.ymin,e.zmax)),n(x(t,e.xmax,e.ymin,e.zmax)),n(x(t,e.xmin,e.ymax,e.zmax)),n(x(t,e.xmax,e.ymax,e.zmax))):(n(x(t,e.xmin,e.ymin,t[2])),n(x(t,e.xmax,e.ymin,t[2])),n(x(t,e.xmin,e.ymax,t[2])),n(x(t,e.xmax,e.ymax,t[2])))}},yi=Object.freeze(Object.defineProperty({__proto__:null,create:Ta,fromCamera:ba,toCameraAsync:Bn,toCameraSync:wa},Symbol.toStringTag,{value:"Module"}));export{Ue as $,ha as A,v as K,di as N,hi as P,xe as Q,gi as R,oa as Z,W as _,pi as a,Cn as c,Ta as d,Ut as f,K as g,ba as h,wa as l,ke as r,mn as u,yi as v,fa as w};
