import{j as V}from"./Point-XGrwlf63.js";import{V as q,z as G,m as J}from"./rasterProjectionHelper-BYBh__EP.js";class K{constructor(n=15e3,e=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=n,this._interval=Math.min(n,e)}decreaseRefCount(n,e){const t=n+"/"+e,o=this._cachedBlocks;if(o.has(t)){const r=o.get(t);return r.refCount--,r.refCount<=0&&(o.delete(t),r.controller&&r.controller.abort()),r.refCount}return 0}getBlock(n,e){const t=n+"/"+e,o=this._cachedBlocks;if(o.has(t)){const r=o.get(t);return r.ts=Date.now(),r.refCount++,o.delete(t),o.set(t,r),r.block}return null}putBlock(n,e,t,o){const r=this._cachedBlocks,c=n+"/"+e;if(r.has(c)){const s=r.get(c);s.ts=Date.now(),s.refCount++}else r.set(c,{block:t,ts:Date.now(),refCount:1,controller:o});this._trim(),this._updateTimer()}deleteBlock(n,e){const t=this._cachedBlocks,o=n+"/"+e;t.has(o)&&t.delete(o)}updateMaxSize(n){this._size=n,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const n=this._cachedBlocks;this._timer=setInterval(()=>{const e=Array.from(n),t=Date.now();for(let o=0;o<e.length&&e[o][1].ts<=t-this._duration;o++)n.delete(e[o][0]);n.size===0&&this._clearTimer()},this._interval)}_trim(){const n=this._cachedBlocks;if(this._size===-1||this._size>=n.size)return;const e=Array.from(n);for(let t=0;t<e.length-this._size;t++)n.delete(e[t][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}}const f=new Map,d=new K;function U(l,n){return n==null?l:`${l}?sliceId=${n}`}function X(l,n){const e={extent:null,rasterInfo:n,cache:new Map},t=f.get(l);return t?(t.push(e),t.length-1):(f.set(l,[e]),0)}function Y(l,n){const e=f.get(l);e&&(e[n]=null,e.some(t=>t!=null)||f.delete(l))}function Z(l,n,e){var c,s;const t=f.get(l);if(!t)return n==null?d.decreaseRefCount(l,e):0;if(n==null||t[n]==null)return d.decreaseRefCount(l,e);const o=(c=t[n])==null?void 0:c.cache,r=o==null?void 0:o.get(e);if(o&&r){if(r.refCount--,r.refCount===0){o.delete(e);for(let i=0;i<t.length;i++)(s=t[i])==null||s.cache.delete(e);r.controller&&r.controller.abort()}return r.refCount}return 0}function ee(l,n,e){var r,c,s;const t=f.get(l);if(!t)return n==null?d.getBlock(l,e):null;if(n==null||t[n]==null){for(let i=0;i<t.length;i++){const a=(r=t[i])==null?void 0:r.cache.get(e);if(a)return a.refCount++,a.block}return d.getBlock(l,e)}const o=(c=t[n])==null?void 0:c.cache.get(e);if(o)return o.refCount++,o.block;for(let i=0;i<t.length;i++){if(i===n||!t[i])continue;const a=(s=t[i])==null?void 0:s.cache,m=a==null?void 0:a.get(e);if(a&&m)return m.refCount++,a.set(e,m),m.block}return null}function te(l,n,e,t,o=null){var s;const r=f.get(l);if(!r)return void(n==null&&d.putBlock(l,e,t,o));if(n==null||r[n]==null)return void d.putBlock(l,e,t,o);const c={refCount:1,block:t,isResolved:!1,isRejected:!1,controller:o};t.then(()=>c.isResolved=!0).catch(()=>c.isRejected=!0),(s=r[n])==null||s.cache.set(e,c)}function ne(l,n,e){var o;const t=f.get(l);t?n!=null&&t[n]!=null?(o=t[n])==null||o.cache.delete(e):d.deleteBlock(l,e):n==null&&d.deleteBlock(l,e)}function N(l,n){const e=f.get(l);return e?e[n]??null:null}function oe(l,n,e,t,o,r,c=null){const s=N(l,n);if(!s)return;const i=s.extent,{cache:a,rasterInfo:m}=s;if(i&&i.xmin===e.xmin&&i.xmax===e.xmax&&i.ymin===e.ymin&&i.ymax===e.ymax)return;t=t??0;const C=e.clone().normalize(),{spatialReference:M,transform:R}=m,w=new Set;for(let _=0;_<C.length;_++){const u=C[_];if(u.xmax-u.xmin<=t||u.ymax-u.ymin<=t)continue;let h=q(u,M,c);R!=null&&(h=R.inverseTransform(h));const D=new V({x:t,y:t,spatialReference:u.spatialReference});if(o==null&&!(o=G(D,M,u,c)))return;const{pyramidLevel:k,pyramidResolution:H,excessiveReading:S}=J(o,m,r||"closest");if(S)return;const{storageInfo:x}=m,{origin:v}=x,{x:z,y:b}=H,$=Math.max(0,Math.floor((h.xmin-v.x)/z)),I=Math.max(0,Math.floor((v.y-h.ymax)/b)),W=Math.ceil(h.width/z-.1),A=Math.ceil(h.height/b-.1),T=k>0?x.pyramidBlockWidth:x.blockWidth,j=k>0?x.pyramidBlockHeight:x.blockHeight,g=x.blockBoundary[k];if(!g)continue;const y=1,E=Math.max(g.minCol,Math.floor($/T)-y),F=Math.max(g.minRow,Math.floor(I/j)-y),L=Math.min(g.maxCol,Math.floor(($+W-1)/T)+y),P=Math.min(g.maxRow,Math.floor((I+A-1)/j)+y);for(let p=F;p<=P;p++)for(let B=E;B<=L;B++)w.add(`${k}/${p}/${B}`)}a.forEach((_,u)=>{if(!w.has(u)){const h=a.get(u);(h==null||h.isResolved||h.isRejected)&&a.delete(u)}}),s.extent={xmin:e.xmin,ymin:e.ymin,xmax:e.xmax,ymax:e.ymax}}export{Y as a,oe as g,te as h,U as i,ee as m,Z as s,X as u,ne as x};
