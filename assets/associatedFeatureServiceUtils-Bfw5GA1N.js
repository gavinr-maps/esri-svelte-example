import{d as g,P as y,s as A}from"./cast-BA_-jlhc.js";import{s as f,V as m}from"./Accessor-BHnuXKD2.js";import{C as T}from"./Portal-CTRRujjZ.js";import I from"./PortalItem-CXk7DqVv.js";async function E(e,n){const a=g(e);if(!a)throw new f("invalid-url","Invalid scene service url");const r={...n,sceneServerUrl:a.url.path,layerId:a.sublayer??void 0};if(r.sceneLayerItem??(r.sceneLayerItem=await $(r)),r.sceneLayerItem==null)return S(r.sceneServerUrl.replace("/SceneServer","/FeatureServer"),r);const t=await q(r);if(!(t!=null&&t.url))throw new f("related-service-not-found","Could not find feature service through portal item relationship");r.featureServiceItem=t;const l=await S(t.url,r);return l.portalItem=t,l}async function $(e){const n=(await U(e)).serviceItemId;if(!n)return null;const a=new I({id:n,apiKey:e.apiKey}),r=await b(e);r!=null&&(a.portal=new T({url:r}));try{return await a.load({signal:e.signal})}catch(t){return m(t),null}}async function U(e){if(e.rootDocument)return e.rootDocument;const n={query:{f:"json",...e.customParameters,token:e.apiKey},responseType:"json",signal:e.signal};try{const a=await y(e.sceneServerUrl,n);e.rootDocument=a.data}catch{e.rootDocument={}}return e.rootDocument}async function b(e){var r;const n=(r=A)==null?void 0:r.findServerInfo(e.sceneServerUrl);if(n!=null&&n.owningSystemUrl)return n.owningSystemUrl;const a=e.sceneServerUrl.replace(/(.*\/rest)\/.*/i,"$1")+"/info";try{const t=(await y(a,{query:{f:"json"},responseType:"json",signal:e.signal})).data.owningSystemUrl;if(t)return t}catch(t){m(t)}return null}async function S(e,n){var v,w,h;const a=g(e);if(!a)throw new f("invalid-feature-service-url","Invalid feature service url");const r=a.url.path,t=n.layerId;if(t==null)return{serverUrl:r};const l=U(n),s=n.featureServiceItem?await n.featureServiceItem.fetchData("json"):null,j=(h=((v=s==null?void 0:s.layers)==null?void 0:v[0])||((w=s==null?void 0:s.tables)==null?void 0:w[0]))==null?void 0:h.customParameters,d=o=>{const P={query:{f:"json",...j},responseType:"json",authMode:o,signal:n.signal};return y(r,P)},D=d("anonymous").catch(()=>d("no-prompt")),[p,c]=await Promise.all([D,l]),u=c==null?void 0:c.layers,i=p.data&&p.data.layers;if(!Array.isArray(i))throw new Error("expected layers array");if(Array.isArray(u)){for(let o=0;o<Math.min(u.length,i.length);o++)if(u[o].id===t)return{serverUrl:r,layerId:i[o].id}}else if(t!=null&&t<i.length)return{serverUrl:r,layerId:i[t].id};throw new Error("could not find matching associated sublayer")}async function q({sceneLayerItem:e,signal:n}){if(!e)return null;try{const a=(await e.fetchRelatedItems({relationshipType:"Service2Service",direction:"reverse"},{signal:n})).find(t=>t.type==="Feature Service")||null;if(!a)return null;const r=new I({portal:a.portal,id:a.id});return await r.load(),r}catch(a){return m(a),null}}export{E as s};
