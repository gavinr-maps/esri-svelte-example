import{a as B,n as I}from"./Cyclical-oTUX3aX7.js";import{o as u,m as z}from"./quantityUtils-D0GB2dMc.js";import{s as q,I as w}from"./Point-Cg0-ChZE.js";import{L as T}from"./vec2-maR1OrZI.js";import{_ as k,n as C}from"./vec2f64-miziP1SN.js";import{H,s as L,o as v}from"./vec32-Dvg_eL9J.js";import{n as c}from"./vec3f64-BLpZdpfb.js";import{n as d}from"./projectVectorToVector-G2uWGoIb.js";import{N as R,q as N,j as P,b as U}from"./geodesicUtils-FCYOaNwu.js";var o;function V(e,r){if(e==null||r==null)return;const t=b(e,r);return t!=null?u(t,"radians","geographic"):void 0}(function(e){e.Absolute="absolute",e.Relative="relative",e.RelativeBilateral="relative-bilateral"})(o||(o={}));const b=(()=>{const e=c(),r=c();return(t,n)=>(v(e,t.x,t.y,t.z??0),v(r,n.x,n.y,n.z??0),_(e,r,t.spatialReference,n.spatialReference))})(),_=(()=>{const e=C(),r=c(),t=c();return(n,i,f,m)=>{if(H(n,i))return;const a=R(f),l=R(m);if(a&&l&&q(a,l)&&d(n,f,r,a)&&d(i,m,t,l)){const{azimuth:g}=N(E,r,t,a);return g!=null?w(g,"degrees","radians"):void 0}e[0]=i[0]-n[0],e[1]=i[1]-n[1];let s=T(k,e);return e[0]<0&&(s=F-s),s}})();function ee(e,r,t,n=o.Absolute){if(r&&t)switch(n){case o.Absolute:return V(r,t);case o.Relative:return A(y(e,r,t),o.Relative);case o.RelativeBilateral:return A(y(e,r,t),o.RelativeBilateral)}}function y(e,r,t){if(!e||!r||!t)return;const n=b(e,r),i=b(r,t);return n!=null&&i!=null?u(i-n,"radians","geographic"):void 0}function A(e,r){if(e!=null)switch(r){case o.Absolute:return D(e);case o.Relative:{const t=h(e);let n=M.normalize(t,0,!0);return n===-180&&(n=180),u(n,"degrees","geographic")}case o.RelativeBilateral:{const t=h(e),n=Math.abs(M.normalize(t,0,!0));return u(n,"degrees","geographic")}}}function D(e){const r=h(e),t=G.normalize(r,0,!0);return u(t,"degrees","geographic")}const te=(()=>{const e=c();return(r,t,n,i,f,m="geodesic")=>{L(e,t);const a=h(f);if(m==="geodesic"){const p=R(n);if(p&&d(e,n,e,p))return P(r,e,a,i,p),r[2]=t[2],!!d(r,p,r,n)}const l=z(a,"geographic","arithmetic"),s=w(l,"degrees","radians"),g=t[0]+i*Math.cos(s),j=t[1]+i*Math.sin(s),x=t[2];return v(r,g,j,x),!0}})();function h(e){if(e!=null)return z($(e),e.rotationType,"geographic")}function re(e){if(e!=null)return z($(e),e.rotationType,"arithmetic")}function $(e){return w(e.value,e.unit,"degrees")}const E=new U,F=2*Math.PI,G=B,M=new I(-180,180);export{D as A,te as M,V as R,h as T,re as U,o as j,A as w,ee as x,_ as y};
